diff --git a/Documentation/devicetree/bindings/bus/renesas,msebi.txt b/Documentation/devicetree/bindings/bus/renesas,msebi.txt
new file mode 100644
index 0000000..f294490
--- /dev/null
+++ b/Documentation/devicetree/bindings/bus/renesas,msebi.txt
@@ -0,0 +1,66 @@
+Device tree bindings for Renesas Medium Speed External Bus Interface (MSEBI)
+found on the RZ/N1 device.
+
+The actual devices are instantiated from the child nodes of a MSEBI node.
+
+Required properties:
+
+ - compatible:		Should contain "renesas,rznr-msebi"
+- reg:			A resource specifier for the register space
+			(see the example below)
+ - clocks:		the clock, see the example below.
+ - #address-cells:	Must be set to 2 to allow memory address translation
+ - #size-cells:		Must be set to 1 to allow CS address passing
+ - ranges:		Must be set up to reflect the memory layout with four
+			integer values for each chip-select line in use:
+			   <cs-number> 0 <physical address of mapping> <size>
+
+ - renesas,msebi-config: The value to write into the CONFIG register.
+
+ - renesas,msebi-config-dirbuf: The value to write into the CONFIG_DIRBUF
+			register.
+ 
+Timing property for child nodes.
+
+ - renesas,msebi-cs-timing: The timing array, contains timing values for the
+			child node. We can get the CS index from the child
+			node's "reg" property. It consists of 3 registers values
+			that correspond to:
+			CYCLESIZE_CSn register value.
+			SETUPHOLD_CSn register value.
+			CONFIG_CSn register value.
+
+Example for an RZ/N1 device, with two 8-bit synchronous memories attached:
+
+	msebi: msebim: memory-controller@RZN1_MSEBI_M0_BASE {
+		compatible = "renesas,rzn1-msebi";
+		#address-cells = <2>;
+		#size-cells = <1>;
+		reg = <RZN1_MSEBI_M0_BASE RZN1_MSEBI_M0_SIZE>;
+		clocks = <&clk_fw_msebi_m>;
+		ranges = <
+			0 0 0x60000000 0x08000000
+			1 0 0x68000000 0x08000000
+			2 0 0x70000000 0x08000000
+			3 0 0x78000000 0x08000000
+		>;
+		renesas,msebi-config = <0x00000490>;
+		renesas,msebi-config-dirbuf = <0x00000000>;
+		interrupts = <GIC_SPI RZN1_IRQ_MSEBIM IRQ_TYPE_LEVEL_HIGH>;
+		status = "okay";
+
+		cs0: cs0@0,0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0 0x00000000 0x04000000>;
+			// Synchronous 8-bit
+			renesas,msebi-cs-timing = <0x00000000 0x00010001 0x00000005>;
+		};
+		cs1: cs1@0,0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <1 0x00000000 0x04000000>;
+			// Synchronous 8-bit
+			renesas,msebi-cs-timing = <0x00000000 0x00010001 0x00000005>;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/clock/renesas,rzn1-clocks.txt b/Documentation/devicetree/bindings/clock/renesas,rzn1-clocks.txt
new file mode 100644
index 0000000..48cb2c5
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/renesas,rzn1-clocks.txt
@@ -0,0 +1,241 @@
+Renesas RZN1 Clock Binding Documentation
+
+This binding uses the common clock binding[1] with extensions.
+
+[1] Documentation/devicetree/bindings/clock/clock-bindings.txt
+
+1] Rationale
+------------
+The Renesas RZN1 device tree clock structure is mostly autogenerated from the
+specification document. The data was extracted from a variety of such
+documents, with the goal of being able to follow these documents and
+re-generate these files if/when the specification evolves.
+
+A number of clock drivers are in place to handle the various features of the
+clock tree:
+	+ renesas,rzn1-clock is the 'container' driver, it's only real job is to
+	  map the SYSCTRL io block that will be used by all the other
+	  drivers.
+	+ renesas,rzn1-clock-gate is a mapping that creates a generic clk-gate
+	  using the information extracted from the clock gate table (see 3]).
+	+ renesas,rzn1-clock-divider is a driver that is derived from the
+	  generic clk-divider linux driver, but has been simplified in some
+	  ways, and the primary feature it needed was to handle the
+	  SYSCTRL 'BUSY' flag that is paired with each divider in the SYSCTRL
+	  block.
+	+ renesas,rzn1-clock-selector is a mapping that creates a generic
+	  clk-mux for the clock that can have multiple sources.
+	+ renesas,rzn1-clock-bitselect is a clock privider that allows one bit
+	  to change the clock source of multiple sub clocks.
+	+ renesas,rzn1-clock-dualgate is a clock provider that is always a
+	  subclock of a bitselect block, as these clock source have different
+	  clock gates depending on which source is selected (!).
+	+ renesas,rzn1-clock-group is a clock provider that allows multiple
+	  clocks to be claimed and enabled while masquerading as a single
+	  source.
+
+2] Clock Container
+------------------
+The renesas,rzn1-clocks driver exists only to be the first one that is loaded,
+to ensure that the SYSCTRL registers are mapped for all the other sub-drivers
+to use.
+It also provides a /sys/kernel/rzn1/ interface with the following files:
+	+ /sys/kernel/rzn1/clk_set_rate
+	  This file allows userland to change the clock rate of anything that
+	  will allow it. It was mainly made to test the clock infrastructure,
+	  however it could be used for other purposes
+
+3] Clock Gates
+--------------
+The first important piece of data is the clock gates; all of these were
+extracted automatically from the SYSCTRL block documentation. Each of the gates
+was extracted, it's named derived from the register it is in, and an optional
+reset and 'slave ready' bit was also extracted at the same time.
+
+Each of these gates were given a number, and are all listed in the
+	./include/dt-bindings/clock/rzn1-clocks.h file.
+
+For a given rzn1-clocks.h definition, for example:
+
+	#define RZN1_CLK_ADC			24
+
+You will find in rzn1-clkctrl-tables.h in the table that allow reverse mapping
+that arbitrary number to a set of register and bits:
+
+	[RZN1_PCLK_ADC] =
+		_CLK("pclk_adc", _BIT(13, 15), _BIT(13, 16), _BIT(13, 17)),
+
+The _BIT() macro has the register number (as a 32 bit word) in the SYSCTRL
+block, so here '13' means RZN1_SYSCTRL_REG_PWRCTRL_BASICS_0 as defined in
+the file:
+
+	./include/dt-bindings/soc/rzn1-sysctrl.h
+
+The Device Mapping is otherwise very simple:
+	clk_adc: clk_adc {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_ADC>;
+		clocks = <&div_adc>;
+	};
+The <reg> property specifies the clock number, that is all that is needed, the
+driver will map that back to a register/bit pair, and create a clk_gate with
+it.
+
+
+4] Clock Divider
+----------------
+Each divider has a standard format register in SYSCTRL, containing a few
+bits for the divider and a BUSY bit, as bit 31.
+The mapping is therefore pretty easy too:
+	div_adc: div_adc {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <50>;
+		renesas,rzn1-div-max = <250>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_BASICS_ADCDIV>;
+		clocks = <&clkout>;
+	};
+The <renesas,rzn1-bit-mask> specifies the bits that needs to be set in the <reg>
+register. The <reg> register uses a define from the file:
+	./include/dt-bindings/soc/rzn1-sysctrl.h
+The <renesas,rzn1-div-min> and <renesas,rzn1-div-max> are the minimum and
+maximum values for this divider, inclusive.
+
+Some of the clock dividers are not linear, you can't use every divider values
+between min and max, therefore there is an extra property that that specifies
+the set of valid values:
+	rtos_mdc: hw_rtos_mdc: hw_rtos_mdc {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3ff>;
+		renesas,rzn1-div-min = <80>;
+		renesas,rzn1-div-max = <640>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV>;
+		renesas,rzn1-div-table = <80 160 320 640>;
+		clocks = <&clk_ref_sync>;
+	};
+Only the values specified in renesas,rzn1-div-table will be used in that
+register, and the frequency requested will be adjusted to the value that is
+nearest the target value using the corresponding divider value.
+
+5] Clock Selector
+-----------------
+Some clocks can have different source clocks, that source clock is specified by
+a register that is not in the SYSCTRL register block.
+	clk_ptp_mac0: mac0_clk_ptp_ref_i: mac0_clk_ptp_ref_i {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		reg = <0xdeadbeef 4>;
+		renesas,rzn1-bit-mask = <0x3>;
+		renesas,rzn1-bit-shift = <12>;
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk25>, <&clk50>;
+	};
+The 'reg' property specifies a physical address for the register that contains
+the mux bits, the renesas,rzn1-bit-mask contains the mask for that register, and
+the optional renesas,rzn1-bit-shift contains the position the mask should be
+shifted to. If renesas,rzn1-bit-shift is not specified, the
+renesas,rzn1-bit-mask is used to derivate it, so you can write:
+		renesas,rzn1-bit-mask = <0x30>;
+And this will be the equivalent of:
+		renesas,rzn1-bit-mask = <0x3>;
+		renesas,rzn1-bit-shift = <4>;
+NOTE: none of the 'reg' properties for the clock-selector nodes are populated
+at this moment, as the register blocks they are in is currently unknown.
+
+6] Clock Bit-Select
+-------------------
+The renesas,rzn1-clock-bitselect driver exists only to support the 2 groups of
+uarts on the machine. All the uarts can have 2 distinctive clock sources, but
+not independently of each others. One bit will change the clock source of all
+the uarts in that group.
+To make things more complicated, there are 2 clock gates per uart, one for
+each of the potential clock source.
+It sort of looks like this:
+
+    Clock Source 1 -----   bit    /--- Gate 1 Uart 0 --\
+                        \ +---+  /  |- Gate 1 Uart 1    \    +------+
+                         -| 0 |-/   |- Gate 1 Uart 2     \---| dual |-- Uart 0
+                        /-| 1 |-\                        /---| gate |    Clock
+                       /  +---+  \---- Gate 2 Uart 0 ---/    +------+
+    Clock Source 2 ----   select    |- Gate 2 Uart 1
+                                    |- Gate 2 Uart 2           ...
+
+So the purpose of the bit-select and dualgate clocks are to make it appear that
+there is a single gate to turn on/off for each uart, and the driver will know
+which gate to activate/deactivate depending on the bit-select current status.
+Likewise, when the bit-select changes, all the sub clocks dual gate will turn
+off the previous clock source gate, and will turn on the new gate.
+
+The instantiation of a clock-bitselect goes like this:
+	 uart_group_012: uart_group_012 {
+		...
+
+		compatible = "renesas,rzn1-clock-bitselect";
+		/* Bit 24 is UARTCLKSEL */
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_BASICS_0>;
+		renesas,rzn1-sel-bit = <30>;
+
+		/* If that bit is zero, use first parent, else,
+		 * use second parent */
+		clocks = <&div_uart>, <&clk_48>;
+
+		/* First group are gates for when selector bit
+		 * is zero, second group is the gates to use when
+		 * bit is 'one' */
+		renesas,rzn1-gates =
+		      <RZN1_SCLK_UART0 RZN1_SCLK_UART1
+			RZN1_SCLK_UART2>,
+		      <RZN1_SCLK_USB_UART0 RZN1_SCLK_USB_UART1
+			RZN1_SCLK_USB_UART2>;
+		...
+	};
+The <reg> property specifies the name of the SYSCTRL register where the bit is
+defined, and the renesas,rzn1-sel-bit specified which bit it is.
+The renesas,rzn1-gates specifies two groups of 'gates'; the first group is the
+gates that are to be used when the bit is zero, the second group for went the
+bit is 1.
+
+Next come the sub-clock instantiation, the renesas,rzn1-clock-dualgate are
+required to be instantiated in the renesas,rzn1-clock-bitselect block.
+		gsclk_uart0: gsclk_uart0 {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-dualgate";
+			clocks = <&uart_group_012>;
+			reg = <0>;
+		 };
+The 'clocks' property links that clock back to the bitselect group, and the
+'reg' property is the index of the gate to use in the renesas,rzn1-gates
+property.
+
+7] Clock Grouping
+-----------------
+There are a lot of IP blocks that rely on having multiple clocks enabled,
+even something as simple as a uart requires a SCLK and a PCLK, however, most
+linux driver will not enable clocks others than the ones they explicitly
+require.
+Therefore, a clock driver 'group' was created as renesas,rzn1-clock-group that
+allows to specify one single clock per driver, while still preparing and
+claiming other 'associated' clocks.
+For example:
+		 sclk_uart0_grp: sclk_uart0_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart0 &pclk_uart0>;
+		 };
+This will group gsclk_uart0 pclk_uart0 together. The driver will transparently
+appear as gsclk_uart0, but will also enable and disable pclk_uart0 along with
+the sclk.
+This grouping is prevent having to patch multiple linux drivers to force
+enable multiple clocks.
+
+8] Clock tree inspection & tweak
+--------------------------------
+The clock tree can be monitored using debugfs (assuming your kernel has debugfs
+compiled in).
+# mount -t debugfs / /sys/kernel/debug/
+# cd /sys/kernel/debug/
+# cat clk/clk_summary
+You can then also change the clock rates, for clocks nodes that can:
+# echo div_ca7 250000000 >/sys/kernel/rzn1/clk_set_rate
diff --git a/Documentation/devicetree/bindings/dma/snps-dma.txt b/Documentation/devicetree/bindings/dma/snps-dma.txt
index 0f55832..f7199c1 100644
--- a/Documentation/devicetree/bindings/dma/snps-dma.txt
+++ b/Documentation/devicetree/bindings/dma/snps-dma.txt
@@ -1,7 +1,7 @@
 * Synopsys Designware DMA Controller
 
 Required properties:
-- compatible: "snps,dma-spear1340"
+- compatible: "snps,dma-spear1340" or "snps,dma-rzn1"
 - reg: Address range of the DMAC registers
 - interrupt: Should contain the DMAC interrupt number
 - dma-channels: Number of channels supported by hardware
@@ -21,6 +21,11 @@ Deprecated properties:
 - data_width: Maximum data width supported by hardware per AHB master
   (0 - 8bits, 1 - 16bits, ..., 5 - 256bits)
 
+If compatible with "snps,dma-rzn1", the following properties are required:
+- rzn1_cfg_dmamux: This value is masked with the rzn1_cfg_dmamux_mask value and
+  then written to the RZ/N1 SYSCTRL CFG_DMAMUX register. This register switches
+  dma request signal between different peripherals.
+- rzn1_cfg_dmamux_mask: See rzn1_cfg_dmamux.
 
 Optional properties:
 - interrupt-parent: Should be the phandle for the interrupt controller
diff --git a/Documentation/devicetree/bindings/fb/db9000fb.txt b/Documentation/devicetree/bindings/fb/db9000fb.txt
new file mode 100644
index 0000000..75f0b39
--- /dev/null
+++ b/Documentation/devicetree/bindings/fb/db9000fb.txt
@@ -0,0 +1,59 @@
+* Digital Blocks DB9000 LCD Controller
+
+Required properties:
+- compatible: Should be "digitalblocks,db9000-clcd".
+- reg: Address and length of the register set for lcdif
+- interrupts: Should contain lcdif interrupts
+- display : phandle to display node (see below for details)
+- clocks: Clock phandles to the pixel and bus (ahb) clocks.
+
+Optional properties:
+- backlight-pwm-clock : If using the DB9000 PWM output for a backlight, this
+  specifies the PWM output clock required.
+- blink-period-ms : If built with CONFIG_FB_DB9000_BLINK, this specifies the
+  blink period in ms, see the config menu.
+- bus-width : The width of the interface to the LCD panel that is actually
+  used. This is only needed if the bits-per-pixel property is set to 16 or
+  less, but the board connects to a 24-bit panel. In which case, the controller
+  will shift the 16-bit data to the most significant bits of the panel. If the
+  buffer is less than 16bpp, the controller will use a palette to effectively
+  generate 16bpp data for the panel.
+
+* display node
+
+Required properties:
+- bits-per-pixel : <1>, <2>, <4>, <8> for paletted RGB565, <16> for RGB565,
+  <24> for packed RGB888, <32> for RGB888.
+
+Required sub-node:
+- display-timings : Refer to binding doc display-timing.txt for details.
+
+Examples:
+
+fb0: fb@RZN1_LCD_BASE {
+	compatible = "digitalblocks,db9000-clcd";
+	interrupts = <GIC_SPI RZN1_IRQ_LCD IRQ_TYPE_LEVEL_HIGH>;
+	reg = <RZN1_LCD_BASE RZN1_LCD_SIZE>;
+	clock-names = "pclk", "ahb";
+	clocks = <&clk_slcd>, <&clk_ahb_lcd>;
+	status = "okay";
+
+	bits-per-pixel = <32>;
+	display-timings {
+		native-mode = <&timing0>;
+		timing0: timing0 {
+			clock-frequency = <8000000>;
+			hactive = <320>;
+			vactive = <240>;
+			hback-porch = <68>;
+			hfront-porch = <20>;
+			vback-porch = <18>;
+			vfront-porch = <4>;
+			hsync-len = <2>;
+			vsync-len = <2>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+		};
+	};
+};
diff --git a/Documentation/devicetree/bindings/mtd/renesas,rzn1-qspi.txt b/Documentation/devicetree/bindings/mtd/renesas,rzn1-qspi.txt
new file mode 100644
index 0000000..7f872ed
--- /dev/null
+++ b/Documentation/devicetree/bindings/mtd/renesas,rzn1-qspi.txt
@@ -0,0 +1,95 @@
+* MTD QSPI driver for RZN1
+
+This driver should contains subnodes that corresponds to the m25p80.txt format,
+with a few optional options.
+
+Required properties:
+- #address-cells, #size-cells : Must be present if the device has sub-nodes
+      representing flash devices on different CS lines.
+- compatible : Should be "renesas,rzn1-qspi".
+- reg-names : "qspi", "qspi-mapping" -- necessary to locate which address range
+      is the register one, and which one is the memory map for the flash.
+- clock-names : must be "flexway", "pclk"
+
+Optional properties:
+- renesas,rzn1-cs_mux[ = <0/1>];
+	This specifies wether we want to use the discrete CS lines (default
+	mode) to handle up to 4 NOR chips, or if we want to use the 'mux'
+	mode that can handle up to 16 of them.
+	Note that this property is optional (default to zero), and it will also
+	default to '1' in the case any of the sub flashes specified below have
+	a CS number >3
+Furthermore, each sub node for each chip may contain (on top of the m25p80):
+- spi-max-frequency: Same definition as spi-bus
+- spi-rx-bus-width : Same definition as spi-bus
+- spi-cpha : Same definition as spi-bus
+- spi-cpol : Same definition as spi-bus
+
+- renesas,rzn1-read-cmd [ = <COMMAND DUMMY ADDR_MUX>];
+	Syntax is:
+	    + COMMAND: Read Array opcode to use
+	    + DUMMY: Number of dummy/mode cycles
+	    + ADDR_MUX: 0/1: If the address sent to the NOR flash is sent on
+			     multiple pins.
+	The number of address bytes is optional, if not set here (or zero)
+	the driver will rely on what the spi-nor framework decides to set it
+	to. It's likely it will attempt to set the device forcibly in 4 bytes
+	mode, which can be an issue at reset time (for the ROM and such) if
+	the SPI NOR doesn't have a dedicated coupled reset line.
+	IMPORTANT NOTE: Use of this property requires the SPI NOR flash to be
+		marked as SPI_NOR_DUAL_READ and/or SPI_NOR_QUAD_READ in the
+		spi-nor driver in drivers/mtd/spi-nor/spi-nor.c -- without this
+		flag, the driver will fail to work.
+- renesas,rzn1-readcap-delay = <N>;
+	Specifies the read delay to use when talking to the flash at high speed
+	The value can be probed using u-boot and should be constant for each
+	type of flash, however board layout might have some impact.
+
+Example:
+
+spi@RZN1_QSPI_BASE {
+	compatible = "renesas,rzn1-qspi";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	reg = <RZN1_QSPI_BASE RZN1_QSPI_SIZE
+		RZN1_V_QSPI_BASE RZN1_V_QSPI_SIZE>;
+	reg-names = "qspi", "qspi-mapping";
+	interrupts = <GIC_SPI
+		RZN1_IRQ_QSPI0 IRQ_TYPE_LEVEL_HIGH>;
+	clocks = <&clk_fw_qspi0>, <&clk_qspi0>;
+	clock-names = "flexway", "pclk";
+	status = "okay";
+
+	renesas,rzn1-cs_mux = <0>;
+
+	flash: mx25l12805@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "st,mx25l12805d";
+		reg = <0>;
+		spi-max-frequency = <62500000>;
+		spi-cpha;
+		spi-cpol;
+
+		/* Use 0x6b command to read data on 4 lines,
+		   using 8 dummy cycles, and
+		   the address is also sent on 4 lines.
+		   Check your datasheet for the 'optimal' opcode to use;
+		   the spi-nor upper layer defaults to slightly less
+		   optimal opcodes */
+		spi-rx-bus-width = <4>;
+		renesas,rzn1-read-cmd = <0x6b 8 1>;
+
+		renesas,rzn1-readcap-delay = <1>;
+
+		partition@0 {
+			/* 1MB */
+			label = "loader";
+			reg = <0x000000 0x00100000>;
+		};
+		partition@1 {
+			/* 1MB */
+			label = "u-boot";
+			reg = <0x100000 0x00100000>;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/net/can/sja1000.txt b/Documentation/devicetree/bindings/net/can/sja1000.txt
index ac3160e..f294ae5 100644
--- a/Documentation/devicetree/bindings/net/can/sja1000.txt
+++ b/Documentation/devicetree/bindings/net/can/sja1000.txt
@@ -44,6 +44,10 @@ Optional properties:
 
 - nxp,no-comparator-bypass : Allows to disable the CAN input comparator.
 
+- nxp,no-cdr : Indicates that the Clock Divider Register is not present.
+
+- nxp,no-loopback : Indicates the hardware does not looback messages.
+
 For further information, please have a look to the SJA1000 data sheet.
 
 Examples:
diff --git a/Documentation/devicetree/bindings/pci/pci-rcar-gen2.txt b/Documentation/devicetree/bindings/pci/pci-rcar-gen2.txt
index 07a7509..45dda63 100644
--- a/Documentation/devicetree/bindings/pci/pci-rcar-gen2.txt
+++ b/Documentation/devicetree/bindings/pci/pci-rcar-gen2.txt
@@ -10,6 +10,7 @@ Required properties:
 	      "renesas,pci-r8a7791" for the R8A7791 SoC;
 	      "renesas,pci-r8a7793" for the R8A7793 SoC;
 	      "renesas,pci-r8a7794" for the R8A7794 SoC;
+	      "renesas,pci-rzn1" for the RZ/N1 SoC;
 	      "renesas,pci-rcar-gen2" for a generic R-Car Gen2 compatible device
 
 
diff --git a/Documentation/devicetree/bindings/spi/snps,dw-apb-ssi.txt b/Documentation/devicetree/bindings/spi/snps,dw-apb-ssi.txt
index 204b311..3e13d87 100644
--- a/Documentation/devicetree/bindings/spi/snps,dw-apb-ssi.txt
+++ b/Documentation/devicetree/bindings/spi/snps,dw-apb-ssi.txt
@@ -12,6 +12,8 @@ Optional properties:
 - num-cs : The number of chipselects. If omitted, this will default to 4.
 - reg-io-width : The I/O register width (in bytes) implemented by this
   device.  Supported values are 2 or 4 (the default).
+- dmas : Two dma phandles, one for rx, one for tx
+- dma-names : Must be "rx", "tx"
 
 Child nodes as per the generic SPI binding.
 
@@ -26,5 +28,8 @@ Example:
 		num-cs = <2>;
 		cs-gpios = <&gpio0 13 0>,
 			   <&gpio0 14 0>;
+		dmas =  <&dma0 8 0 0>,
+			<&dma0 9 0 0>;
+		dma-names = "rx", "tx";
 	};
 
diff --git a/Documentation/devicetree/bindings/spi/spi-dw.txt b/Documentation/devicetree/bindings/spi/spi-dw.txt
index 7b63ed6..10cf7bb 100644
--- a/Documentation/devicetree/bindings/spi/spi-dw.txt
+++ b/Documentation/devicetree/bindings/spi/spi-dw.txt
@@ -11,6 +11,12 @@ Required properties:
 
 Optional properties:
 - cs-gpios: see spi-bus.txt
+- renesas,rzn1-cs-mode: specify software/hardware modes for CS lines.
+  This version of the controller has a 'software mode' that allows the
+  SPI layer to control the CS line as it sees fit, instead of letting the
+  hardware toggle it -- this is necessary for talking to flash chips, eeproms
+  etc. The value is a bitfield, with bits corresponds to individual lines, and
+  '1' means 'use software CS' and 0 means 'default to hardware mode'.
 
 Example:
 
@@ -21,4 +27,5 @@ spi: spi@4020a000 {
 	clocks = <&pclk>;
 	num-cs = <2>;
 	cs-gpios = <&banka 0 0>;
+	renesas,rzn1-cs-mode = <0x3>;
 };
diff --git a/Documentation/devicetree/bindings/usb/renesas,usbf.txt b/Documentation/devicetree/bindings/usb/renesas,usbf.txt
new file mode 100644
index 0000000..a884e22
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/renesas,usbf.txt
@@ -0,0 +1,80 @@
+Required properties :
+ - compatible : Should be "renesas,usbf".
+ - reg : Offset and length of the register set for the device.
+ - clock-names: needs to be "axi".
+ - clocks: must refer to the clock used by the IP.
+ - interrupts: Should list the two interrupts needed by the IP
+
+Optional Properties:
+ - renesas,sram-conf[,<gadget-name>]
+	This property allows you to specify the SRAM allocated per
+	endpoint types, OR the SRAM allocated for each endpoint
+	individually.
+	In the first instance, if you specify a 3 element array, this
+	specifies the number of USB packets per endpoint /type/, for
+	example:
+		renesas,sram-ep-packets = <4 3 0>;
+	Will allocate 4 packets (of 512, implicitly) to the bulk
+	endpoints (first element); 3 packets (or whatever size the
+	descriptor specifies) to the interrupt endpoints, and the default
+	value (which is 2, incidentally) of packets to the isochronous
+	endpoints.
+	In the second instance, you can specify the number of packets
+	per endpoint by passing an array of more than 3 elements:
+		renesas,sram-conf = <
+			4 4 0 0 0	/* -bulk endpoints */
+			4 0 0 0		/* -int endpoints */
+			0 0 0 0 0 0>;	/* -iso endpoints */
+	In this case, you can specify the size to the endpoints you
+	know are being used.
+	Note that you can tie a memory configuration for a particular
+	gadget configuration; the driver will first look for the property
+	name concatenated with the currently configured gadget before
+	doing a fallback on the generic name. Thus:
+		renesas,sram-conf,g_ether = <6 2 0>;
+		renesas,sram-conf = <2 8 0>;
+	This is a valid declaration providing a configuration for the
+	RNDIS g_ether driver, and another configuration for any other
+	cases/gadget.
+
+ - renesas,sram-size
+	The renesas IP can be configured with variable amount of SRAM,
+	variable type/number of endpoints, and some of them disabled.
+	The sram-size property is the only one that cannot be inferred
+	by probing, so this properly allows you to specify it as per
+	your device configuration.
+	The SRAM size is just used to make sure you don't allocate too
+	much using the renesas,sram-conf property, it can be left out,
+	but doing so will prevent any warning from being emitted, and
+	that could result in silent failure.
+	NOTE: The ram size value is the number of 32 bits words in SRAM,
+	      and NOT a byte value.
+		renesas,sram-size = <5024>;
+
+ - renesas,dma-threshold
+	Specifies the packet size at below which we don't even attempt
+	to do a DMA transfer. The DMA introduces some latency as the IRQ
+	needs to be routed back to the driver, so a small packet size with DMA
+	might take longer to transfer than sending it using plain PIO.
+	The threshold is by default 64, however, it was not set using any
+	measurement, so the value probably should be measured using proper
+	empirical testing for the use you make of the driver.
+
+Example:
+	usbf: usbf@RZN1_USB_DEV_BASE {
+		compatible = "renesas,usbf";
+		reg = <RZN1_USB_DEV_BASE RZN1_USB_DEV_SIZE>;
+		interrupts =
+			<GIC_SPI
+				RZN1_IRQ_USBF_EPC IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI
+				RZN1_IRQ_USBF IRQ_TYPE_LEVEL_HIGH>;
+		clock-names = "axi";
+		clocks = <&clk_fw_usb_f>;
+
+		renesas,sram-size = <5024>; /* 32 bits words */
+		renesas,sram-conf,g_ether = <6 6 0 0 0 4>;
+		renesas,sram-conf,g_mass_storage = <8 8 0 0 0 0>;
+		renesas,dma-threshold = <64>;
+		status = "okay";
+	};
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.txt b/Documentation/devicetree/bindings/vendor-prefixes.txt
index f0a48ea..5a87107 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.txt
+++ b/Documentation/devicetree/bindings/vendor-prefixes.txt
@@ -73,6 +73,7 @@ delta	Delta Electronics, Inc.
 denx	Denx Software Engineering
 digi	Digi International Inc.
 digilent	Diglent, Inc.
+digitalblocks	Digital Blocks, Inc.
 dlg	Dialog Semiconductor
 dlink	D-Link Corporation
 dmo	Data Modul AG
@@ -177,6 +178,7 @@ mpl	MPL AG
 mqmaker	mqmaker Inc.
 msi	Micro-Star International Co. Ltd.
 mti	Imagination Technologies Ltd. (formerly MIPS Technologies Inc.)
+mtip	MoreThanIP
 mundoreader	Mundo Reader S.L.
 murata	Murata Manufacturing Co., Ltd.
 mxicy	Macronix International Co., Ltd.
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index b5d529f..db06652 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -804,6 +804,8 @@ source "arch/arm/mach-realview/Kconfig"
 
 source "arch/arm/mach-rockchip/Kconfig"
 
+source "arch/arm/mach-rzn1/Kconfig"
+
 source "arch/arm/mach-sa1100/Kconfig"
 
 source "arch/arm/mach-socfpga/Kconfig"
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 6be9ee1..291bfa58 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -200,6 +200,7 @@ machine-$(CONFIG_ARCH_QCOM)		+= qcom
 machine-$(CONFIG_ARCH_REALVIEW)		+= realview
 machine-$(CONFIG_ARCH_ROCKCHIP)		+= rockchip
 machine-$(CONFIG_ARCH_RPC)		+= rpc
+machine-$(CONFIG_ARCH_RZN1) 		+= rzn1
 machine-$(CONFIG_ARCH_S3C24XX)		+= s3c24xx
 machine-$(CONFIG_ARCH_S3C64XX)		+= s3c64xx
 machine-$(CONFIG_ARCH_S5PV210)		+= s5pv210
diff --git a/arch/arm/boot/dts/rzn1-clocks.dtsi b/arch/arm/boot/dts/rzn1-clocks.dtsi
new file mode 100644
index 0000000..2ccbcd9
--- /dev/null
+++ b/arch/arm/boot/dts/rzn1-clocks.dtsi
@@ -0,0 +1,1069 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+
+&clocks {
+	clk_25_pg4: clk_25_pg4@RZN1_CLK_25MHZ_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG4_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_25_pg5: clk_25_pg5@RZN1_CLK_25MHZ_PG5_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG5_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_25_pg6: clk_25_pg6@RZN1_CLK_25MHZ_PG6_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG6_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_25_pg7: clk_25_pg7@RZN1_CLK_25MHZ_PG7_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG7_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_25_pg8: clk_25_pg8@RZN1_CLK_25MHZ_PG8_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_25MHZ_PG8_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_48_pg4: clk_48_pg4@RZN1_CLK_48MHZ_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_48MHZ_PG4_ID>;
+		clocks = <&clk_48>;
+	};
+	clk_48_pg_f: clk_48_pg_f@RZN1_CLK_48MHZ_PG_F_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_48MHZ_PG_F_ID>;
+		clocks = <&clk_48>;
+	};
+	clk_adc: clk_adc@RZN1_CLK_ADC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_ADC_ID>;
+		clocks = <&div_adc>;
+	};
+	clk_cm3: clk_cm3@RZN1_CLK_CM3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_CM3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	clk_ddrc: clk_ddrc@RZN1_CLK_DDRC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_DDRC_ID>;
+		clocks = <&clk_ddrphy_pllclk_d4>;
+	};
+	clk_ddrphy_pllclk_d4: clk_ddrphy_pllclk_d4 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <4>;
+		clock-mult = <1>;
+		clocks = <&clk_ddrphy_pllclk>;
+	};
+	clk_ecat100: clk_ecat100@RZN1_CLK_ECAT100_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_ECAT100_ID>;
+		clocks = <&clkout_d10>;
+	};
+	clk_ecat100_d4: clk_ecat100_d4 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <4>;
+		clock-mult = <1>;
+		clocks = <&clk_ecat100>;
+	};
+	clk_ecat25: clk_ecat25@RZN1_CLK_ECAT25_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_ECAT25_ID>;
+		clocks = <&clk_ecat100_d4>;
+	};
+	clk_hsr: clk_hsr {
+		#clock-cells = <0>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	clk_hsr50: clk_hsr50@RZN1_CLK_HSR50_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_HSR50_ID>;
+		clocks = <&clk_hsr_dup_d2>;
+	};
+	clk_hsr_dup: clk_hsr_dup@RZN1_CLK_HSR_DUP_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_HSR_DUP_ID>;
+		clocks = <&clkout_d10>;
+	};
+	clk_rxgmii_switch: clk_hsr_dup_d2: clk_hsr_dup_d2 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <2>;
+		clock-mult = <1>;
+		clocks = <&clk_hsr_dup>;
+	};
+	clk_hw_rtos: clk_hw_rtos@RZN1_CLK_HW_RTOS_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_HW_RTOS_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	clk_i2c0: clk_i2c0@RZN1_CLK_I2C0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_I2C0_ID>;
+		clocks = <&div_i2c>;
+	};
+	clk_i2c1: clk_i2c1@RZN1_CLK_I2C1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_I2C1_ID>;
+		clocks = <&div_i2c>;
+	};
+	clk_mii_ref: clk_mii_ref@RZN1_CLK_MII_REF_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_MII_REF_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_nand: clk_nand@RZN1_CLK_NAND_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_NAND_ID>;
+		clocks = <&div_nand>;
+	};
+	clk_nousbp2_pg6: clk_nousbp2_pg6@RZN1_CLK_NOUSBP2_PG6_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_NOUSBP2_PG6_ID>;
+		clocks = <&div_p2_pg>;
+	};
+	clk_p1_pg2: clk_p1_pg2@RZN1_CLK_P1_PG2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P1_PG2_ID>;
+		clocks = <&div_p1_pg>;
+	};
+	clk_p1_pg3: clk_p1_pg3@RZN1_CLK_P1_PG3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P1_PG3_ID>;
+		clocks = <&div_p1_pg>;
+	};
+	clk_p1_pg4: clk_p1_pg4@RZN1_CLK_P1_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P1_PG4_ID>;
+		clocks = <&div_p1_pg>;
+	};
+	clk_p4_pg3: clk_p4_pg3@RZN1_CLK_P4_PG3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P4_PG3_ID>;
+		clocks = <&div_p4_pg>;
+	};
+	clk_p4_pg4: clk_p4_pg4@RZN1_CLK_P4_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P4_PG4_ID>;
+		clocks = <&div_p4_pg>;
+	};
+	clk_p6_pg1: clk_p6_pg1@RZN1_CLK_P6_PG1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P6_PG1_ID>;
+		clocks = <&div_p6_pg>;
+	};
+	clk_p6_pg2: clk_p6_pg2@RZN1_CLK_P6_PG2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P6_PG2_ID>;
+		clocks = <&div_p6_pg>;
+	};
+	clk_p6_pg3: clk_p6_pg3@RZN1_CLK_P6_PG3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P6_PG3_ID>;
+		clocks = <&div_p6_pg>;
+	};
+	clk_p6_pg4: clk_p6_pg4@RZN1_CLK_P6_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_P6_PG4_ID>;
+		clocks = <&div_p6_pg>;
+	};
+	clk_pci_usb: clk_pci_usb@RZN1_CLK_PCI_USB_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_PCI_USB_ID>;
+		clocks = <&clkout_d40>;
+	};
+	clk_48: clk_pll_usb: clk_pll_usb {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <48000000>;
+		clocks = <&clkin_d2>;
+	};
+	clk_ptp_mac0: clk_ptp_mac0 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk25>, <&clk50>;
+	};
+	clk_ptp_mac1: clk_ptp_mac1 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk25>, <&clk50>;
+	};
+	clk_ptp_switch: clk_ptp_switch {
+		#clock-cells = <0>;
+	};
+	clk_qspi0: clk_qspi0@RZN1_CLK_QSPI0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_QSPI0_ID>;
+		clocks = <&div_qspi0>;
+	};
+	clk_qspi1: clk_qspi1@RZN1_CLK_QSPI1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_QSPI1_ID>;
+		clocks = <&div_qspi1>;
+	};
+	clk_ddrphy_pclk: clk_fw_ace: clk_cm3_dapclk_apb: 
+		clk_cm3_dapclk_ahb: clk_cm3_dapclk_axi: clk_cm3_hclk: 
+		clk_cm3_atclk: clk_cm3_dapclk: clk_ram_sys: clk_fw: 
+		clk_fw_ddr_ahb: clk_crypto_pe: clk_crypto_aes: 
+		clk_crypto_des: clk_crypto_arc4: clk_crypto_hash: clk_ref_sync_d4: clk_ref_sync_d4 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <4>;
+		clock-mult = <1>;
+		clocks = <&clk_ref_sync>;
+	};
+	clk_fwdiv2: clk_ref_sync_d8: clk_ref_sync_d8 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <8>;
+		clock-mult = <1>;
+		clocks = <&clk_ref_sync>;
+	};
+	clk_rgmii_ref: clk_rgmii_ref@RZN1_CLK_RGMII_REF_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_RGMII_REF_ID>;
+		clocks = <&clkout_d8>;
+	};
+	clk_rmii_ref: clk_rmii_ref@RZN1_CLK_RMII_REF_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_RMII_REF_ID>;
+		clocks = <&clkout_d20>;
+	};
+	clk_rxgmii_mac0: clk_rxgmii_mac0 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&eth_tx_clk>, <&clk50>;
+	};
+	clk_rxgmii_mac1: clk_rxgmii_mac1 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&clk125>, <&clk50>;
+	};
+	clk_sdio0: clk_sdio0@RZN1_CLK_SDIO0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SDIO0_ID>;
+		clocks = <&div_sdio0>;
+	};
+	clk_sdio1: clk_sdio1@RZN1_CLK_SDIO1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SDIO1_ID>;
+		clocks = <&div_sdio1>;
+	};
+	clk_sercos100: clk_sercos100@RZN1_CLK_SERCOS100_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SERCOS100_ID>;
+		clocks = <&clkout_d10>;
+	};
+	clk_sercos100_d2: clk_sercos100_d2 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <2>;
+		clock-mult = <1>;
+		clocks = <&clk_sercos100>;
+	};
+	clk_sercos50: clk_sercos50@RZN1_CLK_SERCOS50_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SERCOS50_ID>;
+		clocks = <&clk_sercos100_d2>;
+	};
+	clk_slcd: clk_slcd@RZN1_CLK_SLCD_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SLCD_ID>;
+		clocks = <&div_p1_pg>;
+	};
+	clk_spi0: clk_spi0@RZN1_CLK_SPI0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI0_ID>;
+		clocks = <&div_p3_pg>;
+	};
+	clk_spi1: clk_spi1@RZN1_CLK_SPI1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI1_ID>;
+		clocks = <&div_p3_pg>;
+	};
+	clk_spi2: clk_spi2@RZN1_CLK_SPI2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI2_ID>;
+		clocks = <&div_p3_pg>;
+	};
+	clk_spi3: clk_spi3@RZN1_CLK_SPI3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI3_ID>;
+		clocks = <&div_p3_pg>;
+	};
+	clk_spi4: clk_spi4@RZN1_CLK_SPI4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI4_ID>;
+		clocks = <&div_p4_pg>;
+	};
+	clk_spi5: clk_spi5@RZN1_CLK_SPI5_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SPI5_ID>;
+		clocks = <&div_p4_pg>;
+	};
+	clk_switch: clk_switch@RZN1_CLK_SWITCH_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_CLK_SWITCH_ID>;
+		clocks = <&div_switch>;
+	};
+	clk_txgmii_mac0: clk_txgmii_mac0 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk50>, <&clk25>,
+			 <&clk2_5>, <&eth_rx_clk>, <&eth_tx_clk>;
+	};
+	clk_txgmii_mac1: clk_txgmii_mac1 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk50>, <&clk25>,
+			 <&clk2_5>, <&eth_rx_clk>, <&eth_tx_clk>;
+	};
+	clk_txgmii_switch: clk_txgmii_switch {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-selector";
+		clocks = <&rgmii_refclk>, <&clk125>, <&clk50>, <&clk25>,
+			 <&clk2_5>, <&eth_rx_clk>, <&eth_tx_clk>;
+	};
+	clk_40_sysctrl: clkin: clkin {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <40000000>;
+	};
+	clk_20_otp: clkin_d2: clkin_d2 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <2>;
+		clock-mult = <1>;
+		clocks = <&clkin>;
+	};
+	clkout: clkout {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <1000000000>;
+	};
+	clkout_d10: clkout_d10 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <10>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	msebis_clk: msebim_clk: clkout_d16: clkout_d16 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <16>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk_cm3_stclk: clkout_d160: clkout_d160 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <160>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk_ddrphy_sr_hrclk: clk_ddrphy_pllclk: clkout_d1or2: clkout_d1or2 {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3>;
+		renesas,rzn1-div-min = <1>;
+		renesas,rzn1-div-max = <2>;
+		clocks = <&clkout>;
+	};
+	clk50: clkout_d20: clkout_d20 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <20>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk25: clk_25: clkout_d40: clkout_d40 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <40>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk2_5: clkout_d400: clkout_d400 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <400>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clkout_d5: clkout_d5 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <5>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	clk125: clkout_d8: clkout_d8 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clock-div = <8>;
+		clock-mult = <1>;
+		clocks = <&clkout>;
+	};
+	ddr_pll_nr: ddr_pll_nr {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+	};
+	div_adc: div_adc@RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <50>;
+		renesas,rzn1-div-max = <250>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV>;
+		clocks = <&clkout>;
+	};
+	clk_a7mp: div_ca7: div_ca7@RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x7>;
+		renesas,rzn1-div-min = <1>;
+		renesas,rzn1-div-max = <4>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV>;
+		renesas,rzn1-div-table = <1 2 4>;
+		clocks = <&clk_ref_sync>;
+	};
+	div_i2c: div_i2c@RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x1f>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <16>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV>;
+		clocks = <&clkout>;
+	};
+	clk_motordiv: clk_motor: div_motor: div_motor@RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xf>;
+		renesas,rzn1-div-min = <2>;
+		renesas,rzn1-div-max = <8>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV>;
+		clocks = <&clkout_d5>;
+	};
+	div_nand: div_nand@RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3f>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <32>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV>;
+		clocks = <&clkout>;
+	};
+	div_p1_pg: div_p1_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <200>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV>;
+		clocks = <&clkout>;
+	};
+	div_p2_pg: div_p2_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV>;
+		clocks = <&clkout>;
+	};
+	div_p3_pg: div_p3_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <8>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV>;
+		clocks = <&clkout>;
+	};
+	div_p4_pg: div_p4_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <8>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV>;
+		clocks = <&clkout>;
+	};
+	clk_p5_pg1: div_p5_pg: div_p5_pg@RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3f>;
+		renesas,rzn1-div-min = <10>;
+		renesas,rzn1-div-max = <40>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV>;
+		clocks = <&clkout>;
+	};
+	div_p6_pg: div_p6_pg@RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x7f>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <64>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV>;
+		clocks = <&clkout>;
+	};
+	div_qspi0: div_qspi0@RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x7>;
+		renesas,rzn1-div-min = <3>;
+		renesas,rzn1-div-max = <7>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV>;
+		clocks = <&clkout>;
+	};
+	div_qspi1: div_qspi1@RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x7>;
+		renesas,rzn1-div-min = <3>;
+		renesas,rzn1-div-max = <7>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV>;
+		clocks = <&clkout>;
+	};
+	clk_ref_sync: ddr_clk_div: div_ref_sync: div_ref_sync@RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x1f>;
+		renesas,rzn1-div-min = <2>;
+		renesas,rzn1-div-max = <16>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV>;
+		renesas,rzn1-div-table = <2 4 8 16>;
+		clocks = <&clkout>;
+	};
+	div_sdio0: div_sdio0@RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <20>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV>;
+		clocks = <&clkout>;
+	};
+	div_sdio1: div_sdio1@RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <20>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV>;
+		clocks = <&clkout>;
+	};
+	div_switch: div_switch@RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3f>;
+		renesas,rzn1-div-min = <5>;
+		renesas,rzn1-div-max = <40>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV>;
+		clocks = <&clkout>;
+	};
+	div_uart: div_uart@RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0xff>;
+		renesas,rzn1-div-min = <12>;
+		renesas,rzn1-div-max = <128>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV>;
+		clocks = <&clkout>;
+	};
+	eth_rx_clk: eth_rx_clk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+	};
+	eth_tx_clk: eth_tx_clk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+	};
+	hclk_adc: hclk_adc@RZN1_HCLK_ADC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_ADC_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_can0: hclk_can0@RZN1_HCLK_CAN0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CAN0_ID>;
+		clocks = <&clk_48>;
+	};
+	hclk_can1: hclk_can1@RZN1_HCLK_CAN1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CAN1_ID>;
+		clocks = <&clk_48>;
+	};
+	hclk_cm3: hclk_cm3@RZN1_HCLK_CM3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CM3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_crypto_eip150: hclk_crypto_eip150@RZN1_HCLK_CRYPTO_EIP150_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CRYPTO_EIP150_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_crypto_eip93: hclk_crypto_eip93@RZN1_HCLK_CRYPTO_EIP93_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_CRYPTO_EIP93_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_ddrc: hclk_ddrc@RZN1_HCLK_DDRC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_DDRC_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_deltasigma: hclk_deltasigma@RZN1_HCLK_DELTASIGMA_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_DELTASIGMA_ID>;
+		clocks = <&div_motor>;
+	};
+	hclk_dma0: hclk_dma0@RZN1_HCLK_DMA0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_DMA0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_dma1: hclk_dma1@RZN1_HCLK_DMA1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_DMA1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_ecat125: hclk_ecat125@RZN1_HCLK_ECAT125_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_ECAT125_ID>;
+		clocks = <&clkout_d8>;
+	};
+	hclk_gmac0: hclk_gmac0@RZN1_HCLK_GMAC0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GMAC0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_gmac1: hclk_gmac1@RZN1_HCLK_GMAC1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GMAC1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_gpio0: hclk_gpio0@RZN1_HCLK_GPIO0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GPIO0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_gpio1: hclk_gpio1@RZN1_HCLK_GPIO1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GPIO1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_gpio2: hclk_gpio2@RZN1_HCLK_GPIO2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_GPIO2_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_hsr: hclk_hsr@RZN1_HCLK_HSR_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_HSR_ID>;
+		clocks = <&clk_hsr_dup_d2>;
+	};
+	hclk_i2c0: hclk_i2c0@RZN1_HCLK_I2C0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_I2C0_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_i2c1: hclk_i2c1@RZN1_HCLK_I2C1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_I2C1_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_lcd: hclk_lcd@RZN1_HCLK_LCD_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_LCD_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_msebi_m: hclk_msebi_m@RZN1_HCLK_MSEBI_M_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_MSEBI_M_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_msebi_s: hclk_msebi_s@RZN1_HCLK_MSEBI_S_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_MSEBI_S_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_nand: hclk_nand@RZN1_HCLK_NAND_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_NAND_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg19: hclk_pg19@RZN1_HCLK_PG19_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG19_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg20: hclk_pg20@RZN1_HCLK_PG20_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG20_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg3: hclk_pg3@RZN1_HCLK_PG3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg4: hclk_pg4@RZN1_HCLK_PG4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG4_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pg_i: hclk_pg_i@RZN1_HCLK_PG_I_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PG_I_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_pinconfig: hclk_pinconfig@RZN1_HCLK_PINCONFIG_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PINCONFIG_ID>;
+		clocks = <&clkout_d40>;
+	};
+	hclk_pwmpto: hclk_pwmpto@RZN1_HCLK_PWMPTO_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_PWMPTO_ID>;
+		clocks = <&div_motor>;
+	};
+	hclk_qspi0: hclk_qspi0@RZN1_HCLK_QSPI0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_QSPI0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_qspi1: hclk_qspi1@RZN1_HCLK_QSPI1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_QSPI1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_rom: hclk_rom@RZN1_HCLK_ROM_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_ROM_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_rsv: hclk_rsv@RZN1_HCLK_RSV_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_RSV_ID>;
+		clocks = <&clk_48>;
+	};
+	hclk_rtc: hclk_rtc@RZN1_HCLK_RTC_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_RTC_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_sdio0: hclk_sdio0@RZN1_HCLK_SDIO0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SDIO0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_sdio1: hclk_sdio1@RZN1_HCLK_SDIO1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SDIO1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_semap: hclk_semap@RZN1_HCLK_SEMAP_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SEMAP_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_sercos: hclk_sercos@RZN1_HCLK_SERCOS_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SERCOS_ID>;
+		clocks = <&clkout_d10>;
+	};
+	hclk_sgpio0: hclk_sgpio0@RZN1_HCLK_SGPIO0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO0_ID>;
+		clocks = <&div_motor>;
+	};
+	hclk_sgpio1: hclk_sgpio1@RZN1_HCLK_SGPIO1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO1_ID>;
+		clocks = <&div_motor>;
+	};
+	hclk_sgpio2: hclk_sgpio2@RZN1_HCLK_SGPIO2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO2_ID>;
+		clocks = <&div_p5_pg>;
+	};
+	hclk_sgpio3: hclk_sgpio3@RZN1_HCLK_SGPIO3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO3_ID>;
+		clocks = <&div_p5_pg>;
+	};
+	hclk_sgpio4: hclk_sgpio4@RZN1_HCLK_SGPIO4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SGPIO4_ID>;
+		clocks = <&div_p5_pg>;
+	};
+	hclk_spi0: hclk_spi0@RZN1_HCLK_SPI0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI0_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi1: hclk_spi1@RZN1_HCLK_SPI1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI1_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi2: hclk_spi2@RZN1_HCLK_SPI2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI2_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi3: hclk_spi3@RZN1_HCLK_SPI3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi4: hclk_spi4@RZN1_HCLK_SPI4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI4_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_spi5: hclk_spi5@RZN1_HCLK_SPI5_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SPI5_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_switch: hclk_switch@RZN1_HCLK_SWITCH_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SWITCH_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_switch_rg: hclk_switch_rg@RZN1_HCLK_SWITCH_RG_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_SWITCH_RG_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_timer0: hclk_timer0@RZN1_HCLK_TIMER0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_TIMER0_ID>;
+		clocks = <&clkout_d40>;
+	};
+	hclk_timer1: hclk_timer1@RZN1_HCLK_TIMER1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_TIMER1_ID>;
+		clocks = <&clkout_d40>;
+	};
+	hclk_uart0: hclk_uart0@RZN1_HCLK_UART0_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART0_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_uart1: hclk_uart1@RZN1_HCLK_UART1_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART1_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_uart2: hclk_uart2@RZN1_HCLK_UART2_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART2_ID>;
+		clocks = <&clk_ref_sync_d8>;
+	};
+	hclk_uart3: hclk_uart3@RZN1_HCLK_UART3_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART3_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_uart4: hclk_uart4@RZN1_HCLK_UART4_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART4_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_uart5: hclk_uart5@RZN1_HCLK_UART5_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART5_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_uart6: hclk_uart6@RZN1_HCLK_UART6_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART6_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_uart7: hclk_uart7@RZN1_HCLK_UART7_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_UART7_ID>;
+		clocks = <&clk_ref_sync_d4>;
+	};
+	hclk_usbf: hclk_usbf@RZN1_HCLK_USBF_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_USBF_ID>;
+		clocks = <&clkout_d8>;
+	};
+	hclk_usbh: hclk_usbh@RZN1_HCLK_USBH_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_USBH_ID>;
+		clocks = <&clkout_d8>;
+	};
+	hclk_usbpm: hclk_usbpm@RZN1_HCLK_USBPM_ID {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-gate";
+		reg = <RZN1_HCLK_USBPM_ID>;
+		clocks = <&clkout_d8>;
+	};
+	rgmii_refclk: rgmii_refclk {
+		#clock-cells = <0>;
+	};
+	rtos_mdc: rtos_mdc@RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV {
+		#clock-cells = <0>;
+		compatible = "renesas,rzn1-clock-divider";
+		renesas,rzn1-bit-mask = <0x3ff>;
+		renesas,rzn1-div-min = <80>;
+		renesas,rzn1-div-max = <640>;
+		reg = <RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV>;
+		renesas,rzn1-div-table = <80 160 320 640>;
+		clocks = <&clk_ref_sync>;
+	};
+};
diff --git a/arch/arm/boot/dts/rzn1.dtsi b/arch/arm/boot/dts/rzn1.dtsi
new file mode 100644
index 0000000..56e43be
--- /dev/null
+++ b/arch/arm/boot/dts/rzn1.dtsi
@@ -0,0 +1,929 @@
+/*
+ * Device Tree Source for the Renesas RZ/N1 SoC
+ *
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/rzn1-irq.h>
+#include <dt-bindings/soc/rzn1-memory-map.h>
+#include <dt-bindings/soc/rzn1-sysctrl.h>
+#include <dt-bindings/pinctrl/pinctrl-rzn1.h>
+#include <dt-bindings/clock/rzn1-clocks.h>
+
+#include "skeleton.dtsi"
+
+/ {
+	compatible = "renesas,rzn1";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen {
+		/* These nodes are specific to the rzn1, and are CAN by the
+		 * bootloader. They are optional
+		   rzn1,bootaddr = <0xxxxxxxxx>  -- this property is set
+		        by the bootloader when it starts in NONSEC mode, this
+		        property will contain the address that the second CA7
+		        core is 'parked' at, and where it is looking for the
+		        boot address code the kernel will pass to it to start it.
+		        This property should not be set manually.
+		   rzn1,h2mode   -- this bool property, if present, will force
+		        the kernel to configure the USB subsystem in 'host' mode,
+		        this mode will prevent the usbf 'device' driver to start.
+		        This property can be set by the bootloader in case there
+		        is a GPIO for this configutation, otherwise, it can also
+		        be set manually in the device tree to force a config.
+		 */
+	};
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&clk_a7mp>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0>;
+		};
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <1>;
+		};
+	};
+	aliases {
+		serial0 = &uart0;
+		pinctrl = &pinctrl;
+		clocks = &clocks;
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		spi0 = &qspi0;
+	};
+	clocks: clocks@0 {
+		compatible = "renesas,rzn1-clock";
+		reg = <RZN1_SYSTEM_CTRL_BASE RZN1_SYSTEM_CTRL_SIZE>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		/* Most of the clock definition is declared in the
+		 * autogenerated file rzn1-clocks.dtsi
+		 * Here we find the 'exceptions' - mostly grouping clocks
+		 * together to attach to drivers */
+
+		/* Needed for pinctrl access !*/
+		hclk_pinconfig { renesas,no-disable; };
+
+		clk_ddr_grp: clk_ddr_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_ddrc &hclk_ddrc>;
+		};
+		all_usbf: all_usbf {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&hclk_usbf &hclk_usbpm &clk_48_pg_f>;
+		};
+		/* USB Host Needs the USB Device clocks(!) since the EPCTR
+		 * register is in the USBF register map, and that register is
+		 * needed to start the PLL */
+		all_usbh: all_usbh {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&hclk_usbh &hclk_usbpm &clk_pci_usb &all_usbf>;
+		};
+		all_lcd: all_lcd {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&hclk_lcd &hclk_pg_i>;
+		};
+		clk_switch_all: clk_switch_all {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&hclk_switch &clk_switch>;
+		};
+		clk_rgmii_conv_all: clk_rgmii_conv_all {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_mii_ref &clk_rmii_ref &clk_rgmii_ref &hclk_switch_rg>;
+		};
+		uart_group_34567: uart_group_34567 {
+			#clock-cells = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "renesas,rzn1-clock-bitselect";
+			/* Bit 24 is UARTCLKSEL */
+			reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2>;
+			renesas,rzn1-sel-bit = <24>;
+
+			/* If that bit is zero, use first parent, else,
+			 * use second parent */
+			clocks = <&div_p2_pg>, <&clk_48>;
+
+			/* First group are gates for when selector bit
+			 * is zero, second group is the gates to use when
+			 * bit is 'one' */
+			renesas,rzn1-gates =
+			      <RZN1_CLK_UART3_ID RZN1_CLK_UART4_ID
+				RZN1_CLK_UART5_ID RZN1_CLK_UART6_ID
+				RZN1_CLK_UART7_ID>,
+			      <RZN1_CLK_USBUART3_ID RZN1_CLK_USBUART4_ID
+				RZN1_CLK_USBUART5_ID RZN1_CLK_USBUART6_ID
+				RZN1_CLK_USBUART7_ID>;
+
+			gsclk_uart3: gsclk_uart3@0 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <0>;
+			 };
+			gsclk_uart4: gsclk_uart4@1 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <1>;
+			 };
+			gsclk_uart5: gsclk_uart5@2 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <2>;
+			 };
+			gsclk_uart6: gsclk_uart6@3 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <3>;
+			 };
+			gsclk_uart7: gsclk_uart7@4 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_34567>;
+				reg = <4>;
+			 };
+		 };
+		 uart_group_012: uart_group_012@RZN1_SYSCTRL_REG_PWRCTRL_PG0_0 {
+			#clock-cells = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "renesas,rzn1-clock-bitselect";
+			/* Bit 24 is UARTCLKSEL */
+			reg = <RZN1_SYSCTRL_REG_PWRCTRL_PG0_0>;
+			renesas,rzn1-sel-bit = <30>;
+
+			/* If that bit is zero, use first parent, else,
+			 * use second parent */
+			clocks = <&div_uart>, <&clk_48>;
+
+			/* First group are gates for when selector bit
+			 * is zero, second group is the gates to use when
+			 * bit is 'one' */
+			renesas,rzn1-gates =
+			      <RZN1_CLK_UART0_ID RZN1_CLK_UART1_ID
+				RZN1_CLK_UART2_ID>,
+			      <RZN1_CLK_USBUART0_ID RZN1_CLK_USBUART1_ID
+				RZN1_CLK_USBUART2_ID>;
+			gsclk_uart0: gsclk_uart0@0 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_012>;
+				reg = <0>;
+			 };
+			gsclk_uart1: gsclk_uart1@1 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_012>;
+				reg = <1>;
+			 };
+			gsclk_uart2: gsclk_uart2@2 {
+				#clock-cells = <0>;
+				compatible = "renesas,rzn1-clock-dualgate";
+				clocks = <&uart_group_012>;
+				reg = <2>;
+			};
+		};
+		sclk_uart0_grp: sclk_uart0_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart0 &hclk_uart0>;
+		};
+		sclk_uart1_grp: sclk_uart1_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart1 &hclk_uart1>;
+		};
+		sclk_uart2_grp: sclk_uart2_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart2 &hclk_uart2>;
+		};
+		sclk_uart3_grp: sclk_uart3_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart3 &hclk_uart3>;
+		};
+		sclk_uart4_grp: sclk_uart4_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart4 &hclk_uart4>;
+		};
+		sclk_uart5_grp: sclk_uart5_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart5 &hclk_uart5>;
+		};
+		sclk_uart6_grp: sclk_uart6_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart6 &hclk_uart6>;
+		};
+		sclk_uart7_grp: sclk_uart7_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&gsclk_uart7 &hclk_uart7>;
+		};
+		clk_i2c0_grp: clk_i2c0_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_i2c0 &hclk_i2c0>;
+		};
+		clk_i2c1_grp: clk_i2c1_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_i2c1 &hclk_i2c1>;
+		};
+		clk_spi0_grp: clk_spi0_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi0>, <&hclk_spi0>;
+		};
+		clk_spi1_grp: clk_spi1_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi1>, <&hclk_spi1>;
+		};
+		clk_spi2_grp: clk_spi2_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi2>, <&hclk_spi2>;
+		};
+		clk_spi3_grp: clk_spi3_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi3>, <&hclk_spi3>;
+		};
+		clk_spi4_grp: clk_spi4_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi4>, <&hclk_spi4>;
+		};
+		clk_spi5_grp: clk_spi5_grp {
+			#clock-cells = <0>;
+			compatible = "renesas,rzn1-clock-group";
+			clocks = <&clk_spi5>, <&hclk_spi5>;
+		};
+	};
+
+	arm_timer: timer {
+		compatible = "arm,armv7-timer";
+		arm,cpu-registers-not-fw-configured;
+		interrupts =
+			<GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			<GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			<GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			<GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	gic: interrupt-controller@RZN1_GIC_BASE {
+		compatible = "arm,cortex-a7-gic";
+		reg = <0x44101000 0x1000>,	/* Distributer */
+		      <0x44102000 0x1000>,	/* CPU interface */
+		      <0x44104000 0x2000>,	/* Virt interface control */
+		      <0x44106000 0x2000>;	/* Virt CPU interface */
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		interrupts =
+			<GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(2) |
+				IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+	ipc: mailbox@RZN1_MAILBOX_BASE {
+	    compatible = "arm,pl320", "arm,primecell";
+	    reg = <RZN1_MAILBOX_BASE RZN1_MAILBOX_SIZE>;
+	    interrupts = <GIC_SPI RZN1_IRQ_IPCM_1 IRQ_TYPE_LEVEL_HIGH>;
+	    clocks = <&clk_fw>;
+	    clock-names = "apb_pclk";
+	};
+
+	gpioirq: gpioirq@RZN1_GPIO0_BASE {
+		compatible = "renesas,rzn1-gpioirq";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+
+		interrupts =
+			<GIC_SPI RZN1_IRQ_GPIO_0 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_1 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_2 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_3 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_4 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_5 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_6 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI RZN1_IRQ_GPIO_7 IRQ_TYPE_LEVEL_HIGH>;
+
+		reg = <RZN1_GPIO0_BASE RZN1_GPIO0_SIZE>,
+			<RZN1_GPIO1_BASE RZN1_GPIO1_SIZE>,
+			<RZN1_GPIO2_BASE RZN1_GPIO2_SIZE>;
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+		/* gpioirq-3 = <&gpio1a 12 GPIO_ACTIVE_HIGH>; */
+	};
+
+	bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		u-boot,dm-pre-reloc;
+
+		memory-controller@RZN1_DDR_BASE {
+			compatible = "cadence,ddr-ctrl";
+			reg = <RZN1_DDR_BASE RZN1_DDR_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_DDRSUB IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&clk_ddr_grp>;
+			status = "okay";
+		};
+		pinctrl: pinctrl@RZN1_PINCTRL_BASE {
+			compatible = "renesas,rzn1-pinctrl";
+			reg = <RZN1_PINCTRL_BASE RZN1_PINCTRL_SIZE>,
+				<RZN1_PINCTRL_L2_BASE RZN1_PINCTRL_L2_SIZE>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+		};
+		timer0: timer@RZN1_TIMER0_BASE {
+			compatible = "renesas,rzn1-timer";
+			reg = <RZN1_TIMER0_BASE RZN1_TIMER0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_TIMER0_0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_2 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_3 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_4 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_5 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_6 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER0_7 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_timer0>;
+			renesas,use-prescaler;
+			status = "disabled";
+		};
+		timer1: timer@RZN1_TIMER1_BASE {
+			compatible = "renesas,rzn1-timer";
+			reg = <RZN1_TIMER1_BASE RZN1_TIMER1_SIZE>;
+			renesas,timer-number = <1>;
+			interrupts = <GIC_SPI RZN1_IRQ_TIMER1_0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_2 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_3 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_4 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_5 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_6 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_TIMER1_7 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_timer1>;
+			renesas,use-prescaler;
+			status = "disabled";
+		};
+		uart0: serial@RZN1_UART0_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART0_BASE RZN1_UART0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART0 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart0_grp>;
+			status = "disabled";
+		};
+		uart1: serial@RZN1_UART1_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART1_BASE RZN1_UART1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART1 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart1_grp>;
+			status = "disabled";
+		};
+		uart2: serial@RZN1_UART2_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART2_BASE RZN1_UART2_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART2 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart2_grp>;
+			status = "disabled";
+		};
+		uart3: serial@RZN1_UART3_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART3_BASE RZN1_UART3_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART3 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart3_grp>;
+			status = "disabled";
+		};
+		uart4: serial@RZN1_UART4_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART4_BASE RZN1_UART4_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART4 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart4_grp>;
+			status = "disabled";
+		};
+		uart5: serial@RZN1_UART5_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART5_BASE RZN1_UART5_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART5 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart5_grp>;
+			status = "disabled";
+		};
+		uart6: serial@RZN1_UART6_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART6_BASE RZN1_UART6_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART6 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart6_grp>;
+			status = "disabled";
+		};
+		uart7: serial@RZN1_UART7_BASE {
+			compatible = "snps,dw-apb-uart";
+			reg = <RZN1_UART7_BASE RZN1_UART7_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_UART7 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&sclk_uart7_grp>;
+			status = "disabled";
+		};
+		i2c0: i2c@RZN1_I2C0_BASE {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <RZN1_I2C0_BASE RZN1_I2C0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_I2C0 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_i2c0_grp>;
+			clock-frequency = <100000>;
+			status = "disabled";
+		};
+		i2c1: i2c@RZN1_I2C1_BASE {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c";
+			reg = <RZN1_I2C1_BASE RZN1_I2C1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_I2C1 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_i2c1_grp>;
+			clock-frequency = <100000>;
+			status = "disabled";
+		};
+		rtc0: rtc@RZN1_RTC_BASE {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "renesas,rzn1-rtc";
+			reg = <RZN1_RTC_BASE RZN1_RTC_SIZE>;
+			clock-names = "axi";
+			clocks = <&hclk_rtc>;
+			interrupt-names = "alarm", "intr", "1hz";
+			interrupts =
+				<GIC_SPI RZN1_IRQ_RTCATINTAL IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI RZN1_IRQ_RTCATINTR IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI RZN1_IRQ_RTCATINT1S IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+		};
+		gmac0: ethernet@RZN1_GMAC0_BASE {
+			compatible = "snps,dwmac-3.72a", "snps,dwmac";
+			reg = <RZN1_GMAC0_BASE RZN1_GMAC0_SIZE>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI RZN1_IRQ_SBD0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_LPI0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_PMT0 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq", "eth_lpi", "eth_wake_irq";
+			clock-names = "stmmaceth";
+			clocks = <&hclk_gmac0>;
+			status = "disabled";
+		};
+		gmac1: ethernet@RZN1_GMAC1_BASE {
+			compatible = "snps,dwmac-3.72a", "snps,dwmac";
+			reg = <RZN1_GMAC1_BASE RZN1_GMAC1_SIZE>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI RZN1_IRQ_SBD1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_LPI1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_PMT1 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq", "eth_lpi", "eth_wake_irq";
+			clock-names = "stmmaceth";
+			clocks = <&hclk_gmac1>;
+			status = "disabled";
+		};
+		switch: ethswitch: eth-switch@RZN1_SWITCH_BASE {
+			compatible = "mtip,5pt_switch";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <RZN1_SWITCH_BASE RZN1_SWITCH_SIZE>;
+			clock-names = "fck";
+			clocks = <&clk_switch_all>;
+			status = "disabled";
+		};
+		eth_miic: eth-miic@RZN1_SWITCH_CTRL_REG_BASE {
+			compatible = "renesas,rzn1-miic";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <RZN1_SWITCH_CTRL_REG_BASE RZN1_SWITCH_CTRL_REG_SIZE>;
+			status = "disabled";
+			clocks = <&clk_rgmii_conv_all>;
+		};
+
+		dma0: dma-controller@RZN1_DMA0_BASE {
+			compatible = "snps,dma-rzn1";
+			reg = <RZN1_DMA0_BASE RZN1_DMA0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_DMA0 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "hclk";
+			clocks = <&hclk_dma0>;
+			dma-channels = <8>;
+			dma-requests = <16>;
+			dma-masters = <1>;
+			#dma-cells = <3>;
+			block_size = <0xfff>;
+			data_width = <3>;
+			status = "disabled";
+		};
+		dma1: dma-controller@RZN1_DMA1_BASE {
+			compatible = "snps,dma-rzn1";
+			reg = <RZN1_DMA1_BASE RZN1_DMA1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_DMA1 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "hclk";
+			clocks = <&hclk_dma1>;
+			dma-channels = <8>;
+			dma-requests = <16>;
+			dma-masters = <1>;
+			#dma-cells = <3>;
+			block_size = <0xfff>;
+			data_width = <3>;
+			status = "disabled";
+		};
+		sdio0: sdhci@RZN1_SDIO0_BASE {
+			compatible = "arasan,sdhci-8.9a";
+			reg = <RZN1_SDIO0_BASE RZN1_SDIO0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SDIO0 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_SDIO0_WKUP IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "clk_xin", "clk_ahb";
+			clocks = <&clk_sdio0>, <&hclk_sdio0>;
+			no-1-8-v;
+			status = "disabled";
+		};
+		sdio1: sdhci@RZN1_SDIO1_BASE {
+			compatible = "arasan,sdhci-8.9a";
+			reg = <RZN1_SDIO1_BASE RZN1_SDIO1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SDIO1 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI RZN1_IRQ_SDIO1_WKUP IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "clk_xin", "clk_ahb";
+			clocks = <&clk_sdio1>, <&hclk_sdio1>;
+			no-1-8-v;
+			status = "disabled";
+		};
+		qspi: qspi0: spi@RZN1_QSPI_BASE {
+			compatible = "renesas,rzn1-qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <RZN1_QSPI_BASE RZN1_QSPI_SIZE
+				RZN1_V_QSPI_BASE RZN1_V_QSPI_SIZE>;
+			reg-names = "qspi", "qspi-mapping";
+			interrupts = <GIC_SPI RZN1_IRQ_QSPI0 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_qspi0>, <&clk_qspi0>;
+			clock-names = "flexway", "pclk";
+			status = "disabled";
+		};
+		nand: nand@RZN1_NAND_BASE {
+			compatible = "evatronix,nandflash-ctrl";
+			reg = <RZN1_NAND_BASE RZN1_NAND_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_NAND IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_nand>, <&clk_nand>;
+			clock-names = "clka", "clkb";
+			#address-cells		= <1>;
+			#size-cells		= <1>;
+			status = "disabled";
+		};
+		/*
+		 * SPI 0-3 are Master; 4-5 are Slave. 4-16 bits data width
+		 * dw_apb-ssi is configured with 16*16 bits FIFO in both
+		 * directions.
+		 * 4 Chipselects for the master interfaces, 1 for slaves
+		 */
+		spi0: spi@RZN1_SPI0_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI0_BASE RZN1_SPI0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI0 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi0_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <4>;
+			status = "disabled";
+		};
+		spi1: spi@RZN1_SPI1_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI1_BASE RZN1_SPI1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI1 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi1_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <4>;
+			status = "disabled";
+		};
+		spi2: spi@RZN1_SPI2_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI2_BASE RZN1_SPI2_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI2 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi2_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <4>;
+			status = "disabled";
+		};
+		spi3: spi@RZN1_SPI3_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI3_BASE RZN1_SPI3_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI3 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi3_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <4>;
+			status = "disabled";
+		};
+		spi4: spi@RZN1_SPI4_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI4_BASE RZN1_SPI4_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI4 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi4_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <1>; /* Slave interface */
+			status = "disabled";
+		};
+		spi5: spi@RZN1_SPI5_BASE {
+			compatible = "snps,dw-apb-ssi";
+			reg = <RZN1_SPI5_BASE RZN1_SPI5_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_SPI5 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "pclk";
+			clocks = <&clk_spi5_grp>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <1>; /* Slave interface */
+			status = "disabled";
+		};
+		usbphy: usbphy0: usbphy@0 {
+			#phy-cells = <0>;
+			compatible = "usb-nop-xceiv";
+			status = "disabled";
+		};
+		usbf: usbf@RZN1_USB_DEV_BASE {
+			compatible = "renesas,rzn1-usbf";
+			reg = <RZN1_USB_DEV_BASE RZN1_USB_DEV_SIZE>;
+			interrupts =
+				<GIC_SPI RZN1_IRQ_USBF_EPC IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI RZN1_IRQ_USBF IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "axi";
+			clocks = <&all_usbf>;
+
+			renesas,sram-size = <5024>; /* 32 bits words */
+			/* Allow 4 x 512 byte packets per endpoint to support MTU of 1500.
+			Due to protocol overheads, 3 x 512 byte packets is not enough. */
+			renesas,sram-conf,g_ether = <4 2 0>;
+			renesas,sram-conf,g_mass_storage = <8 8 0 0 0 0>;
+			status = "disabled";
+		};
+		usbh_pci: pci@RZN1_USB_HOST_BASE {
+			compatible = "renesas,pci-rzn1";
+			device_type = "pci";
+			clock-names = "axi";
+			clocks = <&all_usbh>;
+			reg = <(RZN1_USB_HOST_BASE+0x10000) 0xc00>,
+			      <RZN1_USB_HOST_BASE 0x1100>;
+			interrupts = <GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+
+			bus-range = <0 0>;
+			#address-cells = <3>;
+			#size-cells = <1>;
+			#interrupt-cells = <1>;
+			ranges = <0x02000000 0 RZN1_USB_HOST_BASE RZN1_USB_HOST_BASE 0x00010000>;
+			/* Should map all possible DDR as inbound ranges, but
+			   the IP only supports a 256MB, 512MB, or 1GB window */
+			/* flags, PCI addr (64-bit), CPU addr, PCI size (64-bit) */
+			dma-ranges = <0x42000000 0 0x80000000 0x80000000 0 0x40000000>;
+			interrupt-map-mask = <0xff00 0 0 0x7>;
+			interrupt-map = <0x0000 0 0 1 &gic GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH
+					 0x0800 0 0 1 &gic GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH
+					 0x1000 0 0 2 &gic GIC_SPI RZN1_IRQ_USBH_BIND IRQ_TYPE_LEVEL_HIGH>;
+
+			usb@0,1 {
+				reg = <0x800 0 0 0>;
+				device_type = "pci";
+				phys = <&usbphy 0 0>;
+				phy-names = "usb";
+			};
+
+			usb@0,2 {
+				reg = <0x1000 0 0 0>;
+				device_type = "pci";
+				phys = <&usbphy 0 0>;
+				phy-names = "usb";
+			};
+		};
+		reset: reset@RZN1_RESET_BASE {
+			reg = <RZN1_RESET_BASE RZN1_RESET_SIZE>;
+			clocks = <&hclk_pinconfig>;
+		};
+		wdtsafe0: wdtsafe0@RZN1_WATCHDOGSAFE0_BASE {
+			compatible = "renesas,rzn1-watchdogsafe";
+			reg = <RZN1_WATCHDOGSAFE0_BASE RZN1_WATCHDOGSAFE0_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_WATCHDOGSAFE0 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_pinconfig>;
+			status = "disabled";
+		};
+		wdtsafe1: wdtsafe1@RZN1_WATCHDOGSAFE1_BASE {
+			compatible = "renesas,rzn1-watchdogsafe";
+			reg = <RZN1_WATCHDOGSAFE1_BASE RZN1_WATCHDOGSAFE1_SIZE>;
+			interrupts = <GIC_SPI RZN1_IRQ_WATCHDOGSAFE1 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&hclk_pinconfig>;
+			status = "disabled";
+		};
+		/*
+		 * The GPIO mapping to the corresponding pins is complicted,
+		 * see the hardware documentation for details.
+		 */
+		gpio0: gpio@RZN1_GPIO0_BASE {
+			compatible = "snps,dw-apb-gpio";
+			reg = <RZN1_GPIO0_BASE RZN1_GPIO0_SIZE>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clocks = <&hclk_gpio0>;
+			status = "disabled";
+
+			gpio0a: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio0a";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&gpioirq>;
+				interrupts = <8>;
+			};
+			gpio0b: gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio0b";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <1>;
+			};
+		};
+		gpio1: gpio@RZN1_GPIO1_BASE {
+			compatible = "snps,dw-apb-gpio";
+			reg = <RZN1_GPIO1_BASE RZN1_GPIO1_SIZE>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clocks = <&hclk_gpio1>;
+			status = "disabled";
+
+			/* GPIO1a[0..4] corresponds to pins 45..49 */
+			/* GPIO1a[5..31] corresponds to pins 71..121 */
+			gpio1a: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio1a";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&gpioirq>;
+				interrupts = <9>;
+			};
+			/* GPIO1b[0..1] corresponds to pins 31..32 */
+			/* GPIO1b[2..4] corresponds to pins 35..37 */
+			/* GPIO1b[5..25] corresponds to pins 50..70 */
+			/* GPIO1b[26..31] corresponds to pins 150..155 */
+			gpio1b: gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio1b";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <1>;
+			};
+		};
+		gpio2: gpio@RZN1_GPIO2_BASE {
+			compatible = "snps,dw-apb-gpio";
+			reg = <RZN1_GPIO2_BASE RZN1_GPIO2_SIZE>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clocks = <&hclk_gpio2>;
+			status = "disabled";
+
+			/* GPIO2a[0..27] corresponds to pins 122..149 */
+			/* GPIO2a[28..31] corresponds to pins 156..159 */
+			gpio2a: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio2a";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&gpioirq>;
+				interrupts = <10>;
+			};
+			/* GPIO2b[0..9] corresponds to pins 160..169 */
+			gpio2b: gpio-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				bank-name = "gpio2b";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <10>;
+				reg = <1>;
+			};
+		};
+		sgpio0: gpio@RZN1_SGPIO0_BASE {
+			reg = <RZN1_SGPIO0_BASE RZN1_SGPIO0_SIZE>;
+		};
+		sgpio1: gpio@RZN1_SGPIO1_BASE {
+			reg = <RZN1_SGPIO1_BASE RZN1_SGPIO1_SIZE>;
+		};
+		can0: can@RZN1_CAN0_BASE {
+			compatible = "nxp,sja1000";
+			reg = <RZN1_CAN0_BASE RZN1_CAN0_SIZE>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI RZN1_IRQ_CAN0 IRQ_TYPE_LEVEL_HIGH>;
+			nxp,no-cdr;
+			nxp,no-loopback;
+			clocks = <&hclk_can0>;
+			status = "disabled";
+		};
+		can1: can@RZN1_CAN1_BASE {
+			compatible = "nxp,sja1000";
+			reg = <RZN1_CAN1_BASE RZN1_CAN1_SIZE>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI RZN1_IRQ_CAN1 IRQ_TYPE_LEVEL_HIGH>;
+			nxp,no-cdr;
+			nxp,no-loopback;
+			clocks = <&hclk_can1>;
+			status = "disabled";
+		};
+		fb0: fb@RZN1_LCD_BASE {
+			compatible = "digitalblocks,db9000-clcd";
+			interrupts = <GIC_SPI RZN1_IRQ_LCD IRQ_TYPE_LEVEL_HIGH>;
+			reg = <RZN1_LCD_BASE RZN1_LCD_SIZE>;
+			clock-names = "pclk", "ahb";
+			clocks = <&clk_slcd>, <&all_lcd>;
+			status = "disabled";
+		};
+		msebi: msebim: memory-controller@RZN1_MSEBI_M0_BASE {
+			compatible = "renesas,rzn1-msebi";
+			#address-cells = <2>;
+			#size-cells = <1>;
+			reg = <RZN1_MSEBI_M0_BASE RZN1_MSEBI_M0_SIZE>;
+			clocks = <&hclk_msebi_m>;
+			interrupts = <GIC_SPI RZN1_IRQ_MSEBIM IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		/* These nodes are placeholders; they are refered to by the
+		 * pinmux file, but have no driver just yet, so we create
+		 * empty nodes for them until we can flesh it up */
+		unknown: s3: dsigma: mii: motor: unknown {
+		};
+	};
+
+};
+
+#include "rzn1-clocks.dtsi"
diff --git a/arch/arm/boot/dts/rzn1d400-db-no-cm3.dts b/arch/arm/boot/dts/rzn1d400-db-no-cm3.dts
new file mode 100644
index 0000000..3df0137
--- /dev/null
+++ b/arch/arm/boot/dts/rzn1d400-db-no-cm3.dts
@@ -0,0 +1,23 @@
+/*
+ * Device Tree Source for the RZN1-400 Demo Board.
+ * This dts is for use when the Cortex M3 is not running, i.e. Linux controls
+ * GMAC1, the 5-Port Switch and the RGMII/GMII Converters.
+ *
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include "rzn1d400-db.dts"
+
+&gmac1 {
+	status = "okay";
+};
+&ethswitch {
+	status = "okay";
+};
+&eth_miic {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/rzn1d400-db.dts b/arch/arm/boot/dts/rzn1d400-db.dts
new file mode 100644
index 0000000..4ddd9f4
--- /dev/null
+++ b/arch/arm/boot/dts/rzn1d400-db.dts
@@ -0,0 +1,422 @@
+/*
+ * Device Tree Source for the RZN1-400 Demo Board
+ * This dts is for use when the Cortex M3 is controls GMAC1, the 5-Port Switch
+ * and the RGMII/GMII Converters.
+ *
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/dts-v1/;
+
+#include "rzn1.dtsi"
+#include "rzn1-clocks.dtsi"
+
+/ {
+	model = "RZ/N1D Demo Board";
+	compatible = "renesas,rzn1d-db", "renesas,rzn1";
+
+	chosen {
+		/*
+		 * This is a default command line to help with booting using
+		 * qemu and a ramdisk, it is not meant to stay in the final
+		 * file
+		 g_mass_storage.removable=y g_mass_storage.stall=n
+		 */
+		bootargs = "console=ttyS0,115200 earlyprintk debug rdinit=/linuxrc";
+		stdout-path = &uart0;
+		linux,stdout-path = &uart0;
+	};
+	c2c_sram@20080000 {
+		compatible = "mmio-sram";
+		reg = <0x20080000 0x3000>;
+	};
+	hoard: cat: nmi: rmii {
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+	leds {
+		compatible = "gpio-leds";
+
+		led_1 {
+			label = "pl_gpio92";
+			gpios = <&gpio1b 23 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "cpu0";
+		};
+		led_2 {
+			label = "pl_gpio93";
+			gpios = <&gpio1b 24 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "cpu1";
+		};
+		pca0 {
+			label = "pca0";
+			gpios = <&pca9698 0 GPIO_ACTIVE_HIGH>;
+		};
+		pca1 {
+			label = "pca1";
+			gpios = <&pca9698 1 GPIO_ACTIVE_HIGH>;
+		};
+		pca2 {
+			label = "pca2";
+			gpios = <&pca9698 2 GPIO_ACTIVE_HIGH>;
+		};
+		pca3 {
+			label = "pca3";
+			gpios = <&pca9698 3 GPIO_ACTIVE_HIGH>;
+		};
+		pca4 {
+			label = "pca4";
+			gpios = <&pca9698 4 GPIO_ACTIVE_HIGH>;
+		};
+		pca5 {
+			label = "pca5";
+			gpios = <&pca9698 5 GPIO_ACTIVE_HIGH>;
+		};
+		pca6 {
+			label = "pca6";
+			gpios = <&pca9698 6 GPIO_ACTIVE_HIGH>;
+		};
+		pca7 {
+			label = "pca7";
+			gpios = <&pca9698 7 GPIO_ACTIVE_HIGH>;
+		};
+
+		/* These aren't LEDs, they are gpios attached to the pca9698
+		 * port expander. They select the I2C master used to access the
+		 * EEPROM device. The ACTIVE LOW/HIGH settings ensures Linux
+		 * sets the correctly if not done by U-Boot.
+		 */
+		ctrl0 {
+			label = "ctrl0";
+			gpios = <&pca9698 16 GPIO_ACTIVE_LOW>;
+		};
+		ctrl1 {
+			label = "ctrl1";
+			gpios = <&pca9698 17 GPIO_ACTIVE_HIGH>;
+		};
+		ctrl2 {
+			label = "ctrl2";
+			gpios = <&pca9698 18 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+/* Map the USB pinmux to the peripheral port */
+#define usb usbh_pci
+/* ethX refers to the physical pins for each ethernet interface. Here we simply
+ * place them in the hoard node, and the users of the pins will then indicate
+ * are needed by adding a pinctrl-0 entry for them.
+ */
+#define eth0 hoard
+#define eth1 hoard
+#define eth2 hoard
+#define eth3 hoard
+#define eth4 hoard
+#define refclk hoard
+#define mdio0 hoard
+#define mdio1 hoard
+#define lcd fb0
+
+#include "rzn1d400_preset_db.dts"
+
+&gpioirq {
+	status = "okay";
+	gpioirq-0 = <&gpio2a 24 GPIO_ACTIVE_LOW>;	/* 146: ETH Port 1 IRQ */
+	gpioirq-1 = <&gpio2a 4 GPIO_ACTIVE_LOW>;	/* 126: ETH Port 2 IRQ */
+	gpioirq-2 = <&gpio1a 28 GPIO_ACTIVE_LOW>;	/* 118: ETH Port 3 IRQ */
+	gpioirq-3 = <&gpio2a 25 GPIO_ACTIVE_LOW>;	/* 147: ETH Port 4 IRQ */
+	gpioirq-4 = <&gpio2a 27 GPIO_ACTIVE_LOW>;	/* 149: ETH Port 5 IRQ */
+	gpioirq-5 = <&gpio2a 26 GPIO_ACTIVE_LOW>;	/* 148: TouchSCRN_IRQ  */
+};
+
+&uart0 {
+	status = "okay";
+	u-boot,dm-pre-reloc;
+};
+&uart2 {
+	status = "okay";
+};
+&uart3 {
+	status = "okay";
+};
+&i2c1 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pca9698: gpio@20 {
+		compatible = "nxp,pca9698";
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		gpio-bank-name="pca";
+	};
+	lm75: lm75@49 {
+		/* Ext Board: Temperature sensor */
+		compatible = "lm75";
+		reg = <0x49>;
+	};
+	at24@50 {
+		compatible = "at24,24c64";
+		pagesize = <32>;
+		reg = <0x50>;
+	};
+	polytouch: edt-ft5x06@38 {
+		/* Ext Board: touch sensor on LCD */
+		compatible = "edt,edt-ft5x06";
+		reg = <0x38>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <5 0>;
+		touchscreen-size-x = <800>;
+		touchscreen-size-y = <480>;
+		// touchscreen-swapped-x-y;
+	};
+};
+&gpio1 {
+	status = "okay";
+};
+&gpio2 {
+	status = "okay";
+};
+
+&gmac0 {
+	/* Only accessible from the Ext Board */
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio0>, <&pins_eth0>;
+
+	phy-handle = <&phy_mii0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy_mii0: ethernet-phy@8 {
+			/* Ext Board: Marvell 88E1512 PHY on J22 */
+			device_type = "ethernet-phy";
+			phy-mode = "rgmii-id";
+			reg = <8>;
+			/* Set LED0 as active low link status, LED2 as interrupt */
+			marvell,reg-init = <3 16 0 0x1010 3 18 0 0x4980>;
+			interrupt-parent = <&gpioirq>;
+			interrupts = <0>;
+		};
+	};
+};
+&gmac1 {
+	status = "disabled";
+
+	/* Fixed 1Gbps link to the 5-port switch */
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+&ethswitch {
+	status = "disabled";
+	bus_freq = <2500000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio1>,
+		<&pins_eth1>, <&pins_eth2>, <&pins_eth3>, <&pins_eth4>;
+
+	phy-reset-gpios = <&gpio1b 25 GPIO_ACTIVE_HIGH>;
+	phy-reset-duration = <15>;
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	portA: phy_mii4: ethernet-phy@5 {
+		device_type = "ethernet-phy";
+		phy-mode = "mii";
+		reg = <5>;
+		/* Set LED0 as active low link status */
+		micrel,led-mode = <1>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <4>;
+	};
+	portB: phy_mii3: ethernet-phy@4 {
+		device_type = "ethernet-phy";
+		phy-mode = "mii";
+		reg = <4>;
+		/* Set LED0 as active low link status */
+		micrel,led-mode = <1>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <3>;
+	};
+	portC: phy_mii2: ethernet-phy@10 {
+		/* Ext Board: Marvell 88E1512 PHY on J24 */
+		device_type = "ethernet-phy";
+		phy-mode = "rgmii-id";
+		reg = <10>;
+		/* Set LED0 as active low link status, LED2 as interrupt */
+		marvell,reg-init = <3 16 0 0x1010 3 18 0 0x4980>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <2>;
+	};
+	portD: phy_mii1: ethernet-phy@1 {
+		/* Ext Board: Marvell 88E1512 PHY on J23 */
+		device_type = "ethernet-phy";
+		phy-mode = "rgmii-id";
+		reg = <1>;
+		/* Set LED0 as active low link status, LED2 as interrupt */
+		marvell,reg-init = <3 16 0 0x1010 3 18 0 0x4980>;
+		interrupt-parent = <&gpioirq>;
+		interrupts = <1>;
+	};
+};
+&eth_miic {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_refclk>;
+	/* RIN Mode Control - GMAC1 on all Switch ports */
+	mode_control = <0x13>;
+
+	mii0: eth-mii0 {
+		phy-handle = <&phy_mii0>;
+	};
+	mii1: eth-mii1 {
+		phy-handle = <&phy_mii1>;
+	};
+	mii2: eth-mii2 {
+		phy-handle = <&phy_mii2>;
+	};
+	mii3: eth-mii3 {
+		phy-handle = <&phy_mii3>;
+	};
+	mii4: eth-mii4 {
+		phy-handle = <&phy_mii4>;
+	};
+};
+&qspi0 {
+	status = "okay";
+	u-boot,dm-pre-reloc;
+
+	flash: mx25l25635@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "macronix,mx25l25635e", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <62500000>;
+		spi-cpha;
+		spi-cpol;
+		spi-rx-bus-width = <4>;
+		renesas,rzn1-read-cmd = <0x6b 8 0>;
+		renesas,rzn1-readcap-delay = <1>;
+		/* The properties below are used by U-Boot */
+		tshsl-ns = <30>;
+		tsd2d-ns = <3>;
+		tchsh-ns = <3>;
+		tslch-ns = <3>;
+		memory-map = <RZN1_V_QSPI_BASE RZN1_V_QSPI_SIZE>;
+		memory-map-write = <1>;
+		u-boot,dm-pre-reloc;
+
+		partition@0 {
+			/* 64KB */
+			label = "qspi0:spl";
+			reg = <0x0000000 0x00010000>;
+		};
+		partition@1 {
+			/* 64KB */
+			label = "qspi0:pkgt";
+			reg = <0x0010000 0x00010000>;
+		};
+		partition@2 {
+			/* 512KB */
+			label = "qspi0:u-boot";
+			reg = <0x0020000 0x00080000>;
+		};
+		partition@3 {
+			/* 64KB */
+			label = "qspi0:env";
+			reg = <0x00a0000 0x00010000>;
+		};
+		partition@4 {
+			/* 128KB */
+			label = "qspi0:dtb";
+			reg = <0x00b0000 0x00020000>;
+		};
+		partition@5 {
+			/* 1MB */
+			label = "qspi0:cm3";
+			reg = <0x00d0000 0x00100000>;
+		};
+		partition@6 {
+			/* 6MB */
+			label = "qspi0:kernel";
+			reg = <0x01d0000 0x00600000>;
+		};
+		partition@7 {
+			/* Remaining */
+			label = "qspi0:data";
+			reg = <0x07d0000 0>;
+		};
+	};
+};
+&usbf {
+	status = "okay";
+};
+&usbh_pci {
+	/* Ext Board */
+	status = "okay";
+};
+&wdtsafe0 {
+	status = "okay";
+};
+&dma0 {
+	status = "okay";
+	/* Select spi0, spi1, spi2, spi3, uart3, uart4, uart5, uart6 */
+	rzn1_cfg_dmamux = <0x0000ffff>;
+	rzn1_cfg_dmamux_mask = <0x0000ffff>;
+};
+&spi0 {
+	status = "okay";
+	dmas =  <&dma0 8 0 0>,
+		<&dma0 9 0 0>;
+	dma-names = "rx", "tx";
+
+	/* Ext Board: Serial (SPI) F-RAM device (FM25V10-G) */
+	fram: fm25@0 {
+		compatible = "cypress,fm25";
+		reg = <0>;
+		/* Reduced clock rate due to quickswitch */
+		spi-max-frequency = <21000000>;
+	};
+};
+&sdio0 {
+	/* Ext Board */
+	status = "okay";
+};
+&rtc0 {
+	status = "okay";
+};
+&can1 {
+	/* Ext Board */
+	status = "okay";
+};
+&fb0 {
+	status = "okay";
+
+	bits-per-pixel = <32>;
+	bus-width = <24>;
+
+	/* Ext Board: NewHaven 5" LCD module NHD-5.0-800480TF-ATXL#-CTP  */
+	backlight-pwm-clock = <300>;
+	display-timings {
+		native-mode = <&timing0>;
+		timing0: timing0 {
+			clock-frequency = <33400000>;
+			hactive = <800>;
+			vactive = <480>;
+			hback-porch = <88>;
+			hfront-porch = <40>;
+			vback-porch = <32>;
+			vfront-porch = <13>;
+			hsync-len = <1>;
+			vsync-len = <3>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/rzn1d400_preset_db.dts b/arch/arm/boot/dts/rzn1d400_preset_db.dts
new file mode 100644
index 0000000..d6a7fdf
--- /dev/null
+++ b/arch/arm/boot/dts/rzn1d400_preset_db.dts
@@ -0,0 +1,502 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <rzn1.dtsi>
+
+/*
+ * AUTOGENERATED DO NOT EDIT
+ *
+ * Renesas RZ/N1D Demo Board
+ * This file only sets the pin function by default.
+ *
+ * You can override the default mux pullup/down and drive by
+ * defining the following macros in the board file before
+ * including this.
+ */
+
+#ifndef RZN1_MUX_DEFAULT
+#define RZN1_MUX_DEFAULT RZN1_MUX
+#endif
+
+#ifndef RZN1_MUX_CAN0
+#define RZN1_MUX_CAN0 RZN1_MUX_6MA
+#endif
+#ifndef RZN1_MUX_CAN1
+#define RZN1_MUX_CAN1 RZN1_MUX_6MA
+#endif
+#ifndef RZN1_MUX_ETH0
+#define RZN1_MUX_ETH0 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH1
+#define RZN1_MUX_ETH1 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH2
+#define RZN1_MUX_ETH2 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH3
+#define RZN1_MUX_ETH3 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_ETH4
+#define RZN1_MUX_ETH4 RZN1_MUX_PNONE_6MA
+#endif
+#ifndef RZN1_MUX_GPIO
+#define RZN1_MUX_GPIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_GPIO1
+#define RZN1_MUX_GPIO1 RZN1_MUX_GPIO
+#endif
+#ifndef RZN1_MUX_GPIO2
+#define RZN1_MUX_GPIO2 RZN1_MUX_GPIO
+#endif
+#ifndef RZN1_MUX_I2C1
+#define RZN1_MUX_I2C1 RZN1_MUX_12MA
+#endif
+#ifndef RZN1_MUX_LCD
+#define RZN1_MUX_LCD RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_MDIO
+#define RZN1_MUX_MDIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_MDIO0
+#define RZN1_MUX_MDIO0 RZN1_MUX_MDIO
+#endif
+#ifndef RZN1_MUX_MDIO1
+#define RZN1_MUX_MDIO1 RZN1_MUX_MDIO
+#endif
+#ifndef RZN1_MUX_NMI
+#define RZN1_MUX_NMI RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_QSPI0
+#define RZN1_MUX_QSPI0 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_REFCLK
+#define RZN1_MUX_REFCLK RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_SDIO
+#define RZN1_MUX_SDIO RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_SDIO0
+#define RZN1_MUX_SDIO0 RZN1_MUX_SDIO
+#endif
+#ifndef RZN1_MUX_SPI
+#define RZN1_MUX_SPI RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_SPI0
+#define RZN1_MUX_SPI0 RZN1_MUX_SPI
+#endif
+#ifndef RZN1_MUX_SWITCH
+#define RZN1_MUX_SWITCH RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_UART0
+#define RZN1_MUX_UART0 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_UART2
+#define RZN1_MUX_UART2 RZN1_MUX_PNONE
+#endif
+#ifndef RZN1_MUX_UART
+#define RZN1_MUX_UART RZN1_MUX_DEFAULT
+#endif
+#ifndef RZN1_MUX_UART3
+#define RZN1_MUX_UART3 RZN1_MUX_UART
+#endif
+#ifndef RZN1_MUX_USB
+#define RZN1_MUX_USB RZN1_MUX_DEFAULT
+#endif
+
+&pinctrl {
+	pins_can0: pins_can0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_CAN0(162, CAN)		/* CAN0_TXD */
+			RZN1_MUX_CAN0(163, CAN)		/* CAN0_RXD */
+		>;
+	};
+	pins_can1: pins_can1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_CAN1(109, CAN)		/* CAN1_TXD */
+			RZN1_MUX_CAN1(110, CAN)		/* CAN1_RXD */
+		>;
+	};
+	pins_eth0: pins_eth0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH0(0, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXCLK */
+			RZN1_MUX_ETH0(1, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXD[0] */
+			RZN1_MUX_ETH0(2, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXD[1] */
+			RZN1_MUX_ETH0(3, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXD[2] */
+			RZN1_MUX_ETH0(4, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXD[3] */
+			RZN1_MUX_ETH0(5, CLK_ETH_MII_RGMII_RMII)	/* ETH0_TXEN */
+			RZN1_MUX_ETH0(6, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXCLK */
+			RZN1_MUX_ETH0(7, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXD[0] */
+			RZN1_MUX_ETH0(8, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXD[1] */
+			RZN1_MUX_ETH0(9, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXD[2] */
+			RZN1_MUX_ETH0(10, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXD[3] */
+			RZN1_MUX_ETH0(11, CLK_ETH_MII_RGMII_RMII)	/* ETH0_RXDV */
+		>;
+	};
+	pins_eth1: pins_eth1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH1(12, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXCLK */
+			RZN1_MUX_ETH1(13, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXD[0] */
+			RZN1_MUX_ETH1(14, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXD[1] */
+			RZN1_MUX_ETH1(15, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXD[2] */
+			RZN1_MUX_ETH1(16, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXD[3] */
+			RZN1_MUX_ETH1(17, CLK_ETH_MII_RGMII_RMII)	/* ETH1_TXEN */
+			RZN1_MUX_ETH1(18, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXCLK */
+			RZN1_MUX_ETH1(19, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXD[0] */
+			RZN1_MUX_ETH1(20, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXD[1] */
+			RZN1_MUX_ETH1(21, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXD[2] */
+			RZN1_MUX_ETH1(22, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXD[3] */
+			RZN1_MUX_ETH1(23, CLK_ETH_MII_RGMII_RMII)	/* ETH1_RXDV */
+		>;
+	};
+	pins_eth2: pins_eth2 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH2(24, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXCLK */
+			RZN1_MUX_ETH2(25, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXD[0] */
+			RZN1_MUX_ETH2(26, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXD[1] */
+			RZN1_MUX_ETH2(27, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXD[2] */
+			RZN1_MUX_ETH2(28, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXD[3] */
+			RZN1_MUX_ETH2(29, CLK_ETH_MII_RGMII_RMII)	/* ETH2_TXEN */
+			RZN1_MUX_ETH2(30, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXCLK */
+			RZN1_MUX_ETH2(31, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXD[0] */
+			RZN1_MUX_ETH2(32, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXD[1] */
+			RZN1_MUX_ETH2(33, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXD[2] */
+			RZN1_MUX_ETH2(34, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXD[3] */
+			RZN1_MUX_ETH2(35, CLK_ETH_MII_RGMII_RMII)	/* ETH2_RXDV */
+		>;
+	};
+	pins_eth3: pins_eth3 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH3(36, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXCLK */
+			RZN1_MUX_ETH3(37, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXD[0] */
+			RZN1_MUX_ETH3(38, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXD[1] */
+			RZN1_MUX_ETH3(39, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXD[2] */
+			RZN1_MUX_ETH3(40, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXD[3] */
+			RZN1_MUX_ETH3(41, CLK_ETH_MII_RGMII_RMII)	/* ETH3_TXEN */
+			RZN1_MUX_ETH3(42, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXCLK */
+			RZN1_MUX_ETH3(43, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXD[0] */
+			RZN1_MUX_ETH3(44, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXD[1] */
+			RZN1_MUX_ETH3(45, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXD[2] */
+			RZN1_MUX_ETH3(46, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXD[3] */
+			RZN1_MUX_ETH3(47, CLK_ETH_MII_RGMII_RMII)	/* ETH3_RXDV */
+		>;
+	};
+	pins_eth4: pins_eth4 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_ETH4(48, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXCLK */
+			RZN1_MUX_ETH4(49, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXD[0] */
+			RZN1_MUX_ETH4(50, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXD[1] */
+			RZN1_MUX_ETH4(51, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXD[2] */
+			RZN1_MUX_ETH4(52, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXD[3] */
+			RZN1_MUX_ETH4(53, CLK_ETH_MII_RGMII_RMII)	/* ETH4_TXEN */
+			RZN1_MUX_ETH4(54, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXCLK */
+			RZN1_MUX_ETH4(55, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXD[0] */
+			RZN1_MUX_ETH4(56, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXD[1] */
+			RZN1_MUX_ETH4(57, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXD[2] */
+			RZN1_MUX_ETH4(58, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXD[3] */
+			RZN1_MUX_ETH4(59, CLK_ETH_MII_RGMII_RMII)	/* ETH4_RXDV */
+		>;
+	};
+	pins_gpio1: pins_gpio1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_GPIO1(83, GPIO)	/* PMOD_1 (GPIO1B[14]) */
+			RZN1_MUX_GPIO1(84, GPIO)	/* PMOD_2 (GPIO1B[15]) */
+			RZN1_MUX_GPIO1(85, GPIO)	/* PMOD_2 (GPIO1B[16]) */
+			RZN1_MUX_GPIO1(86, GPIO)	/* PMOD_2 (GPIO1B[17]) */
+			RZN1_MUX_GPIO1(87, GPIO)	/* PMOD_2 (GPIO1B[18]) */
+			RZN1_MUX_GPIO1(88, GPIO)	/* PMOD_3 (GPIO1B[19]) */
+			RZN1_MUX_GPIO1(89, GPIO)	/* PMOD_3 (GPIO1B[20]) */
+			RZN1_MUX_GPIO1(90, GPIO)	/* PMOD_3 (GPIO1B[21]) */
+			RZN1_MUX_GPIO1(91, GPIO)	/* PMOD_3 (GPIO1B[22]) */
+			RZN1_MUX_GPIO1(92, GPIO)	/* LED_2R (GPIO1B[23]) */
+			RZN1_MUX_GPIO1(93, GPIO)	/* LED_2G (GPIO1B[24]) */
+			RZN1_MUX_GPIO1(94, GPIO)	/* ETH_PHY_RESET (GPIO1B[25]) */
+			RZN1_MUX_GPIO1(117, GPIO)	/* GPIO1A[27] */
+			RZN1_MUX_GPIO1(118, GPIO)	/* ETHERNET Port3 IRQ (GPIO1A[28]) */
+			RZN1_MUX_GPIO1(154, GPIO)	/* GPIO2 (GPIO1B[30]) */
+			RZN1_MUX_GPIO1(155, GPIO)	/* GPIO (GPIO1B[31]) */
+		>;
+	};
+	pins_gpio2: pins_gpio2 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_GPIO2(126, GPIO)	/* ETHERNET Port2 IRQ (GPIO2A[4]) */
+			RZN1_MUX_GPIO2(146, GPIO)	/* ETHERNET Port1  IRQ (GPIO2A[24]) */
+			RZN1_MUX_GPIO2(147, GPIO)	/* Eth Port4 IRQ (GPIO2A[25]) */
+			RZN1_MUX_GPIO2(148, GPIO)	/* TouchSCRN_IRQ (GPIO2A[26]) */
+			RZN1_MUX_GPIO2(149, GPIO)	/* Eth Port5 IRQ (GPIO2A[27]) */
+		>;
+	};
+	pins_i2c1: pins_i2c1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_I2C1(115, I2C)		/* I2C1_SCL */
+			RZN1_MUX_I2C1(116, I2C)		/* I2C1_SDA */
+		>;
+	};
+	pins_lcd: pins_lcd {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_LCD(62, LCD)		/* LCD_R[1] */
+			RZN1_MUX_LCD(63, LCD)		/* LCD_G[1] */
+			RZN1_MUX_LCD(64, LCD)		/* LCD_B[1] */
+			RZN1_MUX_LCD(65, LCD)		/* LCD_R[2] */
+			RZN1_MUX_LCD(66, LCD)		/* LCD_G[2] */
+			RZN1_MUX_LCD(67, LCD)		/* LCD_B[2] */
+			RZN1_MUX_LCD(68, LCD)		/* LCD_R[3] */
+			RZN1_MUX_LCD(69, LCD)		/* LCD_G[3] */
+			RZN1_MUX_LCD(70, LCD)		/* LCD_B[3] */
+			RZN1_MUX_LCD(71, LCD)		/* LCD_R[4] */
+			RZN1_MUX_LCD(72, LCD)		/* LCD_G[4] */
+			RZN1_MUX_LCD(73, LCD)		/* LCD_B[4] */
+			RZN1_MUX_LCD(127, LCD)		/* LCD_PWM[0] */
+			RZN1_MUX_LCD(128, LCD)		/* LCD_PCLK */
+			RZN1_MUX_LCD(129, LCD)		/* LCD_HSYNC */
+			RZN1_MUX_LCD(130, LCD)		/* LCD_VSYNC */
+			RZN1_MUX_LCD(131, LCD)		/* LCD_DE */
+			RZN1_MUX_LCD(132, LCD)		/* LCD_PE */
+			RZN1_MUX_LCD(133, LCD)		/* LCD_PWM[1] */
+			RZN1_MUX_LCD(134, LCD)		/* LCD_R[5] */
+			RZN1_MUX_LCD(135, LCD)		/* LCD_R[0] */
+			RZN1_MUX_LCD(136, LCD)		/* LCD_G[0] */
+			RZN1_MUX_LCD(137, LCD)		/* LCD_B[0] */
+			RZN1_MUX_LCD(138, LCD)		/* LCD_R[6] */
+			RZN1_MUX_LCD(139, LCD)		/* LCD_G[6] */
+			RZN1_MUX_LCD(140, LCD)		/* LCD_B[6] */
+			RZN1_MUX_LCD(141, LCD)		/* LCD_R[7] */
+			RZN1_MUX_LCD(142, LCD)		/* LCD_G[7] */
+			RZN1_MUX_LCD(143, LCD)		/* LCD_B[7] */
+			RZN1_MUX_LCD(144, LCD)		/* LCD_G[5] */
+			RZN1_MUX_LCD(145, LCD)		/* LCD_B[5] */
+		>;
+	};
+	pins_mdio0: pins_mdio0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_MDIO0(150, ETH_MDIO)	/* MDIO0_MDC */
+			RZN1_MUX_MDIO0(151, ETH_MDIO)	/* MDIO0_MDIO */
+			RZN1_MUX_MDIO0(170, MDIO_MUX_MAC0)	/* MDIO0_MUX_MAC0 */
+		>;
+	};
+	pins_mdio1: pins_mdio1 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_MDIO1(152, ETH_MDIO_E1)	/* MDIO1_MDC */
+			RZN1_MUX_MDIO1(153, ETH_MDIO)	/* MDIO1_MDIO */
+			RZN1_MUX_MDIO1(171, MDIO_MUX_SWITCH)	/* MDIO1_MUX_SWITCH */
+		>;
+	};
+	pins_nmi: pins_nmi {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_NMI(111, ETHERCAT)	/* NMI_CORTEXM[3] */
+		>;
+	};
+	pins_qspi0: pins_qspi0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_QSPI0(74, QSPI)	/* QSPI0_CS_N[0] */
+			RZN1_MUX_QSPI0(75, QSPI)	/* QSPI0_IO[3] */
+			RZN1_MUX_QSPI0(76, QSPI)	/* QSPI0_IO[2] */
+			RZN1_MUX_QSPI0(77, QSPI)	/* QSPI0_IO[1] */
+			RZN1_MUX_QSPI0(78, QSPI)	/* QSPI0_IO[0] */
+			RZN1_MUX_QSPI0(79, QSPI)	/* QSPI0_CLK */
+		>;
+	};
+	pins_refclk: pins_refclk {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_REFCLK(60, CLK_ETH_MII_RGMII_RMII)	/* REFCLK_RGMII */
+			RZN1_MUX_REFCLK(61, CLK_ETH_NAND)	/* REFCLK_MII */
+		>;
+	};
+	pins_sdio0: pins_sdio0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_SDIO0(95, SDIO)	/* SDIO0_CMD */
+			RZN1_MUX_12MA(96, SDIO)		/* SDIO0_CLK */
+			RZN1_MUX_SDIO0(97, SDIO)	/* SDIO0_IO[0] */
+			RZN1_MUX_SDIO0(98, SDIO)	/* SDIO0_IO[1] */
+			RZN1_MUX_SDIO0(99, SDIO)	/* SDIO0_IO[2] */
+			RZN1_MUX_SDIO0(100, SDIO)	/* SDIO0_IO[3] */
+			RZN1_MUX_SDIO0(101, SDIO_E)	/* SDIO0_CD_N */
+			RZN1_MUX_SDIO0(102, SDIO_E)	/* SDIO0_WP */
+		>;
+	};
+	pins_spi0: pins_spi0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_SPI0(156, SPI0_M)	/* SPI0_CLK */
+			RZN1_MUX_SPI0(157, SPI0_M)	/* SPI0_MOSI */
+			RZN1_MUX_SPI0(158, SPI0_M)	/* SPI0_MISO */
+			RZN1_MUX_SPI0(159, SPI0_M)	/* SPI0_SS_N[0] */
+		>;
+	};
+	pins_switch: pins_switch {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_SWITCH(80, MAC_MTIP_SWITCH)	/* SWITCH_MII_LINK[5] */
+			RZN1_MUX_SWITCH(81, MAC_MTIP_SWITCH)	/* SWITCH_MII_LINK[4] */
+			RZN1_MUX_SWITCH(82, MAC_MTIP_SWITCH)	/* SWITCH_MII_LINK[3] */
+			RZN1_MUX_SWITCH(114, MAC_MTIP_SWITCH)	/* SWITCH_MII_LINK[2] */
+		>;
+	};
+	pins_uart0: pins_uart0 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_UART0(103, UART0_I)	/* UART0_TXD */
+			RZN1_MUX_UART0(104, UART0_I)	/* UART0_RXD */
+		>;
+	};
+	pins_uart2: pins_uart2 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_UART2(105, UART2)	/* UART2_TXD */
+			RZN1_MUX_UART2(106, UART2)	/* UART2_RXD */
+			RZN1_MUX_UART2(107, UART2)	/* UART2_RTS_N */
+			RZN1_MUX_UART2(108, UART2)	/* UART2_CTS_N */
+		>;
+	};
+	pins_uart3: pins_uart3 {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_UART3(123, UART3)	/* UART3_TXD */
+			RZN1_MUX_UART3(124, UART3)	/* UART3_RXD */
+			RZN1_MUX_UART3(125, UART3)	/* UART3_RTS_N */
+		>;
+	};
+	pins_usb: pins_usb {
+		renesas,rzn1-pinmux-ids = <
+			RZN1_MUX_USB(119, USB)		/* USB_PPON[1] */
+			RZN1_MUX_USB(120, USB)		/* USB_OC[1] */
+			RZN1_MUX_USB(121, USB)		/* USB_PPON[2] */
+			RZN1_MUX_USB(122, USB)		/* USB_OC[2] */
+		>;
+	};
+};
+
+&can0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_can0>;
+};
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_can1>;
+};
+&eth0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth0>;
+};
+&eth1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth1>;
+};
+&eth2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth2>;
+};
+&eth3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth3>;
+};
+&eth4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_eth4>;
+};
+&gpio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_gpio1>;
+};
+&gpio2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_gpio2>;
+};
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_i2c1>;
+};
+&lcd {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_lcd>;
+};
+&mdio0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio0>;
+};
+&mdio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_mdio1>;
+};
+&nmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_nmi>;
+};
+&qspi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_qspi0>;
+};
+&refclk {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_refclk>;
+};
+&sdio0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_sdio0>;
+};
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_spi0>;
+};
+&switch {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_switch>;
+};
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_uart0>;
+};
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_uart2>;
+};
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_uart3>;
+};
+&usb {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pins_usb>;
+};
+
+/* 
+ * this is the compressed Renesas Pinmux Web App data structure; this is
+ * used to allow uploading this file back into the web app, make some
+ * more changes and generate/save the DTS again. It is not used by linux
+ * in any way.
+ */
+#ifdef JSON_PRESET
+N4IgdghgtgpiBcIBKMwwM4XQAiQLQHoA5ARgBFsyYoB7bAIRogCcATEAGhAAcIBjANYQA5nEQwALAAYpnHjGYBLbgAsFEADboEAb
+RABhAIKk5RogCY5AUQAqACRLX7lrrbsBmJ3YleArHIBxAAUASQB5FxBg8M8uEPN9SIAZfTI5AFkycMcuTPDIonSQuQBFAGVQnOQr
+ADF9JIBpOTKssKqKkPaAdRCbfTs5AFVDJBsq4dHYkAmbHy5BsvoQAF0uYW5FGgB9SFhteFAATktENyskIltsIJpmABd3bBCkErkS
+KQB2BBAg9LCyLZVd4ADm+v3+gLeUkOYL+AKB71hEIRjkQ4IBkRIJBOPzhW0xJE8aLxBJ8xIhBP85IBUyxADYkTS3iQvtStrSSKC2
+RyYYgklYMUg3uZZHyBfiAsLUSA3FsgnYAJpbJBWMq2YUMxDRCLC1lRUJhN7uHFnC5XG73cxPF5vXwm+znS42a63O4kbDW15cEi+I
+kyu4qF33CSe21kkA2GgAVz4KjK+guW2eXpAPqp/sDFruvlDAF81hsaPsdB9fBIWXSOKXyx8PlWyyzgfWa4dm5ypG3gSRO+ZO+5Ox
+JO75O5Xq5y62PgU3J62x4cO3Pu3Pe3P+3PB3Ph3PRw3DhPd9Pd7OyyKFyepEvzyvz2vzxvz1vzzuJCL9y+pIf38eX+9m+YsX+2KA
+beP73j+j4/s+/5vv+n7/t+5gin+/7IdeL7mCBiFgYhEGIVB5gweYcHmAh7hni+7iXhRaEYZh7jYe4w6+L4Hx0kRHDMR8U7DvR7h0
+pWvF0nWglNoJra8R8HYSd2Em9hJ/YSYOEk8RI7isRwEl1sxXZlhxvg6Ux+k+pW2k+lpRn6XpOmtr47zmIOtlSOYTF2ZWEisYcrbu
+ZJHbeReHB+b2fn9n5g5+cOflubWnwBdFTZ+V5ta/vRJCqQFxzAocAnlhIKmpdlqXCTlol0iQe4aaVhxNr4bEfIc3Y1QRxwcXSvq+
+i1bUOa1jFMd1NUcPZuWZQNEi5fOGk1YcPGTQJk1ae8lm+FIdKeUxy2eVFHzuCFtb0RVVUKStwJKUdPFHW5PpTQFl0Xb45XeS+Gmj
+ZRT2qXJz0Kc9SnPSpqnZapRWqaJz3iaN0iveWEPvc9EPfaNv0SP97kQ8Do2JaxQW1nSO2sWFWNnUtcmtVIh2sVJxMRbWkmxUlAXl
+lOdOcl55bjaNZXdoNdKPZzaW2WxJl2liyy5kAA==
+#endif
diff --git a/arch/arm/configs/rzn1_defconfig b/arch/arm/configs/rzn1_defconfig
new file mode 100644
index 0000000..c77f20c
--- /dev/null
+++ b/arch/arm/configs/rzn1_defconfig
@@ -0,0 +1,273 @@
+CONFIG_KERNEL_LZO=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+# CONFIG_UID16 is not set
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_ELF_CORE is not set
+# CONFIG_SHMEM is not set
+# CONFIG_ADVISE_SYSCALLS is not set
+CONFIG_EMBEDDED=y
+CONFIG_SLAB=y
+CONFIG_JUMP_LABEL=y
+CONFIG_CC_STACKPROTECTOR_STRONG=y
+CONFIG_MODULES=y
+CONFIG_ARCH_RZN1=y
+CONFIG_ARM_LPAE=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_PL310_ERRATA_588369=y
+# CONFIG_ARM_ERRATA_643719 is not set
+CONFIG_PCI=y
+CONFIG_PCI_RCAR_GEN2=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+# CONFIG_ARM_CPU_TOPOLOGY is not set
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_NR_CPUS=2
+CONFIG_AEABI=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_CLEANCACHE=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_VFP=y
+# CONFIG_SUSPEND is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+CONFIG_CAN=y
+CONFIG_CAN_SJA1000=y
+CONFIG_CAN_SJA1000_PLATFORM=y
+CONFIG_CAN_PEAK_USB=y
+CONFIG_CFG80211=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_RZN1_MSEBI=y
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_ROM=y
+CONFIG_MTD_ABSENT=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_ECC_BCH=y
+CONFIG_MTD_NAND_EVATRONIX=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_RZN1_QSPI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HP is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+CONFIG_NET_VENDOR_MORETHANIP=y
+CONFIG_MTIP_SWITCH=y
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+CONFIG_RZN1_MIIC=y
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+CONFIG_STMMAC_ETH=y
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MARVELL_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_SMSC_PHY=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN_VENDOR_ADMTEK is not set
+CONFIG_ATH6KL=y
+CONFIG_ATH6KL_SDIO=y
+# CONFIG_WLAN_VENDOR_ATMEL is not set
+# CONFIG_WLAN_VENDOR_BROADCOM is not set
+# CONFIG_WLAN_VENDOR_CISCO is not set
+# CONFIG_WLAN_VENDOR_INTEL is not set
+# CONFIG_WLAN_VENDOR_INTERSIL is not set
+# CONFIG_WLAN_VENDOR_MARVELL is not set
+# CONFIG_WLAN_VENDOR_MEDIATEK is not set
+# CONFIG_WLAN_VENDOR_RALINK is not set
+# CONFIG_WLAN_VENDOR_REALTEK is not set
+# CONFIG_WLAN_VENDOR_RSI is not set
+# CONFIG_WLAN_VENDOR_ST is not set
+# CONFIG_WLAN_VENDOR_TI is not set
+# CONFIG_WLAN_VENDOR_ZYDAS is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_EDT_FT5X06=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_RZNCTC=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_SPI=y
+CONFIG_SPI_CADENCE=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_MMIO=y
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_SENSORS_LM75=y
+CONFIG_WATCHDOG=y
+CONFIG_FB=y
+CONFIG_FB_DB9000=y
+CONFIG_FB_DB9000_BLINK=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_DB9000_LCD=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_DEBUG_FS=y
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=4
+CONFIG_USBF_RENESAS=y
+CONFIG_USB_ETH=y
+CONFIG_USB_LED_TRIG=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_EDAC=y
+CONFIG_EDAC_MM_EDAC=y
+CONFIG_EDAC_CADENCE_MC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_RZN1=y
+CONFIG_DMADEVICES=y
+CONFIG_DW_DMAC=y
+CONFIG_RZN1_TIMER=y
+CONFIG_MAILBOX=y
+CONFIG_PL320_MBOX=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_USE_FOR_EXT2 is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_SUMMARY=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_DWARF4=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_PAGEALLOC=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_STACK_END_CHECK=y
+CONFIG_STACKTRACE=y
+CONFIG_SPARSE_RCU_POINTER=y
+CONFIG_RCU_TRACE=y
+# CONFIG_FTRACE is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_UART_8250=y
+CONFIG_DEBUG_UART_PHYS=0x40060000
+CONFIG_DEBUG_UART_VIRT=0xf0060000
+CONFIG_DEBUG_UART_8250_WORD=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_ECHAINIV is not set
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_HW is not set
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
diff --git a/arch/arm/mach-rzn1/Kconfig b/arch/arm/mach-rzn1/Kconfig
new file mode 100644
index 0000000..6bb27e7
--- /dev/null
+++ b/arch/arm/mach-rzn1/Kconfig
@@ -0,0 +1,12 @@
+
+config ARCH_RZN1
+	bool "Renesas RZ/N1"
+	select ARM_AMBA
+	select USE_OF
+	select ARCH_WANT_OPTIONAL_GPIOLIB
+	select ARM_GIC
+	select CPU_V7
+	select USE_OF
+	select PINCTRL
+	select PINCTRL_RZN1
+	select HAVE_SMP
diff --git a/arch/arm/mach-rzn1/Makefile b/arch/arm/mach-rzn1/Makefile
new file mode 100644
index 0000000..bddb680
--- /dev/null
+++ b/arch/arm/mach-rzn1/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the linux kernel.
+#
+
+ccflags-$(CONFIG_ARCH_MULTIPLATFORM) := -I$(srctree)/arch/arm/mach-rzn1/include
+
+obj-$(CONFIG_ARCH_RZN1)		+= setup-rzn1.o sysctrl-rzn1.o rzn1-gpioirq.o
+obj-$(CONFIG_SMP) += platsmp.o
diff --git a/arch/arm/mach-rzn1/headsmp.S b/arch/arm/mach-rzn1/headsmp.S
new file mode 100644
index 0000000..c477116
--- /dev/null
+++ b/arch/arm/mach-rzn1/headsmp.S
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <dt-bindings/soc/rzn1-sysctrl.h>
+#include <dt-bindings/soc/rzn1-memory-map.h>
+
+#define GIC_BASE 	(RZN1_GIC_BASE + 0x2000)
+#define BOOTADDR	(RZN1_SYSTEM_CTRL_BASE + RZN1_SYSCTRL_REG_BOOTADDR)
+#define BOOTADDR2		CONFIG_RZN1_SMP_ALT_BOOTADDR
+#define BOOTADDR2_CANARY	0x525a4e31
+/*
+ * RZ/N1 specific entry point for secondary CPUs. The second CPU enables
+ * interrupts for itself (in masked state), then loops on a wfi for the
+ * kernel to wake it up, have a look at the BOOTADDR for an address,
+ * picks it up (and clears BOOTADDR) then just branches out.
+ */
+ENTRY(rzn1_secondary_startup)
+
+	ldr	pc, =_reset 		@ reset vector
+	ldr	pc, =_undf		@ undef
+	ldr	pc, =_undf		@ svc
+	ldr	pc, =_undf		@ abort
+	ldr	pc, =_undf		@ irq
+	nop
+fiq:	b	fiq
+_undf:	b	_undf
+
+_reset:
+	mrc	p15, 0, r0, c0, c0, 5	@ get processor id
+	and	r0, r0, #15		@ What CPU am I?
+	bne	_cpu1
+
+	b 	park
+_cpu1:	@ they both go in park anyway
+park:
+	ldr 	r2, =BOOTADDR2_CANARY
+	ldr	r0, =BOOTADDR2		@ Check for canary in PEN2+4 location
+	add	r0, #4
+	ldr     r1, [r0]
+	cmp	r1, r2
+	ldr	r0, =BOOTADDR2
+	ldrne	r0, =BOOTADDR
+
+	mov	r3, #0
+	ldr 	r2, =GIC_BASE
+
+	mov 	r1, #1
+	str 	r1, [r2] 		@ set GICC_CTLR.Enable
+	mov 	r1, #255
+	str 	r1, [r2, #4] 		@ set GIC_PMR.Priority to 0xff
+	dsb
+
+pen:	wfi
+	ldr     r1, [r0]
+	tst     r1, r1
+	beq	pen
+	str	r3, [r0]		@ Clear BOOTADDR
+	bx	r1
+	.ltorg
+ENDPROC(rzn1_secondary_startup)
diff --git a/arch/arm/mach-rzn1/platsmp.c b/arch/arm/mach-rzn1/platsmp.c
new file mode 100644
index 0000000..4ddcafc
--- /dev/null
+++ b/arch/arm/mach-rzn1/platsmp.c
@@ -0,0 +1,110 @@
+/*
+ * SMP support for Renesas RZ/N1
+ *
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * Based on code
+ *  Copyright (C) 2012-2013 Allwinner Ltd.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/memory.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/smp.h>
+#include <asm/system_misc.h>
+
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/sysctrl-rzn1.h>
+
+#include <linux/reset.h>
+#include <linux/cpu.h>
+#include <asm/cacheflush.h>
+#include <asm/cp15.h>
+#include <asm/smp_scu.h>
+#include <asm/smp_plat.h>
+#include <asm/mach/map.h>
+
+#define BOOTADDR2_CANARY	0x525a4e31
+
+static void __iomem *pen2_base;
+
+static DEFINE_SPINLOCK(cpu_lock);
+
+/* The alternate boot address for the second core can be overriden in the DT,
+ * typically this will happen if the bootloader decides to park the second
+ * core somewhere else than the fixed ALT_BOOTADDR address
+ */
+static void __init rzn1_smp_prepare_cpus(unsigned int max_cpus)
+{
+	u32 bootaddr = 0;
+	struct device_node *np = of_find_node_by_path("/chosen");
+
+	if (np)
+		of_property_read_u32(np, "rzn1,bootaddr", &bootaddr);
+
+	if (bootaddr &&
+		bootaddr != RZN1_SYSCTRL_REG_BOOTADDR &&
+		bootaddr != (RZN1_SYSTEM_CTRL_BASE+RZN1_SYSCTRL_REG_BOOTADDR)) {
+
+		pr_info("RZ/N1 CPU#2 boot address %08x\n", bootaddr);
+		pen2_base = ioremap(bootaddr, 8);
+
+		if (!pen2_base) {
+			pr_warn("Couldn't map RZ/N1 CPU#2 PEN2\n");
+			return;
+		}
+	} else {
+		pr_info("RZ/N1 CPU#2 boot address not specified - using SYSCTRL reg\n");
+	}
+}
+
+static int rzn1_smp_boot_secondary(unsigned int cpu,
+				    struct task_struct *idle)
+{
+	u32 t = (u32)virt_to_phys(secondary_startup);
+
+	/* Set CPU boot address */
+	if (pen2_base && (readl(pen2_base + 4) == BOOTADDR2_CANARY))
+		pr_info("RZ/N1 CPU#%d writing %08x to boot address\n", cpu, t);
+	else
+		pr_info("RZ/N1 CPU#%d writing %08x to SYSCTRL reg\n", cpu, t);
+
+	spin_lock(&cpu_lock);
+
+	/* Set CPU boot address */
+	if (pen2_base && (readl(pen2_base + 4) == BOOTADDR2_CANARY))
+		writel(virt_to_phys(secondary_startup), pen2_base);
+	else
+		rzn1_sysctrl_writel(virt_to_phys(secondary_startup),
+			RZN1_SYSCTRL_REG_BOOTADDR);
+
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&cpu_lock);
+
+	return 0;
+}
+
+struct smp_operations rzn1_smp_ops __initdata = {
+	.smp_prepare_cpus	= rzn1_smp_prepare_cpus,
+	.smp_boot_secondary	= rzn1_smp_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(rzn1_smp, "renesas,rzn1", &rzn1_smp_ops);
diff --git a/arch/arm/mach-rzn1/rzn1-gpioirq.c b/arch/arm/mach-rzn1/rzn1-gpioirq.c
new file mode 100644
index 0000000..fa5a6bf
--- /dev/null
+++ b/arch/arm/mach-rzn1/rzn1-gpioirq.c
@@ -0,0 +1,380 @@
+/*
+ * RZ/N1 GPIO IRQ Muxer interface
+ *
+ * Copyright (C) 2016 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/mach/arch.h>
+#include <dt-bindings/interrupt-controller/rzn1-irq.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl-rzn1.h>
+#include <linux/sysctrl-rzn1.h>
+
+/*
+ * This driver configures and redirects the RZ/N1 8 GPIO IRQs to their
+ * respective GPIO blocks.
+ * It also provides a 'direct' way to use these interrupts for drivers who are
+ * not compatible with GPIO based interupts and need a raw one.
+ *
+ * So the driver acts as an interrupt controller with 8 'direct' forward IRQs
+ * and 3 that are hooked to the GPIO blocks.
+ */
+/*
+   This example shows the propagation for a normal GPIO IRQ, for example the
+   gpio-key driver. The 'direct' interrupt isn't needed, it's passed on to the
+   GPIO block, and forward on.
+	GIC		gpioirq				Client Driver
+	GPIO_0	+->	0				<no direct client>
+		|->	8/9/10	->	DWAPB1/2/3  ->	gpio-key
+
+   This second use case is for a driver that requires an IRQ, not a GPIO. here
+   the gpioirq will have to claim the corresponding gpio to make sure DWAPB
+   configures it properly.
+   The direct interrupt is passed on to the client driver, and the 'gpio'
+   interrupt is just passed on to the dummy handler.
+	GPIO_1  +->	1       ->                      Ethernet MAC Port 1
+		|->     8/9/10  ->      DWAPB1/2/3
+		        dummy   <-          <-|
+ */
+#define DRIVER_DESC     "Renesas RZ/N1 GPIO IRQ Mux Driver"
+#define DRIVER_AUTHOR   "Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>"
+#define DRIVER_VERSION  "0.1"
+
+static const char driver_name[] = "girq_renesas";
+static const char driver_desc[] = DRIVER_DESC;
+
+enum {
+	GIRQ_IRQ_FORWARD = 0,
+	GIRQ_IRQ_GPIO0 = 8,
+	GIRQ_IRQ_GPIO1,
+	GIRQ_IRQ_GPIO2,
+	GIRQ_IRQ_COUNT
+};
+
+struct girq {
+	struct device *dev;
+	struct device_node *np;
+	struct irq_domain *irq_domain;
+	struct {
+		int irq;	/* this is the one from the GIC */
+		int gpio_irq;	/* this is the one from the gpio_chip */
+		unsigned enabled: 1, masked: 1, configured: 1, claimed: 1;
+		unsigned bank : 3;
+	} irq[GIRQ_IRQ_COUNT];
+};
+
+static struct girq *g_irq;
+
+static irqreturn_t girq_handler(
+	int inirq, void *dev_id)
+{
+	struct girq *g = dev_id;
+	struct irq_desc *desc = irq_to_desc(inirq);
+	unsigned long hwirq = desc->irq_data.hwirq;
+	int irq;
+
+	irq = hwirq - 32 - RZN1_IRQ_GPIO_0; /* convert to local hw_irq */
+
+	/* this clearly shouldn't happend unless the devtree is rotten */
+	BUG_ON(irq < 0 || irq > 7);
+
+	/*
+	 * If both that GPIO and that bank are mapped and ready, fire these
+	 * interrupts. We first fire the GPIO bank one so it has a chance to
+	 * clear the GPIO interrupt itself.
+	 * This will in turn call girq_dummy_handler() somehow, however, we
+	 * also then propagate the GIC interrupt we've just received by
+	 * passing it on to our own hw_irq handler
+	 */
+	if (g->irq[irq].configured &&
+	    g->irq[GIRQ_IRQ_GPIO0 + g->irq[irq].bank].enabled) {
+		int gpio_block = irq_find_mapping(g->irq_domain,
+			GIRQ_IRQ_GPIO0 + g->irq[irq].bank);
+
+		/* tell the GPIO bank driver to clear the GPIO irq and forward
+		 * to whomever might have requested it as an IRQ */
+		generic_handle_irq(gpio_block);
+	}
+	if (g->irq[irq].enabled) {
+		int forward = irq_find_mapping(g->irq_domain, irq);
+		/* Also forward it to any chained sub-irq with that number */
+		generic_handle_irq(forward);
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t girq_dummy_handler(
+	int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+/*
+ * 'configuring' one of these 8 GPIO irq involves claiming it from the GIC,
+ * finding which GPIO it want it muxed to, which bank of GPIO it is, then set
+ * it up so the interrupt can be forwarded to the GPIO block, which in turn
+ * will pass it on to the normal GPIO handler down the line.
+ */
+static int girq_configure_hwirq(
+	struct girq *g, int hw_irq)
+{
+	struct gpio_chip *chip;
+	u32 gpio_resbase;
+	char prop[16];
+	int i, gpio, bank;
+
+	if (g->irq[hw_irq].configured)
+		return 0;
+
+	sprintf(prop, "gpioirq-%c", '0' + hw_irq);
+	/* need to do that, otherwise the gpiochip of code complains on the
+	 * console about the property not being present etc, even tho these
+	 * are optional anyway */
+	if (!of_get_property(g->np, prop, NULL))
+		return -1;
+	gpio = of_get_named_gpio_flags(g->np, prop, 0, 0);
+	if (gpio < 0) {
+		dev_err(g->dev, "%s is not available\n", prop);
+		return -1;
+	}
+	/*
+	 * Take the Linux GPIO number (assume 'random') and figure out
+	 * which of the GPIO blocks it belongs to, first get the gpio_chip, then
+	 * compare their 'res' property address with the gpio blocks we have in
+	 * out own DT 'res' node for comparison. It is a little bit involved,
+	 * but it's the cleanest way I could find to do this.
+	 */
+	chip = gpio_to_chip(gpio);
+	if (!chip) {
+		dev_err(g->dev, "no chip for GPIO %d\n", gpio);
+		return -1;
+	}
+	/* no need to convert from be32, as we compare the same order anyway */
+	gpio_resbase = *of_get_address(chip->parent->of_node, 0, NULL, NULL);
+
+	for (bank = -1, i = 0; i < 3 && bank == -1; i++)
+		if (*of_get_address(g->np, i, NULL, NULL) == gpio_resbase)
+			bank = i;
+	if (bank == -1) {
+		dev_err(g->dev, "gpio %d is not in a suitable bank\n", gpio);
+		return -1;
+	}
+	dev_info(g->dev, "gpio %d aka GPIO%cA[%d] mapped to irq %d\n",
+		gpio, '0' + bank, gpio - chip->base, hw_irq);
+
+	g->irq[hw_irq].irq = of_irq_get(g->np, hw_irq);
+	g->irq[hw_irq].gpio_irq = gpio_to_irq(gpio);
+	g->irq[hw_irq].bank = bank;
+	g->irq[hw_irq].configured = 1;
+
+	rzn1_pinctrl_gpioint_select(hw_irq, (bank * 32) + (gpio - chip->base));
+
+	if (devm_request_irq(g->dev, g->irq[hw_irq].irq, girq_handler, 0,
+			dev_name(g->dev), g)) {
+		dev_err(g->dev, "failed to request GIC IRQ %d\n",
+			g->irq[hw_irq].irq);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Enabling the IRQ is a bit tricker -- this means someone wants to use the
+ * GPIO_X interrupt directly (without using it as a GPIO) so we need to /claim/
+ * it as a SHARED interrupt handler (doing nothing) so the downstream driver can
+ * also claim it without having to worry about the fact the interrupt is a GPIO
+ */
+static void girq_enable(
+	struct irq_data *d)
+{
+	struct girq *g = g_irq;
+	int hw_irq = irqd_to_hwirq(d);
+
+	BUG_ON(hw_irq >= GIRQ_IRQ_COUNT);
+
+	/* GPIO block interrupts don't need any special handling */
+	if (hw_irq >= GIRQ_IRQ_GPIO0) {
+		/* enable the bank interrupt, to make sure we don't forward
+		 * IRQs to a missing handler in case it's misconfigured */
+		g->irq[hw_irq].enabled = 1;
+		return;
+	}
+	/* not really an error here, log it. */
+	if (g->irq[hw_irq].enabled) {
+		dev_err(g->dev, "IRQ %d is already enabled\n", hw_irq);
+		return;
+	}
+	if (!g->irq[hw_irq].configured) {
+		if (girq_configure_hwirq(g, hw_irq)) {
+			dev_err(g->dev, "IRQ %d can't be configured\n", hw_irq);
+			return;
+		}
+	}
+	if (!g->irq[hw_irq].claimed) {
+		if (devm_request_irq(g->dev, g->irq[hw_irq].gpio_irq,
+				girq_dummy_handler, IRQF_SHARED | IRQF_TRIGGER_FALLING,
+				dev_name(g->dev), g)) {
+			dev_err(g->dev, "failed to request GPIO IRQ %d\n",
+				g->irq[hw_irq].irq);
+			return;
+		}
+		g->irq[hw_irq].claimed = 1;
+	}
+	g->irq[hw_irq].enabled = 1;
+}
+
+/* Don't /really/ need to release anything here; perhaps we should? */
+static void
+girq_disable(
+	struct irq_data *d)
+{
+	struct girq *g = g_irq;
+	int hw_irq = irqd_to_hwirq(d);
+
+	/* dev_info(g->dev, "IRQ %d disable ignored\n", hw_irq); */
+	/* not really an error here, log it. */
+	if (!g->irq[hw_irq].enabled)
+		dev_err(g->dev, "IRQ %d is already disabled\n", hw_irq);
+	g->irq[hw_irq].enabled = 0;
+}
+
+/* Don't /really/ need this, but the irq_chip code will crash if not there */
+static void
+girq_mask(
+	struct irq_data *d)
+{
+	struct girq *g = g_irq;
+	int hw_irq = irqd_to_hwirq(d);
+
+	g->irq[hw_irq].masked = 1;
+}
+/* Don't /really/ need this, but the irq_chip code will crash if not there */
+static void
+girq_unmask(
+	struct irq_data *d)
+{
+	struct girq *g = g_irq;
+	int hw_irq = irqd_to_hwirq(d);
+
+	g->irq[hw_irq].masked = 0;
+}
+
+/*
+ * Preconfigure IRQs if they haven't been explicitely asked by a handler
+ * already (at boot time). This allows drivers to use the old method of claiming
+ * a GPIO irq and it will work, as long as the mux is configured properly
+ * with the qpioirq-X DT property
+ */
+static int __init girq_late_init(void)
+{
+	struct girq *g = g_irq;
+	int i;
+
+	if (!g)	/* probe failed perhaps? */
+		return 0;
+
+	dev_info(g->dev, "Initializing mapping\n");
+
+	for (i = 0; i < 8; i++)
+		girq_configure_hwirq(g, i);
+
+	return 0;
+}
+late_initcall(girq_late_init);
+
+static int girq_probe(
+	struct platform_device *ofdev)
+{
+	int ret = -ENOMEM;
+	struct device *dev = &ofdev->dev;
+	struct device_node *np = ofdev->dev.of_node;
+	struct girq *g;
+	struct irq_chip_generic	*gc = NULL;
+
+	g = devm_kzalloc(dev, sizeof(*g), GFP_KERNEL);
+	if (!g)
+		return -ENOMEM;
+	g->dev = dev;
+	g->np = np;
+
+	g->irq_domain = irq_domain_add_linear(np, GIRQ_IRQ_COUNT,
+					      &irq_generic_chip_ops, g);
+	if (!g->irq_domain) {
+		ret = -ENXIO;
+		dev_err(dev, "cannot initialize irq domain\n");
+		goto invalid_mapping;
+	}
+	if (irq_alloc_domain_generic_chips(g->irq_domain, GIRQ_IRQ_COUNT, 1,
+				"rzn1-gpioirq", handle_level_irq,
+				IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN,
+				0, 0)) {
+		dev_err(dev, "irq_alloc_domain_generic_chips failed\n");
+		goto post_domain;
+	}
+	gc = irq_get_domain_generic_chip(g->irq_domain, 0);
+
+	gc->chip_types[0].chip.irq_mask = girq_mask; /* required */
+	gc->chip_types[0].chip.irq_unmask = girq_unmask;
+	gc->chip_types[0].chip.irq_disable = girq_disable;
+	gc->chip_types[0].chip.irq_enable = girq_enable;
+
+	irq_setup_generic_chip(gc, IRQ_MSK(GIRQ_IRQ_COUNT),
+				IRQ_GC_INIT_NESTED_LOCK, IRQ_NOREQUEST, 0);
+
+	g_irq = g;
+	return 0;
+
+post_domain:
+	irq_domain_remove(g->irq_domain);
+invalid_mapping:
+	return ret;
+}
+
+static int girq_remove(
+	struct platform_device *pdev)
+{
+	struct girq *g = platform_get_drvdata(pdev);
+
+	irq_domain_remove(g->irq_domain);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static const struct of_device_id girq_match[] = {
+	{ .compatible = "renesas,rzn1-gpioirq", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, girq_match);
+
+static struct platform_driver girq_driver = {
+	.driver = {
+		.name = driver_name,
+		.owner = THIS_MODULE,
+		.of_match_table = girq_match,
+	},
+	.probe          = girq_probe,
+	.remove         = girq_remove,
+};
+
+module_platform_driver(girq_driver);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-rzn1/setup-rzn1.c b/arch/arm/mach-rzn1/setup-rzn1.c
new file mode 100644
index 0000000..456f9cf
--- /dev/null
+++ b/arch/arm/mach-rzn1/setup-rzn1.c
@@ -0,0 +1,59 @@
+/*
+ * RZ/N1 processor support file (placeholder)
+ *
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/of_platform.h>
+#include <asm/mach/arch.h>
+#include <linux/sysctrl-rzn1.h>
+
+extern struct smp_operations rzn1_smp_ops;
+
+/* TODO ? */
+void __init rzn1_add_dt_devices(void)
+{
+/*	printk("%s\n", __func__); */
+}
+
+/* TODO ? */
+void __init rzn1_init_early(void)
+{
+/*	printk("%s\n", __func__); */
+}
+
+static void rzn1_restart(enum reboot_mode mode, const char *cmd)
+{
+	printk("%s\n", __func__);
+
+	rzn1_sysctrl_writel(
+			rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_RSTEN) |
+			(1 << RZN1_SYSCTRL_REG_RSTEN_SWRST_EN) |
+				(1 << RZN1_SYSCTRL_REG_RSTEN_MRESET_EN),
+			RZN1_SYSCTRL_REG_RSTEN);
+	rzn1_sysctrl_writel(
+			rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_RSTCTRL) |
+			(1 << RZN1_SYSCTRL_REG_RSTCTRL_SWRST_REQ),
+			RZN1_SYSCTRL_REG_RSTCTRL);
+}
+
+#ifdef CONFIG_USE_OF
+static const char *rzn1_boards_compat_dt[] __initdata = {
+	"renesas,rzn1",
+	NULL,
+};
+
+DT_MACHINE_START(rzn1_DT, "Renesas RZ/N1 (DT)")
+	.smp 		= smp_ops(rzn1_smp_ops),
+	.init_early	= rzn1_init_early,
+	.dt_compat	= rzn1_boards_compat_dt,
+	.restart	= rzn1_restart,
+MACHINE_END
+#endif /* CONFIG_USE_OF */
diff --git a/arch/arm/mach-rzn1/sysctrl-rzn1.c b/arch/arm/mach-rzn1/sysctrl-rzn1.c
new file mode 100644
index 0000000..1e73cf4
--- /dev/null
+++ b/arch/arm/mach-rzn1/sysctrl-rzn1.c
@@ -0,0 +1,38 @@
+/*
+ * RZ/N1 sysctrl access API
+ *
+ * Copyright (C) 2014-2016 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sysctrl-rzn1.h>
+
+static void __iomem *sysctrl_base_addr;
+
+
+static void __iomem *watchdog_base_addr;
+
+void __init rzn1_sysctrl_init(void)
+{
+	if (sysctrl_base_addr)
+		return;
+	sysctrl_base_addr = ioremap(RZN1_SYSTEM_CTRL_BASE,
+					RZN1_SYSTEM_CTRL_SIZE);
+	BUG_ON(!sysctrl_base_addr);
+
+	watchdog_base_addr = ioremap(RZN1_WATCHDOG0_BASE,
+					3 * RZN1_WATCHDOG0_SIZE);
+	BUG_ON(!watchdog_base_addr);
+}
+
+void __iomem *rzn1_sysctrl_base(void)
+{
+	BUG_ON(!sysctrl_base_addr);
+	return sysctrl_base_addr;
+}
diff --git a/drivers/bus/Kconfig b/drivers/bus/Kconfig
index 7875105..14e48d9 100644
--- a/drivers/bus/Kconfig
+++ b/drivers/bus/Kconfig
@@ -85,6 +85,14 @@ config MIPS_CDMM
 	  platform code needs to implement mips_cdmm_phys_base() (see
 	  asm/cdmm.h).
 
+config RZN1_MSEBI
+	bool "MSEBI driver"
+	depends on ARCH_RZN1
+	help
+	  Driver for MSEBI Master controller.
+	  The MSEBI (Medium Speed External Bus Interface) is programmable bus.
+	  You can attach many different devices on it, such as NOR, onenand.
+
 config MVEBU_MBUS
 	bool
 	depends on PLAT_ORION
diff --git a/drivers/bus/Makefile b/drivers/bus/Makefile
index c6cfa6b..21d9e10 100644
--- a/drivers/bus/Makefile
+++ b/drivers/bus/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_BRCMSTB_GISB_ARB)	+= brcmstb_gisb.o
 obj-$(CONFIG_IMX_WEIM)		+= imx-weim.o
 obj-$(CONFIG_MIPS_CDMM)		+= mips_cdmm.o
 obj-$(CONFIG_MVEBU_MBUS) 	+= mvebu-mbus.o
+obj-$(CONFIG_RZN1_MSEBI) 	+= rzn1-msebi.o
 
 # Interconnect bus driver for OMAP SoCs.
 obj-$(CONFIG_OMAP_INTERCONNECT)	+= omap_l3_smx.o omap_l3_noc.o
diff --git a/drivers/bus/rzn1-msebi.c b/drivers/bus/rzn1-msebi.c
new file mode 100644
index 0000000..fbc3b36
--- /dev/null
+++ b/drivers/bus/rzn1-msebi.c
@@ -0,0 +1,140 @@
+/*
+ * MSEBI driver for Renesas RZ/N1 chips
+ * Copyright (C) 2015 Renesas Electronics Europe Ltd.
+ *
+ * Based on imx-weim driver
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+
+#define MSEBI_MAX_CS 4
+#define MSEBI_NR_TIMING_REGS 3
+#define MSEBI_CS_STRIDE 0x100
+#define MSEBI_CS_CYCLESIZE_REG	0x00
+#define MSEBI_CS_SETUPHOLD_REG	0x04
+#define MSEBI_CS_CONFIG_REG	0x60
+#define MSEBI_CONFIG_REG	0x800
+#define MSEBI_CONFIG_DIRBUF_REG	0x804
+
+static const struct of_device_id msebi_id_table[] = {
+	{ .compatible = "renesas,rzn1-msebi", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, msebi_id_table);
+
+/* Parse and set the timing for this device. */
+static int __init msebi_timing_setup(struct device_node *np, void __iomem *base)
+{
+	u32 cs_idx, value[MSEBI_NR_TIMING_REGS];
+	int ret;
+
+	/* get the CS index from this child node's "reg" property. */
+	ret = of_property_read_u32(np, "reg", &cs_idx);
+	if (ret)
+		return ret;
+
+	if (cs_idx >= MSEBI_MAX_CS)
+		return -EINVAL;
+
+	ret = of_property_read_u32_array(np, "renesas,msebi-cs-timing",
+					 value, MSEBI_NR_TIMING_REGS);
+	if (ret)
+		return ret;
+
+	/* set the timing */
+	writel(value[0], base + cs_idx * MSEBI_CS_STRIDE + MSEBI_CS_CYCLESIZE_REG);
+	writel(value[1], base + cs_idx * MSEBI_CS_STRIDE + MSEBI_CS_SETUPHOLD_REG);
+	writel(value[2], base + cs_idx * MSEBI_CS_STRIDE + MSEBI_CS_CONFIG_REG);
+
+	return 0;
+}
+
+static int __init msebi_parse_dt(struct platform_device *pdev,
+				void __iomem *base)
+{
+	struct device_node *child;
+	int ret, have_child = 0;
+	u32 cfg;
+
+	ret = of_property_read_u32(pdev->dev.of_node, "renesas,msebi-config", &cfg);
+	if (ret)
+		return ret;
+	writel(cfg, base + MSEBI_CONFIG_REG);
+
+	ret = of_property_read_u32(pdev->dev.of_node, "renesas,msebi-config-dirbuf", &cfg);
+	if (ret)
+		return ret;
+	writel(cfg, base + MSEBI_CONFIG_DIRBUF_REG);
+
+	for_each_child_of_node(pdev->dev.of_node, child) {
+		if (!child->name)
+			continue;
+
+		ret = msebi_timing_setup(child, base);
+		if (ret)
+			dev_warn(&pdev->dev, "%s set timing failed.\n",
+				child->full_name);
+		else
+			have_child = 1;
+	}
+
+	if (have_child)
+		ret = of_platform_populate(pdev->dev.of_node,
+				   of_default_bus_match_table,
+				   NULL, &pdev->dev);
+	if (ret)
+		dev_err(&pdev->dev, "%s fail to create devices.\n",
+			pdev->dev.of_node->full_name);
+	return ret;
+}
+
+static int __init msebi_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct clk *clk;
+	void __iomem *base;
+	int ret;
+
+	/* get the resource */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	/* get the clock */
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	ret = clk_prepare_enable(clk);
+	if (ret)
+		return ret;
+
+	/* parse the device node */
+	ret = msebi_parse_dt(pdev, base);
+	if (ret)
+		clk_disable_unprepare(clk);
+	else
+		dev_info(&pdev->dev, "Driver registered.\n");
+
+	return ret;
+}
+
+static struct platform_driver msebi_driver = {
+	.driver = {
+		.name		= "renesas-msebi",
+		.of_match_table	= msebi_id_table,
+	},
+};
+module_platform_driver_probe(msebi_driver, msebi_probe);
+
+MODULE_AUTHOR("Renesas Electronics Europe Ltd");
+MODULE_DESCRIPTION("RZ/N1 MSEBI Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index dcc0973..981a365 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -590,5 +590,7 @@ config TILE_SROM
 
 source "drivers/char/xillybus/Kconfig"
 
+source "drivers/char/ctc/Kconfig"
+
 endmenu
 
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 6e6c244..310d0a5 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -60,3 +60,5 @@ js-rtc-y = rtc.o
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
 obj-$(CONFIG_XILLYBUS)		+= xillybus/
 obj-$(CONFIG_POWERNV_OP_PANEL)	+= powernv-op-panel.o
+
+obj-$(CONFIG_RZNCTC)		+= ctc/
diff --git a/drivers/char/ctc/Kconfig b/drivers/char/ctc/Kconfig
new file mode 100644
index 0000000..7cdca7f
--- /dev/null
+++ b/drivers/char/ctc/Kconfig
@@ -0,0 +1,15 @@
+#
+# Core2Core
+#
+
+menu "RZ/N CTC"
+
+config RZNCTC
+	bool "RZ/N Core2Core device support"
+	default n
+	help
+	  Say Y here if you want to support the RZ/N Core2Core.
+	  When in doubt, say "Y".
+
+endmenu
+
diff --git a/drivers/char/ctc/Makefile b/drivers/char/ctc/Makefile
new file mode 100644
index 0000000..c4516ae
--- /dev/null
+++ b/drivers/char/ctc/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_RZNCTC) += goal_target_ctc_kernel.o
diff --git a/drivers/char/ctc/goal_target_ctc_kernel.c b/drivers/char/ctc/goal_target_ctc_kernel.c
new file mode 100644
index 0000000..93be27d
--- /dev/null
+++ b/drivers/char/ctc/goal_target_ctc_kernel.c
@@ -0,0 +1,1008 @@
+/** @file
+ *
+ * @brief Core to core module
+ *
+ * This module implements the core to core functionality between the M3 and A7 core
+ * of the RZ-N.
+ *
+ * @copyright
+ * (C) Copyright 2017 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/kfifo.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pl320-ipc.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <linux/types.h>
+#include <linux/uio.h>
+#include <linux/workqueue.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+
+/****************************************************************************/
+/* Local defines */
+/****************************************************************************/
+#define CTC_KERNEL_VERSION_MAJOR 2              /**< major version of the kernel */
+#define CTC_KERNEL_VERSION_MINOR 0              /**< minor version of the kernel */
+
+#define CTC_CHANNEL_NUM 5                       /**< Number of channels */
+
+#define CTC_DEVICE_NAME "ctc"                   /**< Name of sysfs device */
+
+#define CTC_DEVICE_FILE "c2c_chan%u"            /**< Device file name in /dev */
+
+#define CTC_FIFO_SIZE 16                        /**< Number of elements in fifo. kfifo requires a power of 2 */
+
+#define CTC_WORK_QUEUE_NAME "CTC_FIFO_WQUEUE"   /**< Work queue */
+
+/**< 16 pages of 64 bytes = 1024 Bytes write buffer per channel */
+#define CTC_PAGE_COUNT_EXPONENT 4               /**< exponent of the number of pages */
+#define CTC_PAGE_SIZE_EXPONENT 6                /**< exponent of the size of a page */
+
+#define CTC_PAGE_COUNT (1 << CTC_PAGE_COUNT_EXPONENT)
+#define CTC_PAGE_SIZE (1 << CTC_PAGE_SIZE_EXPONENT)
+
+#define CTC_MEM_NAME "ctc_mem"                  /**< name of memory */
+/**< size of shm for one direction */
+#define CTC_MEM_SIZE (CTC_PAGE_COUNT * CTC_PAGE_SIZE * CTC_CHANNEL_NUM)
+#define CTC_MEM_OFFSET_RX (CTC_MEM_SIZE)
+
+/**< types of a mailbox message */
+#define CTC_MBOX_MSG_REQ 0
+#define CTC_MBOX_MSG_RES 1
+
+/**< construction of mailbox data */
+#ifndef CTC_MBOX_TIME_MS
+#define CTC_MBOX_TIME_MS 500                    /**< time till mailbox message shall be send in ms */
+#endif
+#define CTC_MBOX_LEN 7                          /**< mailbox data length */
+
+#define CTC_MBOX_DATA0_SIZE_MSK 0x0000FFFF      /**< mask for data length */
+#define CTC_MBOX_DATA1_DST_OFFSET 16            /**< offset for direction */
+#define CTC_MBOX_DATA0_DST_MSK 0x00FF0000       /**< mask for direction */
+#define CTC_MBOX_DATA1_CHN_OFFSET 24            /**< offset for channel */
+#define CTC_MBOX_DATA0_CHN_MSK 0xFF000000       /**< mask for channel */
+
+#define CTC_MBOX_DATA1_PGE_MSK 0xFFFFFFFF       /**< mask page number */
+
+/**< io ctl defines */
+#define CTC_IOCTL_NUM 0x0C2C                    /**< magic number */
+#define CTC_IOCTL_SIZE_FRAGMENT _IOR(CTC_IOCTL_NUM, 0, int) /**< read the fragment size */
+#define CTC_IOCTL_SET_MBOX_MS _IOW(CTC_IOCTL_NUM, 1, int) /**< set the maximal mailbox waiting time */
+#define CTC_IOCTL_SETUP_CYCLIC _IO(CTC_IOCTL_NUM, 2) /**< io control cmd for setup a cyclic channel */
+#define CTC_IOCTL_VERSION _IOR(CTC_IOCTL_NUM, 3, int) /**< io control cmd for reading ctc kernel major version */
+
+
+/****************************************************************************/
+/* Makros */
+/****************************************************************************/
+#define CTC_GET_TIME_MS(hdlTime) ((hdlTime.tv_sec * 1000) + (hdlTime.tv_nsec / 1000000)) /**< read time in ms */
+
+
+/****************************************************************************/
+/* Local structs/enums */
+/****************************************************************************/
+/**< FIFO data entry for received data */
+struct ctcDataEntry {
+    void *pBuf;                                 /**< pointer to data on shared memory */
+    __u16 size;                                 /**< size of data */
+};
+
+/**< Device structure */
+struct ctcDeviceData {
+    struct cdev chrdev;                         /**< character device */
+    int minor;                                  /**< minor number */
+    struct device *sysDev;                      /**< sysfs device */
+    int wrIdx;                                  /**< write index */
+    int rdIdx;                                  /**< read index */
+    char *pWrData;                              /**< pointer to write data buffer (virtual memory) */
+    DECLARE_KFIFO(rdFifo, struct ctcDataEntry *, CTC_FIFO_SIZE); /**< read fifo */
+    pid_t pid;                                  /**< PID of the user space process */
+    wait_queue_head_t ctcRxWait;                /**< wait queue for read fifo */
+    struct mutex ctc_mutex;                     /**< mutex for ctc device */
+    bool flgCyclic;                             /**< flag for cyclic data */
+};
+
+/**< Work queue entry */
+typedef struct {
+    struct work_struct ctcWork;                 /**< core to core work queue */
+    __u32 ctcMboxData[CTC_MBOX_LEN];            /**< data received from mailbox */
+} CTC_WORK_T;
+
+
+/****************************************************************************/
+/* Local prototypes */
+/****************************************************************************/
+static int ctc_open(
+    struct inode *pInode,                       /**< pointer to inode */
+    struct file *pFile                          /**< pointer to file */
+);
+
+static int ctc_release(
+    struct inode *pInode,                       /**< pointer to inode */
+    struct file *pFile                          /**< pointer to file */
+);
+
+static ssize_t ctc_read(
+    struct file *pFile,                         /**< file handler */
+    char *pBuf,                                 /**< buffer */
+    size_t len,                                 /**< length */
+    loff_t *pOffset                             /**< offset */
+);
+
+static ssize_t ctc_write(
+    struct file *pFile,                         /**< file handler */
+    const char *pBuf,                           /**< buffer */
+    size_t len,                                 /**< length */
+    loff_t *pOffset                             /**< offset */
+);
+
+long ctc_ioctl(
+    struct file *pFile,                         /**< file handler */
+    unsigned int cmd,                           /**< io control command */
+    unsigned long arg                           /**< pointer to user data as ulong */
+);
+
+static void ctc_cleanup(
+    void
+);
+
+static int ctc_create_devices(
+    void
+);
+
+static int ctc_init_mbox(
+    void
+);
+
+static int ctc_init_shm(
+    void
+);
+
+static int ctc_notifier(
+    struct notifier_block *pNb,                 /**< notifier block */
+    unsigned long page,                         /**< first element is the start page of the message */
+    void *pData                                 /**< pointer to second element */
+);
+
+static int ctc_mBoxRxNewJob(
+    int minor,                                  /**< minor number */
+    void *pBuf,                                 /**< data buffer */
+    __u16 size                                  /**< buffer length */
+);
+
+static int ctc_mBoxRxRes(
+    int minor,                                  /**< minor number */
+    __u16 size                                  /**< buffer length */
+);
+
+static size_t ctcCalcPages(
+    size_t len,                                 /**< data length */
+    int ctcIdx,                                 /**< index of mailbox fifo */
+    int *pReqPages,                             /**< required pages */
+    int *pOffsetIdx                             /**< offset to write index */
+);
+
+static void ctcSetMboxMsg(
+    __u32 *pCtcMboxData,                        /**< data for mailbox */
+    int minor,                                  /**< minor number */
+    __u32 page,                                 /**< first message page */
+    __u16 len,                                  /**< data length */
+    char ctcMsgType                             /**< request or acknowledge */
+);
+
+static void ctcGetMboxMsg(
+    __u32 *pCtcMboxData,                        /**< data for mailbox */
+    int *pMinor,                                /**< minor number */
+    __u16 *pLen,                                /**< data length */
+    char *pCtcMsgType                           /**< request or acknowledge */
+);
+
+
+/****************************************************************************/
+/* Local variables */
+/****************************************************************************/
+static dev_t ctcDev = 0;                        /**< core to core device */
+static int ctcMajor = 0;                        /**< core to core major number */
+static struct class *ctcCharClass = NULL;       /**< core to core char class */
+
+/**< File operations for char devices */
+static struct file_operations ctc_fops =
+{
+    .open = ctc_open,
+    .read = ctc_read,
+    .write = ctc_write,
+    .release = ctc_release,
+    .unlocked_ioctl = ctc_ioctl,
+};
+
+/**< Core to core notifier */
+static struct notifier_block ctc_nb = {
+    .notifier_call = ctc_notifier,
+};
+
+static struct ctcDeviceData ctcDevices[CTC_CHANNEL_NUM]; /**< core to core devices */
+static void *pVirtKernMem;                      /**< data buffer as virtual kernel memory */
+static struct workqueue_struct *fifo_workqueue = NULL; /**< fifo queue for work */
+static unsigned int ctcMboxTimeoutMs = CTC_MBOX_TIME_MS; /**< mailbox waiting time */
+
+
+/****************************************************************************/
+/** Initializes the core to core module
+ *
+ * This function initialize the core to core module on Linux. A requirement
+ * next to the char devices is the mailbox driver.
+ *
+ * @return 0 if successful, otherwise error code
+ */
+static int __init ctc_init(
+    void
+)
+{
+    int res;                                    /* response */
+
+    printk(KERN_INFO "CTC: Start initialization of CTC module version %u.%u.\n", CTC_KERNEL_VERSION_MAJOR, CTC_KERNEL_VERSION_MINOR);
+
+    memset(&(ctcDevices[0]), 0, sizeof(struct ctcDeviceData) * CTC_CHANNEL_NUM);
+
+    /* Alloc char dev regions */
+    res = alloc_chrdev_region(&ctcDev, 0, CTC_CHANNEL_NUM, CTC_DEVICE_NAME);
+    if (res) {
+        printk(KERN_NOTICE "CTC: %s - Failed to alloc char devs.\n", __func__);
+        return -EFAULT;
+    }
+    ctcMajor = MAJOR(ctcDev);
+
+    /* Create class in sysfs */
+    ctcCharClass = class_create(THIS_MODULE, CTC_DEVICE_NAME);
+    printk(KERN_NOTICE "CTC: Created ctc class.\n");
+
+    /* Create char devices */
+    res = ctc_create_devices();
+    if (res) {
+        ctc_cleanup();
+        return res;
+    }
+
+    /* Init mailbox and interrupt handler */
+    res = ctc_init_mbox();
+    if (res) {
+        ctc_cleanup();
+        return res;
+    }
+
+    /* Create the workqueue for signaling */
+    fifo_workqueue = create_workqueue(CTC_WORK_QUEUE_NAME);
+
+    printk(KERN_INFO "CTC: CTC module version %u.%u initialized.\n", CTC_KERNEL_VERSION_MAJOR, CTC_KERNEL_VERSION_MINOR);
+
+    return 0;
+}
+
+
+/****************************************************************************/
+/** Initializes the shared memory
+ *
+ * This function initialize the shared memory for linux usage. The device
+ * tree node c2c_sram contains the physical start address and the length of
+ * the whole shared memory. It is remaped to Kernel space, thus the module is
+ * able to read received messages.
+ *
+ * @return 0 if successful, otherwise error code
+ */
+static int ctc_init_shm(
+    void
+)
+{
+    struct device_node *pDp;                    /* device tree node for shared memory register */
+    struct resource res;                        /* recource */
+    int ret;                                    /* return value */
+    unsigned int ctc_sramSize;                  /* size of SRAM */
+
+    /* find the SRAM node */
+    pDp = of_find_compatible_node(NULL, NULL, "mmio-sram");
+    if (!pDp) {
+        /* Error */
+        printk(KERN_ALERT "CTC: %s - unable to find node c2c_sram.\n", __func__);
+        return -EFAULT;
+    }
+
+    /* read the memory size */
+    ret = of_address_to_resource(pDp, 0, &res);
+    if (0 > ret) {
+        printk(KERN_ALERT "CTC: %s - could not get address for node %s.\n",
+               __func__, pDp->full_name);
+        of_node_put(pDp);
+        return ret;
+    }
+    ctc_sramSize = resource_size(&res);
+    if ((CTC_MEM_SIZE << 1) > ctc_sramSize) {
+        printk(KERN_ALERT "CTC: %s - Shared memory is too small: 0x%X byte availible 0x%X byte needed.\n", __func__, ctc_sramSize, (CTC_MEM_SIZE << 1));
+        of_node_put(pDp);
+        return -EFAULT;
+    }
+
+    /* map the SRAM */
+    pVirtKernMem = of_iomap(pDp, 0);
+    if (NULL == pVirtKernMem) {
+        printk(KERN_NOTICE "CTC: %s - unable to remap 0x%X byte\n", __func__, ctc_sramSize);
+        of_node_put(pDp);
+        return -EFAULT;
+    }
+
+    /* clear the memory for transmission */
+    memset(pVirtKernMem, 0, CTC_MEM_SIZE);
+
+    of_node_put(pDp);
+
+    return 0;
+}
+
+
+/****************************************************************************/
+/** Initializes the char devices for the different channels
+ *
+ * All devices are created here. The shared memory region of reading and
+ * writing is initialized at the beginning to ensure available of the needed
+ * RAM.
+ * Right after, the individual char devices and sysfs devices are initialized.
+ *
+ * @return 0 if successful, otherwise error code
+ */
+static int ctc_create_devices(
+    void
+)
+{
+    int res;                                    /* response */
+    int idx;                                    /* index */
+    char buffer[10];                            /* buffer for device name */
+
+    /* initialize the shared memory */
+    res = ctc_init_shm();
+    if (res) {
+        return res;
+    }
+
+    /* Init individual char devs and sysfs devices */
+    for (idx = 0; idx < CTC_CHANNEL_NUM; idx++) {
+        cdev_init(&(ctcDevices[idx].chrdev), &ctc_fops);
+        ctcDevices[idx].chrdev.owner = THIS_MODULE;
+        ctcDevices[idx].chrdev.ops = &ctc_fops;
+        ctcDevices[idx].minor = idx;
+        res = cdev_add(&(ctcDevices[idx].chrdev), MKDEV(ctcMajor, idx), 1);
+        if (res) {
+            printk(KERN_NOTICE "CTC: %s - Failed to alloc char devs.\n", __func__);
+            return -EFAULT;
+        } else {
+            printk(KERN_NOTICE "CTC: Created device "CTC_DEVICE_FILE".\n", idx);
+        }
+        sprintf(buffer, CTC_DEVICE_FILE, idx);
+        ctcDevices[idx].sysDev = device_create(ctcCharClass, NULL, MKDEV(ctcMajor, idx), NULL, buffer);
+
+        /* Init the fifo for the mailbox messages */
+        INIT_KFIFO(ctcDevices[idx].rdFifo);
+
+        ctcDevices[idx].pWrData = (char *) (pVirtKernMem + (CTC_PAGE_COUNT * CTC_PAGE_SIZE * idx));
+
+        ctcDevices[idx].wrIdx = 0;
+        ctcDevices[idx].rdIdx = 0;
+        ctcDevices[idx].pid = 0;
+        ctcDevices[idx].flgCyclic = false;
+
+        /* init the wait queue for the channel */
+        init_waitqueue_head(&(ctcDevices[idx].ctcRxWait));
+
+        /* init the mutex */
+        mutex_init(&(ctcDevices[idx].ctc_mutex));
+    }
+
+    return 0;
+}
+
+
+/****************************************************************************/
+/** Initializes the mailboxes incl. interrupts here
+ *
+ * The mailbox driver PL320 is used for the communication. This function
+ * registers the notifier.
+ *
+ * @return 0 if successful, otherwise error code
+ */
+static int ctc_init_mbox(
+    void
+)
+{
+    pl320_ipc_register_notifier(&ctc_nb);
+    return 0;
+}
+
+
+/****************************************************************************/
+/** Core to Core notifier
+ *
+ * This notifier is called, after a new mailbox message received.
+ *
+ * @return 0 if successful, otherwise error code
+ */
+static int ctc_notifier(
+    struct notifier_block *pNb,                 /**< notifier block */
+    unsigned long page,                         /**< first element is the start page of the message */
+    void *pData                                 /**< pointer to second element */
+)
+{
+    int minor;                                  /* minor number */
+    __u16 len;                                  /* data length */
+    __u32 offsetRxData;                         /* offset to new rx data */
+    char ctcMsgType;                            /* request or acknowledge */
+
+    /* evaluate the mailbox data on the work queue */
+    ctcGetMboxMsg((__u32 *) pData, &minor, &len, &ctcMsgType);
+
+    if ((CTC_CHANNEL_NUM > minor) && (CTC_PAGE_COUNT > page)) {
+        /* select the message type */
+        if (CTC_MBOX_MSG_REQ != ctcMsgType) {
+            ctc_mBoxRxRes(minor, len);
+            /* no evaluation of the return value - in error case, the message will be lost */
+
+        } else {
+            /* data are on the rx buffer. Calculate the offset to it */
+            /* Offset to the read buffer */
+            offsetRxData = CTC_MEM_OFFSET_RX;
+            /* Offset to the correct channel */
+            offsetRxData += (minor << (CTC_PAGE_SIZE_EXPONENT + CTC_PAGE_COUNT_EXPONENT));
+            /* Offset to the correct page */
+            offsetRxData += (page << CTC_PAGE_SIZE_EXPONENT);
+
+            ctc_mBoxRxNewJob(minor, (pVirtKernMem +  offsetRxData), len);
+            /* no evaluation of the return value - in error case, the message will be lost */
+        }
+    }
+    return 0;
+}
+
+
+/****************************************************************************/
+/** Handle received mailbox response
+ *
+ * This function increases the read index of the writing buffer based on the
+ * length of data. It is called during the mailbox receive interrupt.
+ *
+ * @return 0 if successful, otherwise error code
+ */
+static int ctc_mBoxRxRes(
+    int minor,                                  /**< minor number */
+    __u16 size                                  /**< buffer length */
+)
+{
+    int reqPages;                               /* required pages */
+    int offsetIdx;                              /* offset to write index */
+
+    /* calculate the required pages and the offset */
+    if (size != ctcCalcPages((size_t) size, ctcDevices[minor].rdIdx, &reqPages, &offsetIdx)) {
+        return -EPERM;
+    }
+
+    /* increase the read index and consider the overflow */
+    ctcDevices[minor].rdIdx += (reqPages + offsetIdx);
+    ctcDevices[minor].rdIdx &= (CTC_PAGE_COUNT - 1);
+
+    return 0;
+}
+
+
+/****************************************************************************/
+/** Handle new Job
+ *
+ * This function is called, if a new job was received on the mailbox. The data
+ * are stored to the mailbox fifo and the read process is waked up.
+ *
+ * @return 0 if successful, otherwise error code
+ */
+static int ctc_mBoxRxNewJob(
+    int minor,                                  /**< minor number */
+    void *pBuf,                                 /**< data buffer */
+    __u16 size                                  /**< buffer length */
+)
+{
+    struct ctcDataEntry *pEntry;                /* fifo entry */
+    struct kfifo *pFifo;                        /* dido of the channel */
+    unsigned int ret;                           /* return value */
+
+    /* alloc a new fifo entry */
+    pEntry = kmalloc(sizeof(struct ctcDataEntry), GFP_ATOMIC);
+    if (!pEntry) {
+        /* error during allocation */
+        printk(KERN_NOTICE "CTC: %s - Could not allocate memory for fifo entry.\n", __func__);
+        return -ENOMEM;
+    }
+    /* store the data on the fifo */
+    pEntry->size = size;
+    pEntry->pBuf = pBuf;
+
+    /* Get the according channel fifo */
+    pFifo = (struct kfifo *) &(ctcDevices[minor].rdFifo);
+
+    if (!kfifo_is_full(pFifo)) {
+        /* add entry */
+        ret = kfifo_in(pFifo, &pEntry, 1);
+        if (1 != ret) {
+            printk(KERN_NOTICE "CTC: %s - Could not get data from FIFO.\n", __func__);
+            return -EPERM;
+        }
+
+        /* wake up the read process */
+        wake_up_interruptible(&(ctcDevices[minor].ctcRxWait));
+        return 0;
+
+    } else {
+        /* Error handler */
+        printk(KERN_NOTICE "CTC: %s - Mailbox FIFO is full.\n", __func__);
+    }
+
+    return -EPERM;
+}
+
+
+/****************************************************************************/
+/** Calculate Pages
+ *
+ * This function calculates the required pages and the index offset based on
+ * the data length and the index.
+ * The required pages doesn't include the offset!
+ *
+ * @return data length if successful, otherwise 0
+ */
+static size_t ctcCalcPages(
+    size_t len,                                 /**< data length */
+    int ctcIdx,                                 /**< rndex of mailbox fifo */
+    int *pReqPages,                             /**< required pages */
+    int *pOffsetIdx                             /**< offset to write index */
+)
+{
+    int reqPages;                               /* required pages */
+
+    /* calculate the necessary pages */
+    reqPages = (len + (CTC_PAGE_SIZE - 1)) >> CTC_PAGE_SIZE_EXPONENT;
+
+    /* The data will not be splitted at the end of the cyclic buffer. Instead they'll be written to the first page */
+    /* Check if the new data will fit onto the buffer */
+    if ((1 < reqPages) &&
+            (CTC_PAGE_COUNT < (ctcIdx + reqPages))) {
+        /* calculate offset */
+        *pOffsetIdx = (int) (CTC_PAGE_COUNT - ctcIdx);
+    } else {
+        *pOffsetIdx = 0;
+    }
+
+    /* hand back the calculated required pages */
+    *pReqPages = reqPages;
+
+    return len;
+}
+
+
+/****************************************************************************/
+/** Set mailbox message
+ *
+ * This function prepares the mailbox message by filling all data into the
+ * mailbox data structure.
+ */
+static void ctcSetMboxMsg(
+    __u32 *pCtcMboxData,                        /**< data for mailbox */
+    int minor,                                  /**< minor number */
+    __u32 page,                                 /**< first message page */
+    __u16 len,                                  /**< data length */
+    char ctcMsgType                             /**< request or acknowledge */
+)
+{
+    /* prepare the mailbox message */
+    /* add the information of the first page entry */
+    *(pCtcMboxData) = (CTC_MBOX_DATA1_PGE_MSK & page);
+
+    /* add the minor number as channel ID */
+    *(pCtcMboxData + 1) = (CTC_MBOX_DATA0_CHN_MSK & ((__u32) minor << CTC_MBOX_DATA1_CHN_OFFSET));
+
+    /* add the message type */
+    *(pCtcMboxData + 1) |= (CTC_MBOX_DATA0_DST_MSK & ((__u32) ctcMsgType << CTC_MBOX_DATA1_DST_OFFSET));
+
+    /* add the data length */
+    *(pCtcMboxData + 1) |= (CTC_MBOX_DATA0_SIZE_MSK & len);
+}
+
+
+/****************************************************************************/
+/** Get mailbox message
+ *
+ * This function reads all informations from the mailbox buffer.
+ *
+ * @return data length if successful, otherwise 0
+ */
+static void ctcGetMboxMsg(
+    __u32 *pCtcMboxData,                        /**< data for mailbox */
+    int *pMinor,                                /**< minor number */
+    __u16 *pLen,                                /**< data length */
+    char *pCtcMsgType                           /**< request or acknowledge */
+)
+{
+    /* read the minor number */
+    *pMinor = (CTC_MBOX_DATA0_CHN_MSK & *(pCtcMboxData)) >> CTC_MBOX_DATA1_CHN_OFFSET;
+
+    /* read the message type */
+    *pCtcMsgType = (CTC_MBOX_DATA0_DST_MSK & *(pCtcMboxData)) >> CTC_MBOX_DATA1_DST_OFFSET;
+
+    /* read the data length */
+    *pLen = (__u16) (CTC_MBOX_DATA0_SIZE_MSK & *(pCtcMboxData));
+}
+
+
+/****************************************************************************/
+/** Deinitializes the core to core module
+ *
+ */
+static void ctc_cleanup(
+    void
+)
+{
+    int idx;                                    /* index */
+
+    /* unregister the notifier */
+    pl320_ipc_unregister_notifier(&ctc_nb);
+
+    /* Deinit individual char devs and devices */
+    for (idx = 0; idx < CTC_CHANNEL_NUM; idx++) {
+        cdev_del(&(ctcDevices[idx].chrdev));
+        device_destroy(ctcCharClass, MKDEV(ctcMajor, idx));
+        printk(KERN_NOTICE "CTC: Removed device ctc_chan%u.\n", idx);
+    }
+
+    /* Unregister region */
+    if (0 != ctcDev) {
+        unregister_chrdev_region(ctcDev, CTC_CHANNEL_NUM);
+    }
+
+    /* Destroy class */
+    if (ctcCharClass) {
+        class_destroy(ctcCharClass);
+        printk(KERN_NOTICE "CTC: Removed ctc class.\n");
+    }
+
+    printk(KERN_INFO "CTC: CTC module released.\n");
+}
+
+
+/****************************************************************************/
+/** Opens a core to core char device for reading/ writing
+ *
+ * Open a char device for core to core usage. This is only possible, if the
+ * nonblocking option is disabled.
+ *
+ * @return 0 if successful, otherwise error code
+ */
+static int ctc_open(
+    struct inode *pInode,                       /**< pointer to inode */
+    struct file *pFile                          /**< pointer to file */
+)
+{
+    int minor;                                  /* minor number */
+
+    minor = MINOR(pFile->f_inode->i_rdev);
+
+    /* Check for non blocking option */
+    if (O_NONBLOCK == (O_NONBLOCK & (pFile->f_flags))) {
+        return -EACCES;
+    }
+
+    /* check if the file is already open */
+    if (ctcDevices[minor].pid) {
+        return -EACCES;
+    }
+
+    /* save the pid */
+    ctcDevices[minor].pid = current->pid;
+
+    return 0;
+}
+
+
+/****************************************************************************/
+/** Closes a core to core char device
+ *
+ * This function closes a core to core char device. This is only possible by
+ * the task, which opened it.
+ *
+ * @param pInode, pointer to inode
+ * @param pFile, pointer to file
+ *
+ * @return 0 if successful, otherwise error code
+ */
+static int ctc_release(
+    struct inode *pInode,                       /**< pointer to inode */
+    struct file *pFile                          /**< pointer to file */
+)
+{
+    int minor;                                  /* minor number */
+
+    minor = MINOR(pFile->f_inode->i_rdev);
+
+    /* remove the pid */
+    ctcDevices[minor].pid = 0;
+    return 0;
+}
+
+
+/****************************************************************************/
+/** Reads up to len bytes from a core to core char device
+ *
+ * This function provides a blocking reading of new messages on the mailbox
+ * FIFO.
+ *
+ * @return data length if successful, otherwise error code or 0 if signal
+ * occurs
+ */
+static ssize_t ctc_read(
+    struct file *pFile,                         /**< file handler */
+    char *pBuf,                                 /**< buffer */
+    size_t len,                                 /**< length */
+    loff_t *pOffset                             /**< offset */
+)
+{
+    int minor;                                  /* minor number */
+    int resMbox;                                /* mailbox result */
+    struct kfifo *pFifo;                        /* fifo of the channel */
+    struct ctcDataEntry *pEntry;                /* selected fifo entry */
+    size_t fifoDataLen;                         /* length of the fido entry */
+    ssize_t res = 0;                            /* result */
+    __u32 ctcMboxData[CTC_MBOX_LEN];            /* data for mailbox */
+    struct timespec mboxTimeout;                /* mailbox timeout */
+    struct timespec mboxTime;                   /* elapsed mailbox time */
+
+    minor = MINOR(pFile->f_inode->i_rdev);
+
+    if (CTC_CHANNEL_NUM <= minor) {
+        printk(KERN_INFO "CTC: "CTC_DEVICE_FILE" does not exist.\n", minor);
+        return -EFAULT;
+    }
+
+    /* Get the according channel fifo */
+    pFifo = (struct kfifo *) &(ctcDevices[minor].rdFifo);
+
+    /* set module to sleep until there is an entry on the mailbox fifo */
+    res = wait_event_interruptible(ctcDevices[minor].ctcRxWait, !kfifo_is_empty(pFifo));
+    if (0 == res) {
+        /* get a fifo entry */
+        fifoDataLen = kfifo_out(pFifo, &pEntry, 1);
+
+        /* check if the reading was successfull */
+        if (1 == fifoDataLen) {
+
+            /* check the length */
+            if (len >= pEntry->size) {
+                /* copy the data to user space */
+                if (!copy_to_user(pBuf, pEntry->pBuf, pEntry->size)) {
+                    /* Data has been read successful. Update the result length */
+                    res = pEntry->size;
+                }
+            }
+            /* set the mailbox message */
+            ctcSetMboxMsg(ctcMboxData, minor, 0, pEntry->size, CTC_MBOX_MSG_RES);
+
+            /* get the current time stamp */
+            getnstimeofday(&mboxTimeout);
+            do {
+                /* send the mailbox message */
+                resMbox = pl320_ipc_transmit(ctcMboxData);
+                getnstimeofday(&mboxTime);
+                if (0 == resMbox) {
+                    /* if mailbox sending was successful break */
+                    break;
+                }
+            } while ((CTC_GET_TIME_MS(mboxTimeout) + ctcMboxTimeoutMs) > CTC_GET_TIME_MS(mboxTime));
+
+            /* Free the buffer whether the destination buffer is to small or not. */
+            kfree(pEntry);
+
+            /* print a kernel info in case of an error */
+            if ((CTC_GET_TIME_MS(mboxTimeout) + ctcMboxTimeoutMs) <= CTC_GET_TIME_MS(mboxTime)) {
+                printk(KERN_NOTICE "CTC: %s - Unable to send a response [Err: 0x%x].\n", __func__, resMbox);
+            }
+        }
+    }
+
+    return res;
+}
+
+
+/****************************************************************************/
+/** Writes up to len bytes to a core to core char device
+ *
+ * @return data length if successful, otherwise 0
+ */
+static ssize_t ctc_write(
+    struct file *pFile,                         /**< file handler */
+    const char *pBuf,                           /**< buffer */
+    size_t len,                                 /**< length */
+    loff_t *pOffset                             /**< offset */
+)
+{
+    __u32 ctcMboxData[CTC_MBOX_LEN];            /* data for mailbox */
+    int minor;                                  /* minor number */
+    int ctcPageWrIdx;                           /* write index for one page */
+    int resMbox;                                /* mailbox result */
+    unsigned int remPages;                      /* remaining pages */
+    unsigned int reqPages;                      /* required pages */
+    unsigned int offsetIdx;                     /* offset to first element of cyclic buffer */
+    char *pDst;                                 /* destination on kernel memory */
+    struct timespec mboxTimeout;                /* mailbox timeout */
+    struct timespec mboxTime;                   /* elapsed mailbox time */
+
+    minor = MINOR(pFile->f_inode->i_rdev);
+
+    if (CTC_CHANNEL_NUM <= minor) {
+        printk(KERN_INFO "CTC:"CTC_DEVICE_FILE" does not exist.\n", minor);
+        return 0;
+    }
+
+    if (ctcDevices[minor].flgCyclic) {
+        if (ctcDevices[minor].rdIdx != ctcDevices[minor].wrIdx) {
+            /* sending of more than one message to the destination isn't allowed on cyclic channel */
+            printk(KERN_INFO "CTC: An other message blocks the cyclic channel.\n");
+            return 0;
+        }
+    }
+
+    mutex_lock(&(ctcDevices[minor].ctc_mutex));
+
+    /* get the actual write index - update it at successful writing */
+    /* The index is 0 <= wrIdx < CTC_PAGE_COUNT */
+    ctcPageWrIdx = ctcDevices[minor].wrIdx;
+
+    /* calculate the required pages and offset */
+    if (len != ctcCalcPages(len, ctcPageWrIdx, &reqPages, &offsetIdx)) {
+        /* Error */
+        mutex_unlock(&(ctcDevices[minor].ctc_mutex));
+        printk(KERN_INFO "CTC: %s - Unable to calculate pages.\n", __func__);
+        return 0;
+    }
+
+    /* calculate the remaining pages on the buffer */
+    remPages = (CTC_PAGE_COUNT - 1) - (ctcPageWrIdx) + ctcDevices[minor].rdIdx;
+    remPages &= (CTC_PAGE_COUNT - 1);
+
+    /* check if there are enough free entries on the buffer */
+    if (remPages < (reqPages + offsetIdx)) {
+        /* ERROR */
+        mutex_unlock(&(ctcDevices[minor].ctc_mutex));
+        printk(KERN_INFO "CTC: %s - No space for %u byte data on buffer.\n", __func__, len);
+        return 0;
+    }
+
+    /* add the offset and consider the overflow */
+    ctcPageWrIdx += offsetIdx;
+    ctcPageWrIdx &= (CTC_PAGE_COUNT - 1);
+
+    /* determine the destination page for writing data */
+    pDst = ctcDevices[minor].pWrData + (ctcPageWrIdx << CTC_PAGE_SIZE_EXPONENT);
+
+    /* Copy the data from user space. */
+    if (copy_from_user(pDst, pBuf, len)) {
+        /* ERROR */
+        mutex_unlock(&(ctcDevices[minor].ctc_mutex));
+        printk(KERN_INFO "CTC: %s - Unable to copy user data.\n", __func__);
+        return 0;
+    }
+
+    /* prepare the mailbox message */
+    ctcSetMboxMsg(ctcMboxData, minor, ctcPageWrIdx, (uint16_t) len, CTC_MBOX_MSG_REQ);
+
+    /* get the current time stamp */
+    getnstimeofday(&mboxTimeout);
+    do {
+        /* send the mailbox message */
+        resMbox = pl320_ipc_transmit(ctcMboxData);
+        getnstimeofday(&mboxTime);
+        if (0 == resMbox) {
+            /* update the write index according to the required pages and consider the overflow */
+            ctcDevices[minor].wrIdx = (ctcPageWrIdx + reqPages) & (CTC_PAGE_COUNT - 1);
+            mutex_unlock(&(ctcDevices[minor].ctc_mutex));
+            return len;
+        }
+    } while ((CTC_GET_TIME_MS(mboxTimeout) + ctcMboxTimeoutMs) > CTC_GET_TIME_MS(mboxTime));
+
+    /* unable to send the message */
+    mutex_unlock(&(ctcDevices[minor].ctc_mutex));
+    printk(KERN_INFO "CTC: %s - Unable to send the mailbox message [Err: 0x%x].\n", __func__, resMbox);
+    return 0;
+}
+
+
+/****************************************************************************/
+/** Io control for core to core char device
+ *
+ * @return 0 if successful, otherwise error code
+ */
+long ctc_ioctl(
+    struct file *pFile,                         /**< file handler */
+    unsigned int cmd,                           /**< io control command */
+    unsigned long arg                           /**< pointer to user data as ulong */
+)
+{
+    int res = 0;                                /* result */
+    int minor;                                  /* minor number */
+    struct kfifo *pFifo;                        /* dido of the channel */
+
+    minor = MINOR(pFile->f_inode->i_rdev);
+
+    if (CTC_CHANNEL_NUM <= minor) {
+        printk(KERN_INFO "CTC:"CTC_DEVICE_FILE" does not exist.\n", minor);
+        return 0;
+    }
+
+    switch (cmd) {
+        case CTC_IOCTL_SIZE_FRAGMENT:
+            if (ctcDevices[minor].flgCyclic) {
+                /* double buffer */
+                res = put_user(((CTC_PAGE_COUNT * CTC_PAGE_SIZE) >> 1), (int __user *) arg);
+            }
+            else {
+                res = put_user(((CTC_PAGE_COUNT - 1) << CTC_PAGE_SIZE_EXPONENT), (int __user *) arg);
+            }
+            break;
+
+        case CTC_IOCTL_SET_MBOX_MS:
+            ctcMboxTimeoutMs = *(unsigned int __user *) arg;
+            break;
+
+        case CTC_IOCTL_SETUP_CYCLIC:
+            /* Get the according channel fifo */
+            pFifo = (struct kfifo *) &(ctcDevices[minor].rdFifo);
+            /* configure the channel as cyclic if it is opened and empty */
+            if ((0 != ctcDevices[minor].pid)
+                    && (ctcDevices[minor].wrIdx == ctcDevices[minor].rdIdx)
+                    && (kfifo_is_empty(pFifo))) {
+                ctcDevices[minor].flgCyclic = true;
+                printk(KERN_INFO "CTC:"CTC_DEVICE_FILE" has been configured for cyclic data.\n", minor);
+            }
+            else {
+                printk(KERN_INFO "CTC:"CTC_DEVICE_FILE" could not be configured for cyclic data.\n", minor);
+                res = -EFAULT;
+            }
+            break;
+
+        case CTC_IOCTL_VERSION:
+            res = put_user(CTC_KERNEL_VERSION_MAJOR, (int __user *) arg);
+            break;
+
+        default:
+            res = -EFAULT;
+            break;
+    }
+
+    return res;
+}
+
+
+module_init(ctc_init);
+module_exit(ctc_cleanup);
+
+MODULE_LICENSE("GPLv2");
+MODULE_AUTHOR("GOAL");
+MODULE_DESCRIPTION("Core2Core driver");
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 925081e..b7fa2c4 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -75,6 +75,7 @@ obj-$(CONFIG_COMMON_CLK_PXA)		+= pxa/
 obj-$(CONFIG_COMMON_CLK_QCOM)		+= qcom/
 obj-$(CONFIG_ARCH_RENESAS)		+= renesas/
 obj-$(CONFIG_ARCH_ROCKCHIP)		+= rockchip/
+obj-$(CONFIG_ARCH_RZN1)			+= rzn1/
 obj-$(CONFIG_COMMON_CLK_SAMSUNG)	+= samsung/
 obj-$(CONFIG_ARCH_SIRF)			+= sirf/
 obj-$(CONFIG_ARCH_SOCFPGA)		+= socfpga/
diff --git a/drivers/clk/rzn1/Makefile b/drivers/clk/rzn1/Makefile
new file mode 100644
index 0000000..b17dc68
--- /dev/null
+++ b/drivers/clk/rzn1/Makefile
@@ -0,0 +1,7 @@
+obj-y += rzn1-clock.o
+obj-y += rzn1-clock-divider.o
+obj-y += rzn1-clock-gate.o
+obj-y += rzn1-clock-selector.o
+obj-y += rzn1-clock-bitselect.o
+obj-y += rzn1-clock-group.o
+
diff --git a/drivers/clk/rzn1/rzn1-clkctrl-tables.h b/drivers/clk/rzn1/rzn1-clkctrl-tables.h
new file mode 100644
index 0000000..f0382f1
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clkctrl-tables.h
@@ -0,0 +1,297 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_CLKCTRL_TABLES_H__
+#define __RZN1_CLKCTRL_TABLES_H__
+
+#define RZN1_CLK_COUNT		129
+
+static const struct rzn1_clkdesc rzn1_clock_list[RZN1_CLK_COUNT] = {
+	[RZN1_HCLK_SDIO0_ID] =
+		_CLK("hclk_sdio0",	_BIT(3, 0), _BIT(3, 1), _BIT(3, 2), _BIT(3, 3), _BIT(4, 0), _BIT(4, 1), _BIT(4, 2)),
+	[RZN1_CLK_SDIO0_ID] =
+		_CLK("clk_sdio0",	_BIT(3, 4), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_USBH_ID] =
+		_CLK("hclk_usbh",	_BIT(7, 0), _BIT(7, 1), {}, _BIT(7, 2), {}, _BIT(8, 0), _BIT(8, 1)),
+	[RZN1_HCLK_USBF_ID] =
+		_CLK("hclk_usbf",	_BIT(7, 3), {}, {}, _BIT(7, 4), {}, _BIT(8, 2), _BIT(8, 3)),
+	[RZN1_HCLK_USBPM_ID] =
+		_CLK("hclk_usbpm",	_BIT(7, 5), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_PCI_USB_ID] =
+		_CLK("clk_pci_usb",	_BIT(7, 6), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_CRYPTO_EIP93_ID] =
+		_CLK("hclk_crypto_eip93",	_BIT(9, 0), _BIT(9, 1), {}, _BIT(9, 2), {}, _BIT(10, 0), _BIT(10, 1)),
+	[RZN1_HCLK_CRYPTO_EIP150_ID] =
+		_CLK("hclk_crypto_eip150",	_BIT(9, 3), _BIT(9, 4), _BIT(9, 5), {}, _BIT(10, 2), {}, {}),
+	[RZN1_HCLK_MSEBI_S_ID] =
+		_CLK("hclk_msebi_s",	_BIT(11, 0), _BIT(11, 1), _BIT(11, 2), _BIT(11, 3), _BIT(12, 0), _BIT(12, 1), _BIT(12, 2)),
+	[RZN1_HCLK_MSEBI_M_ID] =
+		_CLK("hclk_msebi_m",	_BIT(11, 4), _BIT(11, 5), _BIT(11, 6), {}, _BIT(12, 3), {}, {}),
+	[RZN1_HCLK_UART0_ID] =
+		_CLK("hclk_uart0",	_BIT(13, 0), _BIT(13, 1), _BIT(13, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_UART1_ID] =
+		_CLK("hclk_uart1",	_BIT(13, 3), _BIT(13, 4), _BIT(13, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_UART2_ID] =
+		_CLK("hclk_uart2",	_BIT(13, 6), _BIT(13, 7), _BIT(13, 8), {}, {}, {}, {}),
+	[RZN1_HCLK_I2C0_ID] =
+		_CLK("hclk_i2c0",	_BIT(13, 9), _BIT(13, 10), _BIT(13, 11), {}, {}, {}, {}),
+	[RZN1_HCLK_I2C1_ID] =
+		_CLK("hclk_i2c1",	_BIT(13, 12), _BIT(13, 13), _BIT(13, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_ADC_ID] =
+		_CLK("hclk_adc",	_BIT(13, 15), _BIT(13, 16), _BIT(13, 17), {}, {}, {}, {}),
+	[RZN1_CLK_UART0_ID] =
+		_CLK("clk_uart0",	_BIT(13, 18), _BIT(13, 19), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART0_ID] =
+		_CLK("clk_usbuart0",	_BIT(13, 20), _BIT(13, 21), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART1_ID] =
+		_CLK("clk_uart1",	_BIT(13, 22), _BIT(13, 23), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART1_ID] =
+		_CLK("clk_usbuart1",	_BIT(13, 24), _BIT(13, 25), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART2_ID] =
+		_CLK("clk_uart2",	_BIT(13, 26), _BIT(13, 27), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART2_ID] =
+		_CLK("clk_usbuart2",	_BIT(13, 28), _BIT(13, 29), {}, {}, {}, {}, {}),
+	[RZN1_CLK_I2C0_ID] =
+		_CLK("clk_i2c0",	_BIT(15, 6), _BIT(15, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_I2C1_ID] =
+		_CLK("clk_i2c1",	_BIT(15, 8), _BIT(15, 9), {}, {}, {}, {}, {}),
+	[RZN1_CLK_ADC_ID] =
+		_CLK("clk_adc",		_BIT(15, 10), _BIT(15, 11), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_SGPIO0_ID] =
+		_CLK("hclk_sgpio0",	_BIT(15, 0), _BIT(15, 1), _BIT(15, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_SGPIO1_ID] =
+		_CLK("hclk_sgpio1",	_BIT(15, 3), _BIT(15, 4), _BIT(15, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_PWMPTO_ID] =
+		_CLK("hclk_pwmpto",	_BIT(15, 12), _BIT(15, 13), _BIT(15, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_DELTASIGMA_ID] =
+		_CLK("hclk_deltasigma",	_BIT(15, 15), _BIT(15, 16), _BIT(15, 17), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI0_ID] =
+		_CLK("hclk_spi0",	_BIT(16, 0), _BIT(16, 1), _BIT(16, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI1_ID] =
+		_CLK("hclk_spi1",	_BIT(16, 3), _BIT(16, 4), _BIT(16, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI2_ID] =
+		_CLK("hclk_spi2",	_BIT(16, 6), _BIT(16, 7), _BIT(16, 8), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI3_ID] =
+		_CLK("hclk_spi3",	_BIT(16, 9), _BIT(16, 10), _BIT(16, 11), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI4_ID] =
+		_CLK("hclk_spi4",	_BIT(16, 12), _BIT(16, 13), _BIT(16, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_SPI5_ID] =
+		_CLK("hclk_spi5",	_BIT(16, 15), _BIT(16, 16), _BIT(16, 17), {}, {}, {}, {}),
+	[RZN1_HCLK_GPIO0_ID] =
+		_CLK("hclk_gpio0",	_BIT(16, 18), _BIT(16, 19), _BIT(16, 20), {}, {}, {}, {}),
+	[RZN1_HCLK_GPIO1_ID] =
+		_CLK("hclk_gpio1",	_BIT(16, 21), _BIT(16, 22), _BIT(16, 23), {}, {}, {}, {}),
+	[RZN1_HCLK_UART3_ID] =
+		_CLK("hclk_uart3",	_BIT(16, 24), _BIT(16, 25), _BIT(16, 26), {}, {}, {}, {}),
+	[RZN1_HCLK_UART4_ID] =
+		_CLK("hclk_uart4",	_BIT(16, 27), _BIT(16, 28), _BIT(16, 29), {}, {}, {}, {}),
+	[RZN1_HCLK_UART5_ID] =
+		_CLK("hclk_uart5",	_BIT(17, 0), _BIT(17, 1), _BIT(17, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_UART6_ID] =
+		_CLK("hclk_uart6",	_BIT(17, 3), _BIT(17, 4), _BIT(17, 5), {}, {}, {}, {}),
+	[RZN1_HCLK_UART7_ID] =
+		_CLK("hclk_uart7",	_BIT(17, 6), _BIT(17, 7), _BIT(17, 8), {}, {}, {}, {}),
+	[RZN1_HCLK_GPIO2_ID] =
+		_CLK("hclk_gpio2",	_BIT(17, 9), _BIT(17, 10), _BIT(17, 11), {}, {}, {}, {}),
+	[RZN1_HCLK_PG19_ID] =
+		_CLK("hclk_pg19",	_BIT(17, 12), _BIT(17, 13), _BIT(17, 14), {}, {}, {}, {}),
+	[RZN1_HCLK_PG20_ID] =
+		_CLK("hclk_pg20",	_BIT(17, 15), _BIT(17, 16), _BIT(17, 17), {}, {}, {}, {}),
+	[RZN1_HCLK_DMA0_ID] =
+		_CLK("hclk_dma0",	_BIT(19, 0), _BIT(19, 1), _BIT(19, 2), _BIT(19, 3), _BIT(22, 0), _BIT(22, 1), _BIT(22, 2)),
+	[RZN1_HCLK_DMA1_ID] =
+		_CLK("hclk_dma1",	_BIT(19, 4), _BIT(19, 5), _BIT(19, 6), _BIT(19, 7), _BIT(22, 3), _BIT(22, 4), _BIT(22, 5)),
+	[RZN1_HCLK_NAND_ID] =
+		_CLK("hclk_nand",	_BIT(20, 0), _BIT(20, 1), _BIT(20, 2), _BIT(20, 3), _BIT(23, 0), _BIT(23, 1), _BIT(23, 2)),
+	[RZN1_CLK_NAND_ID] =
+		_CLK("clk_nand",	_BIT(20, 4), _BIT(20, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_QSPI0_ID] =
+		_CLK("hclk_qspi0",	_BIT(21, 0), _BIT(21, 1), _BIT(21, 2), _BIT(21, 3), _BIT(24, 0), _BIT(24, 1), _BIT(24, 2)),
+	[RZN1_CLK_QSPI0_ID] =
+		_CLK("clk_qspi0",	_BIT(21, 4), _BIT(21, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_DDRC_ID] =
+		_CLK("hclk_ddrc",	_BIT(25, 0), _BIT(25, 2), {}, _BIT(25, 1), {}, _BIT(29, 0), _BIT(29, 1)),
+	[RZN1_CLK_DDRC_ID] =
+		_CLK("clk_ddrc",	_BIT(25, 3), _BIT(25, 4), {}, {}, {}, {}, {}),
+	[RZN1_CLK_RGMII_REF_ID] =
+		_CLK("clk_rgmii_ref",	_BIT(26, 0), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_RMII_REF_ID] =
+		_CLK("clk_rmii_ref",	_BIT(26, 1), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_MII_REF_ID] =
+		_CLK("clk_mii_ref",	_BIT(26, 2), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_GMAC0_ID] =
+		_CLK("hclk_gmac0",	_BIT(27, 0), _BIT(27, 1), _BIT(27, 2), _BIT(27, 3), _BIT(30, 0), _BIT(30, 1), _BIT(30, 2)),
+	[RZN1_HCLK_GMAC1_ID] =
+		_CLK("hclk_gmac1",	_BIT(28, 0), _BIT(28, 1), _BIT(28, 2), _BIT(28, 3), _BIT(31, 0), _BIT(31, 1), _BIT(31, 2)),
+	[RZN1_HCLK_ECAT125_ID] =
+		_CLK("hclk_ecat125",	_BIT(32, 0), _BIT(32, 1), {}, _BIT(32, 2), {}, _BIT(34, 0), _BIT(34, 1)),
+	[RZN1_CLK_ECAT25_ID] =
+		_CLK("clk_ecat25",	_BIT(32, 3), _BIT(32, 4), {}, {}, {}, {}, {}),
+	[RZN1_CLK_ECAT100_ID] =
+		_CLK("clk_ecat100",	_BIT(32, 5), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_SERCOS_ID] =
+		_CLK("hclk_sercos",	_BIT(33, 0), _BIT(33, 2), {}, _BIT(33, 1), {}, _BIT(35, 0), _BIT(35, 1)),
+	[RZN1_CLK_SERCOS50_ID] =
+		_CLK("clk_sercos50",	_BIT(33, 4), _BIT(33, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SERCOS100_ID] =
+		_CLK("clk_sercos100",	_BIT(33, 5), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_QSPI1_ID] =
+		_CLK("hclk_qspi1",	_BIT(36, 0), _BIT(36, 1), _BIT(36, 2), _BIT(36, 3), _BIT(38, 0), _BIT(38, 1), _BIT(38, 2)),
+	[RZN1_CLK_QSPI1_ID] =
+		_CLK("clk_qspi1",	_BIT(36, 4), _BIT(36, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_HSR_ID] =
+		_CLK("hclk_hsr",	_BIT(36, 0), _BIT(36, 2), {}, _BIT(36, 1), {}, _BIT(38, 0), _BIT(38, 1)),
+	[RZN1_CLK_HSR_DUP_ID] =
+		_CLK("clk_hsr_dup",	_BIT(36, 3), {}, {}, {}, {}, {}, {}),
+	[RZN1_CLK_HSR50_ID] =
+		_CLK("clk_hsr50",	_BIT(36, 4), _BIT(36, 5), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_SDIO1_ID] =
+		_CLK("hclk_sdio1",	_BIT(50, 0), _BIT(50, 1), _BIT(50, 2), _BIT(50, 3), _BIT(51, 0), _BIT(51, 1), _BIT(51, 2)),
+	[RZN1_CLK_SDIO1_ID] =
+		_CLK("clk_sdio1",	_BIT(50, 4), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_PINCONFIG_ID] =
+		_CLK("hclk_pinconfig",	_BIT(58, 0), _BIT(58, 1), _BIT(58, 2), {}, _BIT(87, 0), {}, {}),
+	[RZN1_HCLK_TIMER0_ID] =
+		_CLK("hclk_timer0",	_BIT(58, 3), _BIT(58, 4), _BIT(58, 5), {}, _BIT(87, 1), {}, {}),
+	[RZN1_HCLK_TIMER1_ID] =
+		_CLK("hclk_timer1",	_BIT(58, 6), _BIT(58, 7), _BIT(58, 8), {}, _BIT(87, 2), {}, {}),
+	[RZN1_CLK_25MHZ_PG4_ID] =
+		_CLK("clk_25mhz_pg4",	_BIT(58, 9), _BIT(58, 10), _BIT(58, 11), {}, _BIT(87, 3), {}, {}),
+	[RZN1_CLK_25MHZ_PG5_ID] =
+		_CLK("clk_25mhz_pg5",	_BIT(58, 12), _BIT(58, 13), _BIT(58, 14), {}, _BIT(87, 4), {}, {}),
+	[RZN1_CLK_25MHZ_PG6_ID] =
+		_CLK("clk_25mhz_pg6",	_BIT(58, 15), _BIT(58, 16), _BIT(58, 17), {}, _BIT(87, 5), {}, {}),
+	[RZN1_CLK_25MHZ_PG7_ID] =
+		_CLK("clk_25mhz_pg7",	_BIT(58, 18), _BIT(58, 19), _BIT(58, 20), {}, _BIT(87, 6), {}, {}),
+	[RZN1_CLK_25MHZ_PG8_ID] =
+		_CLK("clk_25mhz_pg8",	_BIT(58, 21), _BIT(58, 22), _BIT(58, 23), {}, _BIT(87, 7), {}, {}),
+	[RZN1_CLK_UART3_ID] =
+		_CLK("clk_uart3",	_BIT(59, 0), _BIT(59, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART3_ID] =
+		_CLK("clk_usbuart3",	_BIT(59, 2), _BIT(59, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART4_ID] =
+		_CLK("clk_uart4",	_BIT(59, 4), _BIT(59, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART4_ID] =
+		_CLK("clk_usbuart4",	_BIT(59, 6), _BIT(59, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART5_ID] =
+		_CLK("clk_uart5",	_BIT(59, 8), _BIT(59, 9), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART5_ID] =
+		_CLK("clk_usbuart5",	_BIT(59, 10), _BIT(59, 11), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART6_ID] =
+		_CLK("clk_uart6",	_BIT(59, 12), _BIT(59, 13), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART6_ID] =
+		_CLK("clk_usbuart6",	_BIT(59, 14), _BIT(59, 15), {}, {}, {}, {}, {}),
+	[RZN1_CLK_UART7_ID] =
+		_CLK("clk_uart7",	_BIT(59, 16), _BIT(59, 17), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBUART7_ID] =
+		_CLK("clk_usbuart7",	_BIT(59, 18), _BIT(59, 19), {}, {}, {}, {}, {}),
+	[RZN1_CLK_NOUSBP2_PG6_ID] =
+		_CLK("clk_nousbp2_pg6",	_BIT(59, 20), _BIT(59, 21), {}, {}, {}, {}, {}),
+	[RZN1_CLK_USBP2_PG6_ID] =
+		_CLK("clk_usbp2_pg6",	_BIT(59, 22), _BIT(59, 23), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_CAN1_ID] =
+		_CLK("hclk_can1",	_BIT(60, 6), _BIT(60, 7), _BIT(60, 8), {}, _BIT(88, 2), {}, {}),
+	[RZN1_CLK_48MHZ_PG4_ID] =
+		_CLK("clk_48mhz_pg4",	_BIT(60, 9), _BIT(60, 10), _BIT(60, 11), {}, _BIT(88, 3), {}, {}),
+	[RZN1_CLK_48MHZ_PG_F_ID] =
+		_CLK("clk_48mhz_pg_f",	_BIT(60, 12), _BIT(60, 13), {}, _BIT(60, 14), {}, _BIT(88, 4), _BIT(88, 5)),
+	[RZN1_HCLK_RSV_ID] =
+		_CLK("hclk_rsv",	_BIT(60, 0), _BIT(60, 1), _BIT(60, 2), {}, _BIT(88, 0), {}, {}),
+	[RZN1_HCLK_CAN0_ID] =
+		_CLK("hclk_can0",	_BIT(60, 3), _BIT(60, 4), _BIT(60, 5), {}, _BIT(88, 1), {}, {}),
+	[RZN1_HCLK_LCD_ID] =
+		_CLK("hclk_lcd",	_BIT(61, 0), _BIT(61, 1), _BIT(61, 2), {}, _BIT(89, 0), {}, {}),
+	[RZN1_HCLK_SEMAP_ID] =
+		_CLK("hclk_semap",	_BIT(61, 3), _BIT(61, 4), _BIT(61, 5), {}, _BIT(89, 1), {}, {}),
+	[RZN1_HCLK_PG3_ID] =
+		_CLK("hclk_pg3",	_BIT(61, 6), _BIT(61, 7), _BIT(61, 8), {}, _BIT(89, 2), {}, {}),
+	[RZN1_HCLK_PG4_ID] =
+		_CLK("hclk_pg4",	_BIT(61, 9), _BIT(61, 10), _BIT(61, 11), {}, _BIT(89, 3), {}, {}),
+	[RZN1_HCLK_PG_I_ID] =
+		_CLK("hclk_pg_i",	_BIT(61, 12), _BIT(61, 13), {}, _BIT(61, 14), {}, _BIT(89, 4), _BIT(89, 5)),
+	[RZN1_CLK_SPI0_ID] =
+		_CLK("clk_spi0",	_BIT(63, 0), _BIT(63, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI1_ID] =
+		_CLK("clk_spi1",	_BIT(63, 2), _BIT(63, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI2_ID] =
+		_CLK("clk_spi2",	_BIT(63, 4), _BIT(63, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI3_ID] =
+		_CLK("clk_spi3",	_BIT(63, 6), _BIT(63, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI4_ID] =
+		_CLK("clk_spi4",	_BIT(65, 0), _BIT(65, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SPI5_ID] =
+		_CLK("clk_spi5",	_BIT(65, 2), _BIT(65, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P4_PG3_ID] =
+		_CLK("clk_p4_pg3",	_BIT(65, 4), _BIT(65, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P4_PG4_ID] =
+		_CLK("clk_p4_pg4",	_BIT(65, 6), _BIT(65, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_SLCD_ID] =
+		_CLK("clk_slcd",	_BIT(67, 0), _BIT(67, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P1_PG2_ID] =
+		_CLK("clk_p1_pg2",	_BIT(67, 2), _BIT(67, 3), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P1_PG3_ID] =
+		_CLK("clk_p1_pg3",	_BIT(67, 4), _BIT(67, 5), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P1_PG4_ID] =
+		_CLK("clk_p1_pg4",	_BIT(67, 6), _BIT(67, 7), {}, {}, {}, {}, {}),
+	[RZN1_CLK_P6_PG1_ID] =
+		_CLK("clk_p6_pg1",	_BIT(69, 0), _BIT(69, 1), _BIT(69, 2), {}, _BIT(91, 0), {}, {}),
+	[RZN1_CLK_P6_PG2_ID] =
+		_CLK("clk_p6_pg2",	_BIT(69, 3), _BIT(69, 4), _BIT(69, 5), {}, _BIT(91, 1), {}, {}),
+	[RZN1_CLK_P6_PG3_ID] =
+		_CLK("clk_p6_pg3",	_BIT(69, 6), _BIT(69, 7), _BIT(69, 8), {}, _BIT(91, 2), {}, {}),
+	[RZN1_CLK_P6_PG4_ID] =
+		_CLK("clk_p6_pg4",	_BIT(69, 9), _BIT(69, 10), _BIT(69, 11), {}, _BIT(91, 3), {}, {}),
+	[RZN1_HCLK_SGPIO2_ID] =
+		_CLK("hclk_sgpio2",	_BIT(70, 3), _BIT(70, 4), _BIT(70, 5), {}, _BIT(90, 1), {}, {}),
+	[RZN1_HCLK_SGPIO3_ID] =
+		_CLK("hclk_sgpio3",	_BIT(70, 6), _BIT(70, 7), _BIT(70, 8), {}, _BIT(90, 2), {}, {}),
+	[RZN1_HCLK_SGPIO4_ID] =
+		_CLK("hclk_sgpio4",	_BIT(70, 9), _BIT(70, 10), _BIT(70, 11), {}, _BIT(90, 3), {}, {}),
+	[RZN1_HCLK_SWITCH_ID] =
+		_CLK("hclk_switch",	_BIT(76, 0), {}, _BIT(76, 1), {}, {}, {}, {}),
+	[RZN1_CLK_SWITCH_ID] =
+		_CLK("clk_switch",	_BIT(76, 2), _BIT(76, 3), {}, {}, {}, {}, {}),
+	[RZN1_HCLK_RTC_ID] =
+		_CLK("hclk_rtc",	_BIT(80, 0), {}, {}, {}, {}, {}, {}),
+	[RZN1_HCLK_ROM_ID] =
+		_CLK("hclk_rom",	_BIT(85, 0), _BIT(85, 1), _BIT(85, 2), {}, _BIT(92, 0), {}, {}),
+	[RZN1_CLK_CM3_ID] =
+		_CLK("clk_cm3",		_BIT(93, 0), _BIT(93, 1), {}, _BIT(93, 2), {}, _BIT(94, 0), _BIT(94, 1)),
+	[RZN1_HCLK_CM3_ID] =
+		_CLK("hclk_cm3",	_BIT(97, 0), _BIT(97, 1), _BIT(97, 2), {}, {}, {}, {}),
+	[RZN1_HCLK_SWITCH_RG_ID] =
+		_CLK("hclk_switch_rg",	_BIT(98, 0), _BIT(98, 1), _BIT(98, 2), {}, {}, {}, {}),
+	[RZN1_CLK_HW_RTOS_ID] =
+		_CLK("clk_hw_rtos",	_BIT(99, 0), _BIT(99, 1), {}, {}, {}, {}, {}),
+	[RZN1_CLK_RTOS_MDC_ID] =
+		_CLK("clk_rtos_mdc",	_BIT(99, 2), {}, {}, {}, {}, {}, {}),
+};
+
+
+#endif /* __RZN1_CLKCTRL_TABLES_H__ */
diff --git a/drivers/clk/rzn1/rzn1-clock-bitselect.c b/drivers/clk/rzn1/rzn1-clock-bitselect.c
new file mode 100644
index 0000000..60778d5
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-bitselect.c
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Clock selector driven from a register bit
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/of.h>
+
+#include "rzn1-clock.h"
+
+/*
+ * This clock provider handles the case of the RZN1 where you have peripherals
+ * that have two potential clock source and two gates, one for each of the
+ * clock source - the used clock source (for all sub clocks) is selected by a
+ * single bit.
+ * That single bit affects all sub-clocks, and therefore needs to change the
+ * active gate (and turn the others off) and force a recalculation of the rates.
+ *
+ * Therefore this file implements two clock providers, one 'bitselect' that
+ * handles the switch between both parents, and another 'dualgate'
+ * that knows which gate to poke at, depending on the parent's bit position.
+ */
+
+struct rzn1_bitselect {
+	struct clk_hw	hw;
+	u32 __iomem *reg;
+	u8 bit;			/* bit for the selector */
+	u8 gate[2][8];		/* bit index for each gate, indexed by 'bit' */
+};
+
+#define to_clk_bitselect(_hw) container_of(_hw, struct rzn1_bitselect, hw)
+
+static u8 rzn1_bitselect_get_value(struct rzn1_bitselect *set)
+{
+	return clk_readl(set->reg) & (1 << set->bit) ? 1 : 0;
+}
+
+static u8 clk_mux_get_parent(struct clk_hw *hw)
+{
+	struct rzn1_bitselect *set = to_clk_bitselect(hw);
+
+	return rzn1_bitselect_get_value(set);
+}
+
+static int clk_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct rzn1_bitselect *set = to_clk_bitselect(hw);
+
+	/* a single bit in the register selects one of two parent clocks */
+	if (index)
+		clk_writel(clk_readl(set->reg) | (1 << set->bit), set->reg);
+	else
+		clk_writel(clk_readl(set->reg) & ~(1 << set->bit), set->reg);
+
+	return 0;
+}
+
+static const struct clk_ops clk_bitselect_ops = {
+	.get_parent = clk_mux_get_parent,
+	.set_parent = clk_mux_set_parent,
+};
+
+/*
+ * This parses the renesas,rzn1-gate property, which consists of a list of
+ * 'gate' numbers for when the selector bit is 'off' (0) followed by a list of
+ * gate numbers for when the selector is 'on' (1).
+ *
+ * renesas,rzn1-gates =
+ *      <RZN1_CLK_SCLK_UART0 RZN1_CLK_SCLK_UART1
+ *	RZN1_CLK_SCLK_UART2>,
+ *      <RZN1_CLK_USB_SCLK_UART0 RZN1_CLK_USB_SCLK_UART1
+ *	RZN1_CLK_USB_SCLK_UART2>;
+ */
+static int __init rzn1_read_bitselect_table(
+	struct rzn1_bitselect *sel,
+	struct device_node *node)
+{
+	u32 table_size;
+	const __be32 *tablespec;
+	int i;
+
+	tablespec = of_get_property(node, "renesas,rzn1-gates", &table_size);
+	if (!tablespec)
+		return -EINVAL;
+	table_size /= sizeof(u32);
+	if (table_size & 1) {
+		pr_err("%s: %s renesas,rzn1-gates needs an even # of gates\n",
+				__func__, node->name);
+		return -EINVAL;
+	}
+	table_size /= 2;
+	if (table_size > sizeof(sel->gate[0])) {
+		pr_err("%s: %s renesas,rzn1-gates overflow\n",
+				__func__, node->name);
+		return -EINVAL;
+	}
+	pr_devel("%s count = %d\n", __func__, table_size);
+	for (i = 0; i < table_size && i < sizeof(sel->gate[0]); i++) {
+		u32 g1, g2;
+
+		of_property_read_u32_index(node, "renesas,rzn1-gates",
+			i, &g1);
+		of_property_read_u32_index(node, "renesas,rzn1-gates",
+			table_size + i, &g2);
+		pr_devel("  [%d] = %s, %s\n", i,
+			rzn1_get_clk_desc(g1)->name,
+			rzn1_get_clk_desc(g2)->name);
+		sel->gate[0][i] = g1;
+		sel->gate[1][i] = g2;
+	}
+	return 0;
+}
+
+static void __init rzn1_clock_bitselect_init(struct device_node *node)
+{
+	struct rzn1_bitselect *sel;
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *parent_name[2];
+	u32 reg_idx;
+	u32 bit_idx;
+	struct clk_init_data init;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name[0] = of_clk_get_parent_name(node, 0);
+	parent_name[1] = of_clk_get_parent_name(node, 1);
+
+	if (!parent_name[0] || !parent_name[1]) {
+		pr_err("%s: invalid parent clocks for %s\n",
+				__func__, node->name);
+		return;
+	}
+	if (of_property_read_u32(node, "reg", &reg_idx)) {
+		pr_err("%s: missing reg property for %s\n",
+				__func__, node->name);
+		return;
+	}
+	if (of_property_read_u32(node, "renesas,rzn1-sel-bit", &bit_idx)) {
+		pr_err("%s: missing renesas,rzn1-sel-bit property for %s\n",
+				__func__, node->name);
+		return;
+	}
+
+	/* allocate the gate */
+	sel = kzalloc(sizeof(struct rzn1_bitselect), GFP_KERNEL);
+	if (!sel) {
+		pr_err("%s: could not allocate bitselect clk\n", __func__);
+		return;
+	}
+
+	init.name = clk_name;
+	init.ops = &clk_bitselect_ops;
+	init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name;
+	init.num_parents = 2;
+
+	if (rzn1_read_bitselect_table(sel, node)) {
+		pr_err("%s: could not read renesas,rzn1-gates property\n",
+			__func__);
+		kfree(sel);
+		return;
+	}
+	/* struct clk_gate assignments */
+	sel->reg = (u32 *)(((u8 *)rzn1_sysctrl_base()) + reg_idx);
+	sel->bit = bit_idx;
+	sel->hw.init = &init;
+
+	clk = clk_register(NULL, &sel->hw);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+
+CLK_OF_DECLARE(rzn1_bitselect_clk,
+		"renesas,rzn1-clock-bitselect", rzn1_clock_bitselect_init);
+
+struct rzn1_dualgate {
+	struct clk_hw	hw;
+	u8 gate;
+};
+#define to_clk_dualgate(_hw) container_of(_hw, struct rzn1_dualgate, hw)
+
+
+static int clk_dualgate_setenable(struct rzn1_dualgate *gate, int enable)
+{
+	struct clk *parent = clk_get_parent(gate->hw.clk);
+	struct rzn1_bitselect *sel = to_clk_bitselect(__clk_get_hw(parent));
+	uint8_t sel_bit = rzn1_bitselect_get_value(sel);
+
+	/* we always turn off the 'other' gate, regardless */
+	rzn1_clk_set_gate(sel->gate[!sel_bit][gate->gate], 0);
+	rzn1_clk_set_gate(sel->gate[sel_bit][gate->gate], enable);
+
+	return 0;
+}
+
+static int clk_gate_enable(struct clk_hw *hw)
+{
+	struct rzn1_dualgate *gate = to_clk_dualgate(hw);
+
+	clk_dualgate_setenable(gate, 1);
+
+	return 0;
+}
+
+static void clk_gate_disable(struct clk_hw *hw)
+{
+	struct rzn1_dualgate *gate = to_clk_dualgate(hw);
+
+	clk_dualgate_setenable(gate, 0);
+}
+
+static int clk_gate_is_enabled(struct clk_hw *hw)
+{
+	struct rzn1_dualgate *gate = to_clk_dualgate(hw);
+	struct clk *parent = clk_get_parent(gate->hw.clk);
+	struct rzn1_bitselect *sel = to_clk_bitselect(__clk_get_hw(parent));
+	uint8_t sel_bit = rzn1_bitselect_get_value(sel);
+
+	return rzn1_clk_is_gate_enabled(sel->gate[sel_bit][gate->gate]);
+}
+
+static const struct clk_ops clk_dualgate_ops = {
+	.enable = clk_gate_enable,
+	.disable = clk_gate_disable,
+	.is_enabled = clk_gate_is_enabled,
+};
+
+static void __init rzn1_clock_dualgate_init(struct device_node *node)
+{
+	struct rzn1_dualgate *gate;
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	u32 gate_idx;
+	struct clk_init_data init;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	if (of_property_read_u32(node, "reg", &gate_idx)) {
+		pr_err("%s: missing gate index property for %s\n",
+				__func__, node->name);
+		return;
+	}
+
+	/* allocate the gate */
+	gate = kzalloc(sizeof(struct rzn1_dualgate), GFP_KERNEL);
+	if (!gate) {
+		pr_err("%s: could not allocate dualgate clk\n", __func__);
+		return;
+	}
+
+	init.name = clk_name;
+	init.ops = &clk_dualgate_ops;
+	init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	/* struct clk_gate assignments */
+	gate->gate = gate_idx;
+	gate->hw.init = &init;
+
+	clk = clk_register(NULL, &gate->hw);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+
+CLK_OF_DECLARE(rzn1_dualgate_clk,
+		"renesas,rzn1-clock-dualgate", rzn1_clock_dualgate_init);
+
diff --git a/drivers/clk/rzn1/rzn1-clock-divider.c b/drivers/clk/rzn1/rzn1-clock-divider.c
new file mode 100644
index 0000000..9b262b6
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-divider.c
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+
+#include "rzn1-clock.h"
+
+static uint32_t ioreg[32];
+static int ioregcnt;
+
+struct rzn1_divider {
+	struct clk_hw	hw;
+	u32 __iomem *reg;
+	u16 mask;
+	u16 flags, min, max;
+	uint8_t table_size;
+	u16 table[8];	/* we know there are no more than 8 */
+};
+
+#define to_rzn1_divider(_hw) container_of(_hw, struct rzn1_divider, hw)
+
+
+static unsigned long rzn1_divider_recalc_rate(
+	struct clk_hw *hw,
+	unsigned long parent_rate)
+{
+	struct rzn1_divider *clk = to_rzn1_divider(hw);
+	long div = readl(clk->reg) & clk->mask;
+
+	pr_devel("%s %ld/%ld (mask %x)\n", __func__,
+		parent_rate, div, clk->mask);
+	if (div < clk->min)
+		div = clk->min;
+	else if (div > clk->max)
+		div = clk->max;
+	return DIV_ROUND_UP(parent_rate, div);
+}
+
+/* Attempts to find a value that is in range of min,max,
+ * and if a table of set dividers was specified for this
+ * register, try to find the fixed divider that is the closest
+ * to the target frequency */
+static long rzn1_divider_clamp_div(
+	struct rzn1_divider *clk,
+	unsigned long rate, unsigned long prate)
+{
+	long div = DIV_ROUND_UP(prate, rate);
+	int i;
+
+	if (div <= clk->min)
+		return clk->min;
+	if (div >= clk->max)
+		return clk->max;
+
+	for (i = 0; clk->table_size && i < clk->table_size - 1; i++) {
+		if (div >= clk->table[i] && div <= clk->table[i+1]) {
+			unsigned long m = rate -
+				DIV_ROUND_UP(prate, clk->table[i]);
+			unsigned long p =
+				DIV_ROUND_UP(prate, clk->table[i + 1]) -
+				rate;
+			/* select the divider that generates
+			 * the value closest to the ideal frequency */
+			div = p >= m ? clk->table[i] : clk->table[i + 1];
+			return div;
+		}
+	}
+	return div;
+}
+
+static long rzn1_divider_round_rate(
+	struct clk_hw *hw, unsigned long rate,
+	unsigned long *prate)
+{
+	struct rzn1_divider *clk = to_rzn1_divider(hw);
+	long div = DIV_ROUND_UP(*prate, rate);
+
+	pr_devel("%s %s %ld (prate %ld) (wanted div %ld)\n", __func__,
+		__clk_get_name(hw->clk), rate, *prate, div);
+	pr_devel("   min %d (%ld) max %d (%ld)\n",
+		clk->min, DIV_ROUND_UP(*prate, clk->min),
+		clk->max, DIV_ROUND_UP(*prate, clk->max));
+
+	div = rzn1_divider_clamp_div(clk, rate, *prate);
+	pr_devel("%s %s %ld / %ld = %ld\n", __func__,
+		__clk_get_name(hw->clk),
+		*prate, div, DIV_ROUND_UP(*prate, div));
+	return DIV_ROUND_UP(*prate, div);
+}
+
+static int rzn1_divider_set_rate(
+	struct clk_hw *hw, unsigned long rate,
+	unsigned long parent_rate)
+{
+	struct rzn1_divider *clk = to_rzn1_divider(hw);
+	u32 div = DIV_ROUND_UP(parent_rate, rate);
+
+	pr_devel("%s rate %ld parent %ld div %d\n", __func__,
+		rate, parent_rate, div);
+
+	/* Need to write the bit 31 with the divider value to
+	 * latch it. Technically we should wait until it has been
+	 * cleared too.
+	 * TODO: Find wether this callback is sleepable, in case
+	 * the hardware /does/ require some sort of spinloop here. */
+	writel(div | (1 << 31), clk->reg);
+
+	return 0;
+}
+
+static const struct clk_ops rzn1_clk_divider_ops = {
+	.recalc_rate = rzn1_divider_recalc_rate,
+	.round_rate = rzn1_divider_round_rate,
+	.set_rate = rzn1_divider_set_rate,
+};
+
+/*
+ * This reads an optional table for dividers, the values have to be
+ * sorted, and have to be within min and max
+ */
+static int __init rzn1_read_divider_table(
+	struct rzn1_divider *div,
+	struct device_node *node)
+{
+	u32 table_size;
+	const __be32 *tablespec;
+	int i;
+
+	tablespec = of_get_property(node, "renesas,rzn1-div-table",
+					&table_size);
+	if (!tablespec)
+		return -1;
+	table_size /= sizeof(u32);
+	if (table_size > ARRAY_SIZE(div->table)) {
+		pr_err("%s: %s renesas,rzn1-div-table overflow\n",
+				__func__, node->name);
+		table_size = ARRAY_SIZE(div->table);
+	}
+	pr_devel("%s %s renesas,rzn1-div-table size = %d (min %d, max %d)\n",
+		__func__, node->name, table_size, div->min, div->max);
+	for (i = 0; i < table_size; i++) {
+		u32 d;
+
+		of_property_read_u32_index(node, "renesas,rzn1-div-table",
+						i, &d);
+		pr_devel("  [%d] = %d\n", i, d);
+
+		if ((div->table_size && d <= div->table[div->table_size-1]) ||
+			d < div->min || d > div->max) {
+			pr_err("%s: %s renesas,rzn1-div-table invalid: %d\n",
+					__func__, node->name, d);
+			return -EOVERFLOW;
+		}
+		div->table[div->table_size++] = d;
+	}
+	return 0;
+}
+
+static struct rzn1_divider *_register_divider(
+		struct device *dev, const char *name,
+		const char *parent_name, unsigned long flags,
+		u32 __iomem *reg, u16 mask,
+		u16 min, u16 max,
+		u8 clk_divider_flags)
+{
+	struct rzn1_divider *div;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	/* allocate the divider */
+	div = kzalloc(sizeof(struct rzn1_divider), GFP_KERNEL);
+	if (!div)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &rzn1_clk_divider_ops;
+	init.flags = flags | CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+
+	/* struct rzn1_divider assignments */
+	div->reg = reg;
+	div->mask = mask;
+	div->flags = clk_divider_flags;
+	div->hw.init = &init;
+	div->min = min;
+	div->max = max;
+
+	/* register the clock */
+	clk = clk_register(dev, &div->hw);
+
+	if (IS_ERR(clk)) {
+		kfree(div);
+		return ERR_PTR(-ENOMEM);
+	}
+	return div;
+}
+
+
+void __init rzn1_clock_divider_init(struct device_node *node)
+{
+	struct rzn1_divider *div;
+	const char *clk_name = node->name;
+	void __iomem *reg;
+	const char *parent_name;
+	u8 clk_divider_flags = 0;
+	u32 mask = 0, div_offset = 0, min = 1, max = 1;
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	if (of_property_read_u32(node, "renesas,rzn1-div-min", &min)) {
+		min = 1;
+		pr_err("%s: missing renesas,rzn1-div-min property for %s\n",
+			__func__, node->name);
+	}
+	if (of_property_read_u32(node, "renesas,rzn1-div-max", &max)) {
+		max = min;
+		pr_err("%s: missing renesas,rzn1-div-max property for %s\n",
+			__func__, node->name);
+	}
+
+	if (of_property_read_u32(node, "reg", &div_offset)) {
+		reg = &ioreg[ioregcnt++];
+		*((u32 *)reg) = min;
+
+		pr_debug("%s: %s MISSING REG property, faking it\n",
+			__func__, node->name);
+	} else {
+		reg = ((u8 *)rzn1_sysctrl_base()) + div_offset;
+	}
+
+	if (of_property_read_u32(node, "renesas,rzn1-bit-mask", &mask)) {
+		mask = 0xff;
+		pr_err("%s: missing bit-mask property for %s\n", __func__,
+			node->name);
+	}
+
+	if (of_property_read_bool(node, "renesas,rzn1-index-power-of-two"))
+		clk_divider_flags |= CLK_DIVIDER_POWER_OF_TWO;
+
+	pr_devel("%s %s mask %x, val %x\n", __func__,
+		node->name, mask, *((u32 *)reg));
+
+	div = _register_divider(NULL, clk_name,
+			parent_name, 0,
+			reg, mask, min, max,
+			clk_divider_flags);
+
+	if (div) {
+		if (rzn1_read_divider_table(div, node) == 0)
+			of_clk_add_provider(node, of_clk_src_simple_get,
+					div->hw.clk);
+	}
+}
+
+CLK_OF_DECLARE(rzn1_divider_clk,
+	"renesas,rzn1-clock-divider", rzn1_clock_divider_init);
+
diff --git a/drivers/clk/rzn1/rzn1-clock-gate.c b/drivers/clk/rzn1/rzn1-clock-gate.c
new file mode 100644
index 0000000..6b111a1
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-gate.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+
+#include "rzn1-clock.h"
+
+/*
+ * This implements the RZ/N1 clock gate 'driver'. We cannot use the system's
+ * clock gate framework as the gates on the RZ/N1 have a special enabling
+ * sequence, therefore we use this little proxy to call into the general
+ * clock gate API in rznr-clock.c that implements what is needed.
+ */
+struct rzn1_gate {
+	struct clk_hw	hw;
+	u32 gate_idx;
+	unsigned no_disable : 1;
+};
+
+#define to_rzn1_gate(_hw) container_of(_hw, struct rzn1_gate, hw)
+
+static int clk_gate_enable(struct clk_hw *hw)
+{
+	struct rzn1_gate *g = to_rzn1_gate(hw);
+
+	rzn1_clk_set_gate(g->gate_idx, 1);
+	return 0;
+}
+
+static void clk_gate_disable(struct clk_hw *hw)
+{
+	struct rzn1_gate *g = to_rzn1_gate(hw);
+
+	if (!g->no_disable)
+		rzn1_clk_set_gate(g->gate_idx, 0);
+	else
+		printk(KERN_INFO "%s %s: disallowed\n", __func__,
+			__clk_get_name(hw->clk));
+}
+
+static int clk_gate_is_enabled(struct clk_hw *hw)
+{
+	struct rzn1_gate *g = to_rzn1_gate(hw);
+
+	return rzn1_clk_is_gate_enabled(g->gate_idx);
+}
+
+static const struct clk_ops _clk_gate_ops = {
+	.enable = clk_gate_enable,
+	.disable = clk_gate_disable,
+	.is_enabled = clk_gate_is_enabled,
+};
+
+static void __init rzn1_clock_gate_init(struct device_node *node)
+{
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	u32 gate_idx = 0;
+	struct rzn1_gate *g;
+	struct clk_init_data init;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	/* Some clock in the clock tree do not have a declared gate register */
+	if (of_property_read_u32(node, "reg", &gate_idx))
+		return;
+
+	/* allocate the gate */
+	g = kzalloc(sizeof(struct rzn1_gate), GFP_KERNEL);
+	if (!g)
+		return;
+
+	init.name = clk_name;
+	init.ops = &_clk_gate_ops;
+	init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+
+	/* struct clk_gate assignments */
+	g->gate_idx = gate_idx;
+	g->hw.init = &init;
+	g->no_disable = of_property_read_bool(node, "renesas,no-disable");
+
+	clk = clk_register(NULL, &g->hw);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	else
+		kfree(g);
+}
+
+
+CLK_OF_DECLARE(rzn1_gate_clk, "renesas,rzn1-clock-gate", rzn1_clock_gate_init);
+
diff --git a/drivers/clk/rzn1/rzn1-clock-group.c b/drivers/clk/rzn1/rzn1-clock-group.c
new file mode 100644
index 0000000..f2ab52f
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-group.c
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This driver is needed to allow clocks to be 'grouped' together, with
+ * just one enable/disable. It is needed because the RZN1 has sometime
+ * several clocks that need to be enabled for a peripheral to work, while
+ * most of the time the drivers has no nothing of more than one clock (at
+ * best).
+ * So this driver allow the grouping of these multiple sclk, pclk and so
+ * forth into one 'umbrella' clock that will enable (and claim) all the
+ * specified parent clocks and enable/disable then all when necessary
+ */
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+
+#include "rzn1-clock.h"
+
+struct rzn1_group {
+	struct clk_hw	hw;
+	int	used;
+	int	nparents;
+	struct {
+		const char *name;
+		struct clk *clk;
+	} parent[0];
+};
+
+#define to_clk_group(_hw) container_of(_hw, struct rzn1_group, hw)
+
+static int clk_group_enable(struct clk_hw *hw)
+{
+	struct rzn1_group *group = to_clk_group(hw);
+	int i;
+
+	group->used = 1;
+
+	for (i = 1; i < group->nparents; i++) {
+		if (!group->parent[i].clk) {
+			group->parent[i].clk =
+				__clk_lookup(group->parent[i].name);
+			if (group->parent[i].clk)
+				clk_prepare(group->parent[i].clk);
+		}
+		if (group->parent[i].clk)
+			clk_enable(group->parent[i].clk);
+	}
+
+	return 0;
+}
+
+static void clk_group_disable(struct clk_hw *hw)
+{
+	struct rzn1_group *group = to_clk_group(hw);
+	int i;
+
+	/* Do not disable clock groups that have not been initialised. This is
+	 * because we will end up decrementing the use count for clocks that
+	 * are shared by multiple IPs */
+	if (!group->used)
+		return;
+
+	for (i = 1; i < group->nparents; i++) {
+		if (!group->parent[i].clk) {
+			group->parent[i].clk =
+				__clk_lookup(group->parent[i].name);
+			if (group->parent[i].clk)
+				clk_prepare(group->parent[i].clk);
+		}
+		/* Do not clk_disable() unless the clock has been
+		 * enabled, otherwise the clk subsystem will BUG() */
+		if (group->parent[i].clk)
+			if (__clk_get_enable_count(group->parent[i].clk) > 0)
+				clk_disable(group->parent[i].clk);
+	}
+}
+
+static int clk_group_is_enabled(struct clk_hw *hw)
+{
+	struct rzn1_group *group = to_clk_group(hw);
+	struct clk *parent = clk_get_parent(group->hw.clk);
+
+	return __clk_is_enabled(parent);
+}
+
+static const struct clk_ops clk_group_ops = {
+	.enable = clk_group_enable,
+	.disable = clk_group_disable,
+	.is_enabled = clk_group_is_enabled,
+};
+
+static void __init rzn1_clock_group_init(struct device_node *node)
+{
+	const char *clk_name = node->name;
+	struct clk *clk;
+	int nparents  = 0;
+	int i;
+	struct rzn1_group *group = NULL;
+	struct clk_init_data init;
+
+	nparents = of_count_phandle_with_args(node, "clocks", "#clock-cells");
+	pr_devel("%s %s %d parents\n", __func__, node->name, nparents);
+
+	group = kzalloc(sizeof(struct rzn1_group) +
+			(sizeof(group->parent[0]) * nparents),
+			GFP_KERNEL);
+	if (IS_ERR(group)) {
+		pr_err("%s failed to allocate %s(%d)\n", __func__,
+			node->name, nparents);
+		return;
+	}
+	for (i = 0; i < nparents; i++)
+		group->parent[i].name = of_clk_get_parent_name(node, i);
+	group->nparents = nparents;
+
+	init.name = clk_name;
+	init.ops = &clk_group_ops;
+	init.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;
+	/* There is only own 'true' parent here, the other ones are ghosts */
+	init.parent_names = &group->parent[0].name;
+	init.num_parents = 1;
+	group->hw.init = &init;
+
+	clk = clk_register(NULL, &group->hw);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+
+}
+
+CLK_OF_DECLARE(rzn1_group_clk,
+		"renesas,rzn1-clock-group", rzn1_clock_group_init);
diff --git a/drivers/clk/rzn1/rzn1-clock-selector.c b/drivers/clk/rzn1/rzn1-clock-selector.c
new file mode 100644
index 0000000..935d903
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock-selector.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+
+#include "rzn1-clock.h"
+
+
+static uint32_t ioreg[32];
+static int ioregcnt;
+
+static void __init rzn1_clock_selector_init(struct device_node *node)
+{
+	const char *clk_name = node->name;
+	struct clk *clk;
+	int nparents  = 0;
+	const char **parent_names;
+	void __iomem *reg = NULL;
+	u32 mask = 0;
+	u32 shift = 0;
+	int i;
+	u8 clk_mux_flags = 0;
+
+	nparents = of_count_phandle_with_args(node, "clocks", "#clock-cells");
+	pr_devel("%s %s %d parents\n", __func__, node->name, nparents);
+
+	parent_names = kzalloc((sizeof(char *) * nparents),
+			GFP_KERNEL);
+	if (!parent_names)
+		return;
+
+	for (i = 0; i < nparents; i++)
+		parent_names[i] = of_clk_get_parent_name(node, i);
+	/*
+	 * TODO Find clock selector register & bits.. unspecified for
+	 * ALL of them for the minute
+	 */
+	reg = of_iomap(node, 0);
+	if (!reg) {
+		reg = &ioreg[ioregcnt++];
+		pr_debug("%s: %s MISSING REG property, faking it\n", __func__,
+			node->name);
+	}
+	if (of_property_read_u32(node, "renesas,rzn1-bit-mask", &mask)) {
+		mask = 0xf;
+		pr_debug("%s: missing bit-mask property for %s\n",
+			__func__, node->name);
+	}
+
+	if (of_property_read_u32(node, "renesas,rzn1-bit-shift", &shift)) {
+		shift = __ffs(mask);
+		mask >>= shift;
+		pr_debug("%s: bit-shift property defaults to 0x%x for %s\n",
+				__func__, shift, node->name);
+	}
+	clk = clk_register_mux_table(NULL, clk_name, parent_names, nparents,
+			0, reg, shift, mask, clk_mux_flags,
+			NULL, NULL);
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+
+CLK_OF_DECLARE(rzn1_selector_clk,
+		"renesas,rzn1-clock-selector", rzn1_clock_selector_init);
diff --git a/drivers/clk/rzn1/rzn1-clock.c b/drivers/clk/rzn1/rzn1-clock.c
new file mode 100644
index 0000000..296bd47
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock.c
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/delay.h>
+
+#include "rzn1-clock.h"
+#include <dt-bindings/clock/rzn1-clocks.h>
+#include <dt-bindings/soc/rzn1-sysctrl.h>
+
+#define _BIT(_r, _p) { .reg = _r, .pos = _p }
+
+#define _CLK(_n, _clk, _rst, _rdy, _midle, _scon, _mirack, _mistat ) \
+	{ .name = _n, .clock = _clk, .reset = _rst, \
+		.ready = _rdy, .masteridle = _midle }
+
+#include "rzn1-clkctrl-tables.h"
+
+static rzn1_clk_hook hook[RZN1_CLK_COUNT];
+
+void rzn1_clk_set_hook(int clkdesc_id, rzn1_clk_hook clk_hook)
+{
+	BUG_ON(clkdesc_id >= RZN1_CLK_COUNT);
+	hook[clkdesc_id] = clk_hook;
+}
+
+const struct rzn1_clkdesc *rzn1_get_clk_desc(int clkdesc_id)
+{
+	static struct rzn1_clkdesc zero = _CLK("*unknown*",
+				{}, {}, {}, {}, {}, {}, {});
+
+	return clkdesc_id < RZN1_CLK_COUNT ?
+			&rzn1_clock_list[clkdesc_id] :
+			&zero;
+}
+EXPORT_SYMBOL_GPL(rzn1_get_clk_desc);
+
+static void clk_mgr_desc_set(const struct rzn1_onereg *one, int on)
+{
+	u32 *reg = ((u32 *)rzn1_sysctrl_base()) + one->reg;
+	u32 val = clk_readl(reg);
+
+	val = (val & ~(1 << one->pos)) | ((!!on) << one->pos);
+	clk_writel(val, reg);
+}
+
+void rzn1_clk_set_gate(int clkdesc_id, int on)
+{
+	const struct rzn1_clkdesc *g = rzn1_get_clk_desc(clkdesc_id);
+
+	BUG_ON(!rzn1_sysctrl_base());
+	BUG_ON(!g->clock.reg);
+
+	if (hook[clkdesc_id])
+		if (hook[clkdesc_id](clkdesc_id, RZN1_CLK_HOOK_GATE_PRE, on))
+			return;
+	clk_mgr_desc_set(&(g->clock), on);
+
+	if (hook[clkdesc_id])
+		if (hook[clkdesc_id](clkdesc_id, RZN1_CLK_HOOK_GATE_SET, on))
+			return;
+
+	/* If the peripheral is memory mapped (i.e. an AXI slave), there is an
+	 * associated SLVRDY bit in the System Controller that needs to be set
+	 * so that the FlexWAY bus fabric passes on the read/write requests.
+	 */
+	if (g->ready.reg)
+		clk_mgr_desc_set(&(g->ready), on);
+
+	/* Clear 'Master Idle Request' bit */
+	if (g->masteridle.reg)
+		clk_mgr_desc_set(&(g->masteridle), !on);
+
+	if (hook[clkdesc_id])
+		hook[clkdesc_id](clkdesc_id, RZN1_CLK_HOOK_GATE_POST, on);
+
+	/* Note: We don't wait for FlexWAY Socket Connection signal */
+}
+EXPORT_SYMBOL_GPL(rzn1_clk_set_gate);
+
+int rzn1_clk_is_gate_enabled(int clkdesc_id)
+{
+	const struct rzn1_clkdesc *g = rzn1_get_clk_desc(clkdesc_id);
+	u32 *reg;
+
+	BUG_ON(!rzn1_sysctrl_base());
+	BUG_ON(!g->clock.reg);
+
+	reg = ((u32 *)rzn1_sysctrl_base()) + g->clock.reg;
+	return !!(clk_readl(reg) & (1 << g->clock.pos));
+}
+EXPORT_SYMBOL_GPL(rzn1_clk_is_gate_enabled);
+
+
+static ssize_t sys_clk_set_rate_show(
+	struct kobject *kobj,
+	struct kobj_attribute *attr,
+	char *buf)
+{
+	strcpy(buf, "Usage: echo <clock name> <rate in hz> >clk_set_rate\n");
+	return strlen(buf);
+}
+
+static ssize_t sys_clk_set_rate_store(
+	struct kobject *kobj,
+	struct kobj_attribute *attr,
+	const char *buf, size_t count)
+{
+	char copy[count + 1];
+	char *p = copy;
+	const char *trate;
+	const char *name;
+	long rate;
+	struct clk *clk;
+
+	/* the 'buf' is const, so we can't strsep into it */
+	strncpy(copy, buf, sizeof(copy));
+	name = strsep(&p, " ");
+	if (name)
+		trate = strsep(&p, " ");
+	if (!name || !trate)
+		return count;
+	pr_devel("%s clock:%s rate:%s\n", __func__, name, trate);
+	if (kstrtol(trate, 10, &rate) != 0) {
+		pr_err("%s %s, invalid rate %s\n", __func__, name, trate);
+		return count;
+	}
+	pr_devel("%s %s requested rate %ld\n", __func__, name, rate);
+
+	clk = __clk_lookup(name);
+	if (IS_ERR(clk)) {
+		pr_err("%s %s: clock not found\n", __func__, name);
+		return -EINVAL;
+	}
+	pr_devel("%s clk %s found\n", __func__, name);
+	pr_devel("%s %s current rate %lu\n", __func__, name,
+		clk_get_rate(clk));
+	if (rate > 0) {
+		if (clk_set_rate(clk, rate)) {
+			pr_err("%s %s FAILED\n", __func__, name);
+		} else {
+			pr_info("%s %s set to %lu\n", __func__, name,
+				clk_get_rate(clk));
+		}
+	}
+	return count;
+}
+
+static struct kobj_attribute clk_set_rate_attribute =
+	__ATTR(clk_set_rate, 0644,
+	       sys_clk_set_rate_show, sys_clk_set_rate_store);
+
+static struct attribute *attrs[] = {
+	&clk_set_rate_attribute.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+static struct kobject *grp_kobj;
+static int __init rzn1_clock_sys_init(void)
+{
+	int retval;
+
+	grp_kobj = kobject_create_and_add("rzn1", kernel_kobj);
+	if (!grp_kobj)
+		return -ENOMEM;
+	retval = sysfs_create_group(grp_kobj, &attr_group);
+	if (retval)
+		kobject_put(grp_kobj);
+	return retval;
+}
+postcore_initcall(rzn1_clock_sys_init);
+
+#define USBFUNC_EPCTR		(RZN1_USB_DEV_BASE + 0x1000 + 0x10)
+
+static int rzn1_usb_clock_hook(int clkdesc_id, int operation, u32 value)
+{
+	u32 val, h2mode = 0;
+	struct device_node *np;
+	void * epctr = NULL;
+
+	if (operation != RZN1_CLK_HOOK_GATE_POST || value != 1)
+		return 0;
+
+	np = of_find_node_by_path("/chosen");
+	if (np && of_property_read_bool(np, "rzn1,h2mode"))
+		h2mode = (1 << RZN1_SYSCTRL_REG_CFG_USB_H2MODE);
+
+	/* If the PLL is already started, we don't need to do it again anyway
+	 * and if the USB configuration is already in the right mode, we don't
+	 * need to configure that either */
+	val = rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_CFG_USB);
+	if (!(val & (1 << RZN1_SYSCTRL_REG_CFG_USB_DIRPD)) &&
+		(val & (1 << RZN1_SYSCTRL_REG_CFG_USB_H2MODE)) == h2mode &&
+		rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_USBSTAT) &
+			(1 << RZN1_SYSCTRL_REG_USBSTAT_PLL_LOCK)) {
+		pr_info("rzn1: USB PLL already started\n");
+		return 0;
+	}
+	pr_info("rzn1: USB PLL in %s mode\n", h2mode ? "Host" : "Func");
+
+	/* trick here, the usb function clocks NEEDS to have been enabled
+	 * otherwise this register is not available. That means the h2mode
+	 * still requires the usbf clocks, at least for this part (!) */
+	epctr = ioremap(USBFUNC_EPCTR, 4);
+	/* Hold USBF in reset */
+	writel(0x7, epctr);
+	udelay(500);
+
+	val &= ~(1 << RZN1_SYSCTRL_REG_CFG_USB_H2MODE);
+	val |= h2mode;
+	val |= (1 << RZN1_SYSCTRL_REG_CFG_USB_DIRPD);
+	val |= (1 << RZN1_SYSCTRL_REG_CFG_USB_FRCLK48MOD);
+	rzn1_sysctrl_writel(val, RZN1_SYSCTRL_REG_CFG_USB);
+
+	udelay(500);
+
+	/* Power up USB PLL */
+	val = rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_CFG_USB);
+	val &= ~(1 << RZN1_SYSCTRL_REG_CFG_USB_DIRPD);
+	rzn1_sysctrl_writel(val, RZN1_SYSCTRL_REG_CFG_USB);
+
+	mdelay(1);
+	/* Release USBF and HOST resets */
+	writel(0, epctr);
+	iounmap(epctr);
+
+	/* Wait for USB PLL lock */
+	do {
+		val = rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_USBSTAT);
+	} while (!(val & (1 << RZN1_SYSCTRL_REG_USBSTAT_PLL_LOCK)));
+
+	return 0;
+}
+
+static void __init rzn1_clock_init(struct device_node *node)
+{
+	rzn1_sysctrl_init();
+
+	/* This hook will decide of the fate of the HOST vs
+	 * DEVICE for the usb port -- the board designer has to enable
+	 * either of the driver in the DTS, or have the bootloader set
+	 * the appropriate DT property before starting the kernel */
+	rzn1_clk_set_hook(RZN1_CLK_48MHZ_PG_F_ID, rzn1_usb_clock_hook);
+}
+
+
+CLK_OF_DECLARE(rzn1_clock, "renesas,rzn1-clock", rzn1_clock_init);
diff --git a/drivers/clk/rzn1/rzn1-clock.h b/drivers/clk/rzn1/rzn1-clock.h
new file mode 100644
index 0000000..92230e5
--- /dev/null
+++ b/drivers/clk/rzn1/rzn1-clock.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __RZN1_CLOCK_H
+#define __RZN1_CLOCK_H
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/sysctrl-rzn1.h>
+
+/* Generic register/bit group descriptor */
+struct rzn1_onereg {
+	uint16_t reg : 7,	/* Register number (word) */
+		pos : 5,	/* Bit number */
+		size : 4;	/* Optional: size in bits */
+};
+
+struct rzn1_clkdesc {
+	const char * name;
+	struct rzn1_onereg clock, reset, ready, masteridle;
+};
+
+/*
+ * These accessors allows control of the clock gates as
+ * defined in rzn1-clocks.h
+ */
+const struct rzn1_clkdesc *rzn1_get_clk_desc(int clkdesc_id);
+void rzn1_clk_set_gate(int clkdesc_id, int on);
+int rzn1_clk_is_gate_enabled(int clkdesc_id);
+
+/*
+ * This allow setting overrride and/or supplemental functions to specific
+ * clocks; the current case is for the USB clock that needs a special PLL
+ * register to be set.
+ */
+enum {
+	RZN1_CLK_HOOK_GATE_PRE = 0,
+	RZN1_CLK_HOOK_GATE_SET,
+	RZN1_CLK_HOOK_GATE_POST,
+};
+
+typedef int (*rzn1_clk_hook)(int clkdesc_id, int operation, u32 value);
+
+void rzn1_clk_set_hook(int clkdesc_id, rzn1_clk_hook clk_hook);
+
+#endif /* __RZN1_CLOCK_H */
+
diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index e2c6e43..e262c48 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -90,6 +90,9 @@ config ORION_TIMER
 	help
 	  Enables the support for the Orion timer driver
 
+config RZN1_TIMER
+	bool "Renesas RZ/N1 UDL Timer"
+
 config SUN4I_TIMER
 	bool "Sun4i timer driver" if COMPILE_TEST
 	depends on GENERIC_CLOCKEVENTS
diff --git a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
index cf87f40..82ade2b 100644
--- a/drivers/clocksource/Makefile
+++ b/drivers/clocksource/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_DIGICOLOR_TIMER)	+= timer-digicolor.o
 obj-$(CONFIG_DW_APB_TIMER)	+= dw_apb_timer.o
 obj-$(CONFIG_DW_APB_TIMER_OF)	+= dw_apb_timer_of.o
 obj-$(CONFIG_ROCKCHIP_TIMER)      += rockchip_timer.o
+obj-$(CONFIG_RZN1_TIMER)	+= rzn1-timer.o
 obj-$(CONFIG_CLKSRC_NOMADIK_MTU)	+= nomadik-mtu.o
 obj-$(CONFIG_CLKSRC_DBX500_PRCMU)	+= clksrc-dbx500-prcmu.o
 obj-$(CONFIG_ARMADA_370_XP_TIMER)	+= time-armada-370-xp.o
diff --git a/drivers/clocksource/rzn1-timer.c b/drivers/clocksource/rzn1-timer.c
new file mode 100644
index 0000000..18ea8e8
--- /dev/null
+++ b/drivers/clocksource/rzn1-timer.c
@@ -0,0 +1,302 @@
+/*
+ * RZ/N1 clock-event
+ *
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ * Author: Phil Edworthy <phil.edworthy@renesas.com>
+ *
+ * Based on timer-keystone.c
+ * Copyright 2013 Texas Instruments, Inc.
+ * Author: Ivan Khoronzhuk <ivan.khoronzhuk@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <linux/interrupt.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/slab.h>
+
+#define TIMER_NAME			"rzn1-timer"
+
+/* Per-Timer register offsets */
+#define LOAD_COUNT			0x00
+#define CURRENT_COUNT			0x04
+#define CONTROL				0x08
+#define CLEAR_INT			0x0c
+#define STATUS_INT0			0x10
+#define STATUS_INT1			0x14
+#define TIMER_SRC_SIZE			0x20
+
+#define TIMER_SRC_COUNT			8
+
+/* Register bit positions */
+#define CONTROL_INT_EN			3
+#define CONTROL_EN			2
+#define CONTROL_RELOAD			1
+#define CONTROL_DIV25			0
+
+#define ONESHOT		1
+#define PERIODIC	0
+
+/**
+ * struct rzn1_timer: holds timer's data for one source
+ * @base: timer memory base address
+ * @hz_period: cycles per HZ period
+ * @dev: event device based on timer
+ */
+struct rzn1_timer {
+	void __iomem *base;
+	unsigned index;	/* sub-timer source index */
+	unsigned long hz_period;
+	struct clock_event_device dev;
+};
+
+static inline u32 rzn1_timer_readl(
+	struct rzn1_timer *timer, unsigned long rg)
+{
+	return readl_relaxed(timer->base + rg);
+}
+
+static inline void rzn1_timer_writel(
+	struct rzn1_timer *timer, u32 val, unsigned long rg)
+{
+	writel_relaxed(val, timer->base + rg);
+}
+
+/**
+ * rzn1_timer_barrier: write memory barrier
+ * use explicit barrier to avoid using readl/writel non relaxed function
+ * variants, because in our case non relaxed variants hide the true places
+ * where barrier is needed.
+ */
+static inline void rzn1_timer_barrier(struct rzn1_timer *timer)
+{
+	__iowmb();
+}
+
+/**
+ * rzn1_timer_config: configures timer to work in oneshot/periodic modes.
+ * @ period: cycles number to configure for
+ */
+static int rzn1_timer_config(
+	struct rzn1_timer *timer, u32 period, int mode)
+{
+	u32 ctrl;
+	u32 off;
+
+	ctrl = rzn1_timer_readl(timer, CONTROL);
+	off = ctrl & ~(1 << CONTROL_EN);
+
+	/* set enable mode */
+	if (mode == ONESHOT) {
+		ctrl &= ~(1 << CONTROL_RELOAD);
+		ctrl |= (1 << CONTROL_EN);
+	} else {
+		/* periodic */
+		ctrl |= (1 << CONTROL_RELOAD);
+		ctrl |= (1 << CONTROL_EN);
+	}
+
+	/* disable timer */
+	rzn1_timer_writel(timer, off, CONTROL);
+	/* here we have to be sure the timer has been disabled */
+	rzn1_timer_barrier(timer);
+
+	/* reset counter to zero, set new period */
+	rzn1_timer_writel(timer, 0, CURRENT_COUNT);
+	rzn1_timer_writel(timer, period, LOAD_COUNT);
+
+	/*
+	 * enable timer
+	 * here we have to be sure that registers have been written.
+	 */
+	rzn1_timer_barrier(timer);
+	rzn1_timer_writel(timer, ctrl, CONTROL);
+	return 0;
+}
+
+static void rzn1_timer_disable(struct rzn1_timer *timer)
+{
+	u32 ctrl;
+
+	ctrl = rzn1_timer_readl(timer, CONTROL);
+
+	/* disable timer */
+	ctrl &= ~(CONTROL_EN);
+	rzn1_timer_writel(timer, ctrl, CONTROL);
+}
+
+static irqreturn_t rzn1_timer_interrupt(int irq, void *dev_id)
+{
+	struct rzn1_timer *timer = dev_id;
+
+	/* ack the interrupt */
+	rzn1_timer_readl(timer, CLEAR_INT);
+	rzn1_timer_barrier(timer);
+
+	timer->dev.event_handler(&timer->dev);
+	return IRQ_HANDLED;
+}
+
+static int rzn1_set_next_event(unsigned long cycles,
+				  struct clock_event_device *evt)
+{
+	struct rzn1_timer *timer = container_of(evt, struct rzn1_timer, dev);
+
+	return rzn1_timer_config(timer, cycles, ONESHOT);
+}
+
+static int rzn1_shutdown(struct clock_event_device *evt)
+{
+	struct rzn1_timer *timer = container_of(evt, struct rzn1_timer, dev);
+
+	rzn1_timer_disable(timer);
+	return 0;
+}
+
+static int rzn1_set_periodic(struct clock_event_device *evt)
+{
+	struct rzn1_timer *timer = container_of(evt, struct rzn1_timer, dev);
+
+	rzn1_timer_config(timer, timer->hz_period, PERIODIC);
+	return 0;
+}
+
+static int __init rzn1_timer_init(struct device_node *np)
+{
+	struct rzn1_timer *timers;
+	unsigned long base_rate;
+	struct clk *clk;
+	u32 timer_width = 16;
+	u32 timer_block_number = 0;
+	bool use_prescaler;
+	int error;
+	void *base;
+	int timer_count = 0, i;
+
+	of_property_read_u32(np, "timer-width", &timer_width);
+	if (timer_width != 16 && timer_width != 32) {
+		pr_err("%s:%s Invalid timer-width\n", __func__, np->full_name);
+		return -EINVAL;
+	}
+	/* optional property, allows for naming timers as timer0, timer1 */
+	of_property_read_u32(np, "renesas,timer-number", &timer_block_number);
+	/* optional property, global prescaler flag for all sources */
+	use_prescaler = of_property_read_bool(np, "use-prescaler");
+
+	timers = kcalloc(TIMER_SRC_COUNT, sizeof(struct rzn1_timer),
+				GFP_KERNEL);
+	if (!timers) {
+		pr_warn("%s:%s failed to allocate", __func__, np->full_name);
+		return -ENOMEM;
+	}
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_err("%s:%s failed to map registers\n",
+			__func__, np->full_name);
+		return -ENXIO;
+	}
+
+	clk = of_clk_get(np, 0);
+	if (IS_ERR(clk)) {
+		pr_err("%s:%s failed to get clock\n",
+			__func__, np->full_name);
+		iounmap(base);
+		return PTR_ERR(clk);
+	}
+
+	error = clk_prepare_enable(clk);
+	if (error) {
+		pr_err("%s:%s failed to enable clock\n",
+			__func__, np->full_name);
+		goto err;
+	}
+
+	base_rate = clk_get_rate(clk);
+
+	pr_info("rzn1-timer%d base clock @%lu Hz\n",
+		timer_block_number, base_rate);
+
+	for (i = 0; i < TIMER_SRC_COUNT; i++, timer_count++) {
+		struct rzn1_timer *timer = &timers[i];
+		unsigned long rate = base_rate;
+		u32 prescale = use_prescaler;
+
+		/* optional, per-src overrride property for the
+		 * prescale flag */
+		of_property_read_u32_index(np, "renesas,src-prescaler",
+					i, &prescale);
+		/* setup clockevent */
+		timer->index = i;
+		timer->base = base + (i * TIMER_SRC_SIZE);
+		timer->dev.features = CLOCK_EVT_FEAT_PERIODIC |
+						CLOCK_EVT_FEAT_ONESHOT;
+		timer->dev.set_next_event = rzn1_set_next_event;
+		timer->dev.set_state_shutdown = rzn1_shutdown;
+		timer->dev.set_state_periodic = rzn1_set_periodic;
+		timer->dev.set_state_oneshot = rzn1_shutdown;
+
+		timer->dev.cpumask = cpu_all_mask;
+		timer->dev.owner = THIS_MODULE;
+		timer->dev.name = kasprintf(GFP_KERNEL, TIMER_NAME "%d:%d",
+						timer_block_number, i);
+
+		timer->dev.irq  = irq_of_parse_and_map(np, i);
+		if (timer->dev.irq == NO_IRQ) {
+			pr_err("%s:%s failed to map interrupts\n",
+				__func__, np->full_name);
+			error = -EINVAL;
+			goto err_irq;
+		}
+
+		if (prescale)
+			rate /= 25;
+
+		/* disable */
+		rzn1_timer_writel(timer, 0, CONTROL);
+		/* here we have to be sure the timer has been disabled */
+		rzn1_timer_barrier(timer);
+
+		/* init counter to zero */
+		rzn1_timer_writel(timer, 0, CURRENT_COUNT);
+
+		timer->hz_period = DIV_ROUND_UP(rate, HZ);
+
+		error = request_irq(timer->dev.irq, rzn1_timer_interrupt,
+					IRQF_TIMER, TIMER_NAME, timer);
+		if (error) {
+			pr_err("%s:%s failed to setup irq\n",
+				__func__, np->full_name);
+			goto err_irq;
+		}
+
+		/* enable timer interrupts */
+		if (prescale)
+			rzn1_timer_writel(timer,
+				(1 << CONTROL_INT_EN) | (1 << CONTROL_DIV25),
+				CONTROL);
+		else
+			rzn1_timer_writel(timer, 1 << CONTROL_INT_EN, CONTROL);
+
+		clockevents_config_and_register(&timer->dev, rate, 1,
+					timer_width == 32 ? ULONG_MAX : 0xffff);
+	}
+	return 0;
+err_irq:
+	for (i = 0; i < timer_count; i++)
+		irq_dispose_mapping(timers[i].dev.irq);
+err:
+	clk_put(clk);
+	iounmap(base);
+	kfree(timers);
+	return error;
+}
+
+CLOCKSOURCE_OF_DECLARE(rzn1_timer, "renesas,rzn1-timer", rzn1_timer_init);
diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index d89b8af..4be71a0 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -88,6 +88,11 @@ config ARM_OMAP2PLUS_CPUFREQ
 	depends on ARCH_OMAP2PLUS
 	default ARCH_OMAP2PLUS
 
+config ARM_RZN1_CPUFREQ
+	bool "Renesas RZN1"
+	depends on ARCH_RZN1
+	default ARCH_RZN1
+
 config ARM_S3C_CPUFREQ
 	bool
 	help
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 0a9b6a09..006ef68 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -4,7 +4,7 @@ obj-$(CONFIG_CPU_FREQ)			+= cpufreq.o freq_table.o
 # CPUfreq stats
 obj-$(CONFIG_CPU_FREQ_STAT)             += cpufreq_stats.o
 
-# CPUfreq governors 
+# CPUfreq governors
 obj-$(CONFIG_CPU_FREQ_GOV_PERFORMANCE)	+= cpufreq_performance.o
 obj-$(CONFIG_CPU_FREQ_GOV_POWERSAVE)	+= cpufreq_powersave.o
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
@@ -62,6 +62,7 @@ obj-$(CONFIG_ARM_MT8173_CPUFREQ)	+= mt8173-cpufreq.o
 obj-$(CONFIG_ARM_OMAP2PLUS_CPUFREQ)	+= omap-cpufreq.o
 obj-$(CONFIG_ARM_PXA2xx_CPUFREQ)	+= pxa2xx-cpufreq.o
 obj-$(CONFIG_PXA3xx)			+= pxa3xx-cpufreq.o
+obj-$(CONFIG_ARM_RZN1_CPUFREQ)		+= rzn1-cpufreq.o
 obj-$(CONFIG_ARM_S3C24XX_CPUFREQ)	+= s3c24xx-cpufreq.o
 obj-$(CONFIG_ARM_S3C24XX_CPUFREQ_DEBUGFS) += s3c24xx-cpufreq-debugfs.o
 obj-$(CONFIG_ARM_S3C2410_CPUFREQ)	+= s3c2410-cpufreq.o
diff --git a/drivers/cpufreq/rzn1-cpufreq.c b/drivers/cpufreq/rzn1-cpufreq.c
new file mode 100644
index 0000000..37c79d0
--- /dev/null
+++ b/drivers/cpufreq/rzn1-cpufreq.c
@@ -0,0 +1,89 @@
+/*
+ * Clock scaling for the Renesas RZ/N1
+ *
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/clk-provider.h>
+#include <linux/printk.h>
+
+static struct cpufreq_driver rzn1_driver;
+
+/* make sure that only the "userspace" governor is run
+ * -- anything else wouldn't make sense on this platform, anyway.
+ */
+static int rzn1_verify_speed(struct cpufreq_policy *policy)
+{
+	if (policy->cpu)
+		return -EINVAL;
+
+	cpufreq_verify_within_cpu_limits(policy);
+	return 0;
+}
+
+static int rzn1_target(struct cpufreq_policy *policy,
+			 unsigned int target_freq,
+			 unsigned int relation)
+{
+	struct cpufreq_freqs freqs;
+	int ret;
+
+	pr_debug("%s switching to %d.%02dMHz\n", __func__,
+		target_freq / 1000, (target_freq / 10) % 100);
+	freqs.old = policy->cur;
+	freqs.new = target_freq;
+
+	cpufreq_freq_transition_begin(policy, &freqs);
+	ret = clk_set_rate(policy->clk, target_freq * 1000);
+	cpufreq_freq_transition_end(policy, &freqs, ret);
+
+	return ret;
+}
+
+static int rzn1_cpu_init(struct cpufreq_policy *policy)
+{
+	struct clk *ref_clk, *cpu_clk;
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+	/* Could use clk_get_parent() here?
+	 * I hoped to be able to get access to 'cpu' dts node from here,
+	 * and derive the div_ca7 clock from the 'clocks' property there,
+	 * but it looked a bit too involved, so this is hard coded instead. */
+	cpu_clk = __clk_lookup("div_ca7");
+	ref_clk = __clk_lookup("div_ref_sync");
+
+	policy->max = policy->cpuinfo.max_freq = clk_get_rate(ref_clk) / 1000;
+	policy->min = policy->cpuinfo.min_freq = policy->max / 4;
+	policy->cpuinfo.transition_latency = 20 * 1000;
+	policy->clk = cpu_clk;
+	return PTR_ERR_OR_ZERO(policy->clk);
+}
+
+static struct cpufreq_driver rzn1_driver = {
+	.flags		= CPUFREQ_STICKY | CPUFREQ_CONST_LOOPS,
+	.verify		= rzn1_verify_speed,
+	.target		= rzn1_target,
+	.get		= cpufreq_generic_get,
+	.init		= rzn1_cpu_init,
+	.name		= "rzn1",
+};
+
+static int __init rzn1_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&rzn1_driver);
+}
+
+subsys_initcall(rzn1_cpufreq_init);
diff --git a/drivers/dma/dw/core.c b/drivers/dma/dw/core.c
index c2c0a61..fced1da 100644
--- a/drivers/dma/dw/core.c
+++ b/drivers/dma/dw/core.c
@@ -780,7 +780,11 @@ static irqreturn_t dw_dma_interrupt(int irq, void *dev_id)
 			mem = sg_dma_address(sg);
 			len = sg_dma_len(sg);
 
-			mem_width = __ffs(data_width | mem | len);
+			if (!sconfig->device_fc) {
+				mem_width = __ffs(data_width | mem | len);
+			} else {
+				mem_width = __ffs(data_width | mem);
+			}
 
 slave_sg_todev_fill_desc:
 			desc = dwc_desc_get(dwc);
@@ -790,7 +794,8 @@ static irqreturn_t dw_dma_interrupt(int irq, void *dev_id)
 			lli_write(desc, sar, mem);
 			lli_write(desc, dar, reg);
 			lli_write(desc, ctllo, ctllo | DWC_CTLL_SRC_WIDTH(mem_width));
-			if ((len >> mem_width) > dwc->block_size) {
+			if (((len >> mem_width) > dwc->block_size) &&
+			    !sconfig->device_fc) {
 				dlen = dwc->block_size << mem_width;
 				mem += dlen;
 				len -= dlen;
@@ -833,7 +838,11 @@ static irqreturn_t dw_dma_interrupt(int irq, void *dev_id)
 			mem = sg_dma_address(sg);
 			len = sg_dma_len(sg);
 
-			mem_width = __ffs(data_width | mem | len);
+			if (!sconfig->device_fc) {
+				mem_width = __ffs(data_width | mem | len);
+			} else {
+				mem_width = __ffs(data_width | mem);
+			}
 
 slave_sg_fromdev_fill_desc:
 			desc = dwc_desc_get(dwc);
@@ -843,7 +852,8 @@ static irqreturn_t dw_dma_interrupt(int irq, void *dev_id)
 			lli_write(desc, sar, reg);
 			lli_write(desc, dar, mem);
 			lli_write(desc, ctllo, ctllo | DWC_CTLL_DST_WIDTH(mem_width));
-			if ((len >> reg_width) > dwc->block_size) {
+			if (((len >> reg_width) > dwc->block_size) &&
+			    !sconfig->device_fc) {
 				dlen = dwc->block_size << reg_width;
 				mem += dlen;
 				len -= dlen;
diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 5bda0eb..ed4b496 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -21,8 +21,12 @@
 #include <linux/dma-mapping.h>
 #include <linux/of.h>
 #include <linux/of_dma.h>
+#include <linux/of_platform.h>
 #include <linux/acpi.h>
 #include <linux/acpi_dma.h>
+#ifdef CONFIG_ARCH_RZN1
+#include <linux/sysctrl-rzn1.h>
+#endif
 
 #include "internal.h"
 
@@ -156,6 +160,48 @@ static inline void dw_dma_acpi_controller_register(struct dw_dma *dw) {}
 }
 #endif
 
+#ifdef CONFIG_ARCH_RZN1
+static int rzn1_dma_init(struct dw_dma_chip *chip)
+{
+	struct device *dev = chip->dev;
+	struct device_node *node = dev->of_node;
+	u32 dmamux;
+	u32 dmamux_mask;
+	u32 val;
+
+	if (of_property_read_u32(node, "rzn1_cfg_dmamux", &dmamux)) {
+		dev_err(dev, "%s missing rzn1_cfg_dmamux property\n",
+			node->full_name);
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32(node, "rzn1_cfg_dmamux_mask", &dmamux_mask)) {
+		dev_err(dev, "%s missing rzn1_cfg_dmamux_mask property\n",
+			node->full_name);
+		return -EINVAL;
+	}
+
+	val = rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_CFG_DMAMUX);
+	val &= ~dmamux_mask;
+	val |= dmamux;
+	rzn1_sysctrl_writel(val, RZN1_SYSCTRL_REG_CFG_DMAMUX);
+
+	dev_info(dev, "RZ/N1 init cfg_dmamux=0x%x\n", val);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_OF
+static const struct of_device_id dw_dma_of_id_table[] = {
+	{ .compatible = "snps,dma-spear1340" },
+#ifdef CONFIG_ARCH_RZN1
+	{ .compatible = "snps,dma-rzn1", .data = rzn1_dma_init },
+#endif
+	{}
+};
+MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
+#endif
+
 static int dw_probe(struct platform_device *pdev)
 {
 	struct dw_dma_chip *chip;
@@ -163,6 +209,8 @@ static int dw_probe(struct platform_device *pdev)
 	struct resource *mem;
 	const struct dw_dma_platform_data *pdata;
 	int err;
+	const struct of_device_id *of_id;
+	int (*hw_init_fn)(struct dw_dma_chip *);
 
 	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
 	if (!chip)
@@ -214,6 +262,16 @@ static int dw_probe(struct platform_device *pdev)
 	if (ACPI_HANDLE(&pdev->dev))
 		dw_dma_acpi_controller_register(chip->dw);
 
+	/* Custom setup */
+	of_id = of_match_device(dw_dma_of_id_table, chip->dev);
+	if (!of_id || !of_id->data)
+		return -EINVAL;
+	hw_init_fn = of_id->data;
+
+	err = hw_init_fn(chip);
+	if (err)
+		return -EINVAL;
+
 	return 0;
 
 err_dw_dma_probe:
@@ -256,14 +314,6 @@ static void dw_shutdown(struct platform_device *pdev)
 	clk_disable_unprepare(chip->clk);
 }
 
-#ifdef CONFIG_OF
-static const struct of_device_id dw_dma_of_id_table[] = {
-	{ .compatible = "snps,dma-spear1340" },
-	{}
-};
-MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
-#endif
-
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id dw_dma_acpi_id_table[] = {
 	{ "INTL9C60", 0 },
diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index 82d85cce..c1f5110 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -448,6 +448,13 @@ config EDAC_ALTERA_SDMMC
 	  Support for error detection and correction on the
 	  Altera SDMMC FIFO Memory for Altera SoCs.
 
+config EDAC_CADENCE_MC
+	tristate "Cadence Memory Controller"
+	depends on EDAC_MM_EDAC
+	help
+	  Support for error detection and correction on the
+	  Cadence DDR memory controller.
+
 config EDAC_SYNOPSYS
 	tristate "Synopsys DDR Memory Controller"
 	depends on EDAC_MM_EDAC && ARCH_ZYNQ
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index 88e472e..3088d76 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -75,5 +75,6 @@ obj-$(CONFIG_EDAC_OCTEON_LMC)		+= octeon_edac-lmc.o
 obj-$(CONFIG_EDAC_OCTEON_PCI)		+= octeon_edac-pci.o
 
 obj-$(CONFIG_EDAC_ALTERA)		+= altera_edac.o
+obj-$(CONFIG_EDAC_CADENCE_MC)		+= cadence_edac.o
 obj-$(CONFIG_EDAC_SYNOPSYS)		+= synopsys_edac.o
 obj-$(CONFIG_EDAC_XGENE)		+= xgene_edac.o
diff --git a/drivers/edac/cadence_edac.c b/drivers/edac/cadence_edac.c
new file mode 100644
index 0000000..75e94e7
--- /dev/null
+++ b/drivers/edac/cadence_edac.c
@@ -0,0 +1,283 @@
+/*
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ *
+ * Based on highbank edac driver:
+ * Copyright 2011-2012 Calxeda, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/ctype.h>
+#include <linux/edac.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/uaccess.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+/* DDR Controller Error Registers */
+#define CAD_DDR_DDR_CLASS		(00 * 4 + 1)	/* DENALI_CTL_00 */
+#define CAD_DDR_ECC_ENABLE		(36 * 4 + 2)	/* DENALI_CTL_36 */
+
+#define CAD_DDR_ECC_FWC			(36 * 4 + 3)	/* DENALI_CTL_36 */
+#define CAD_DDR_ECC_XOR			(37 * 4)	/* DENALI_CTL_37 */
+#define CAD_DDR_ECC_U_ERR_ADDR		(38 * 4)	/* DENALI_CTL_38 */
+#define CAD_DDR_ECC_U_ERR_STAT		(39 * 4)	/* DENALI_CTL_39 */
+#define CAD_DDR_ECC_U_ERR_DATA		(40 * 4)	/* DENALI_CTL_40 */
+#define CAD_DDR_ECC_C_ERR_ADDR		(41 * 4)	/* DENALI_CTL_41 */
+#define CAD_DDR_ECC_C_ERR_STAT		(42 * 4)	/* DENALI_CTL_42 */
+#define CAD_DDR_ECC_C_ERR_DATA		(43 * 4)	/* DENALI_CTL_43 */
+#define CAD_DDR_PORT_CMD_ERR_ADDR	(61 * 4)	/* DENALI_CTL_61 */
+#define CAD_DDR_PORT_CMD_ERR_SRC_ID	(62 * 4 + 0)	/* DENALI_CTL_62 */
+#define CAD_DDR_PORT_CMD_ERR_TYPE	(62 * 4 + 1)	/* DENALI_CTL_62 */
+
+/* DDR Controller Interrupt Registers */
+#define CAD_DDR_ECC_INT_STATUS		(56 * 4)	/* DENALI_CTL_56 */
+#define CAD_DDR_ECC_INT_ACK		(57 * 4)	/* DENALI_CTL_57 */
+#define CAD_DDR_ECC_INT_MASK		(58 * 4)	/* DENALI_CTL_58 */
+
+#define CAD_DDR_ECC_INT_STAT_CE		(1 << 3)
+#define CAD_DDR_ECC_INT_STAT_UE		(1 << 5)
+#define CAD_DDR_ECC_INT_STAT_PORT	(1 << 7)
+
+struct cad_mc_drvdata {
+	void __iomem *io_base;
+};
+
+static irqreturn_t cadence_mc_err_handler(int irq, void *dev_id)
+{
+	struct mem_ctl_info *mci = dev_id;
+	struct cad_mc_drvdata *drvdata = mci->pvt_info;
+	u32 status, err_addr;
+
+	/* Read the interrupt status register */
+	status = readl(drvdata->io_base + CAD_DDR_ECC_INT_STATUS);
+
+	if (status & CAD_DDR_ECC_INT_STAT_UE) {
+		u32 syndrome = readl(drvdata->io_base + CAD_DDR_ECC_U_ERR_STAT);
+
+		syndrome = syndrome & 0x7f;
+		err_addr = readl(drvdata->io_base + CAD_DDR_ECC_U_ERR_ADDR);
+		edac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,
+				     err_addr >> PAGE_SHIFT,
+				     err_addr & ~PAGE_MASK, syndrome,
+				     0, 0, -1,
+				     mci->ctl_name, "");
+	}
+	if (status & CAD_DDR_ECC_INT_STAT_CE) {
+		u32 syndrome = readl(drvdata->io_base + CAD_DDR_ECC_C_ERR_STAT);
+
+		syndrome = syndrome & 0x7f;
+		err_addr = readl(drvdata->io_base + CAD_DDR_ECC_C_ERR_ADDR);
+
+		// TODO scrub by reading 32-bit and write back?
+
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,
+				     err_addr >> PAGE_SHIFT,
+				     err_addr & ~PAGE_MASK, syndrome,
+				     0, 0, -1,
+				     mci->ctl_name, "");
+	}
+
+	if (status & CAD_DDR_ECC_INT_STAT_PORT) {
+		u32 addr = readl(drvdata->io_base + CAD_DDR_PORT_CMD_ERR_ADDR);
+		u8 type = readb(drvdata->io_base + CAD_DDR_PORT_CMD_ERR_TYPE);
+		u8 id = readb(drvdata->io_base + CAD_DDR_PORT_CMD_ERR_SRC_ID);
+
+		pr_warn("DDR protected at addr 0x%x, type 0x%x, id 0x%x\n",
+			addr, type, id);
+	}
+
+	/* clear the error, clears the interrupt */
+	writel(status, drvdata->io_base + CAD_DDR_ECC_INT_ACK);
+
+	return IRQ_HANDLED;
+}
+
+static void cadence_mc_err_inject(struct mem_ctl_info *mci, u16 synd)
+{
+	struct cad_mc_drvdata *pdata = mci->pvt_info;
+
+	writew(synd & 0x3fff, pdata->io_base + CAD_DDR_ECC_XOR);
+	writeb(1, pdata->io_base + CAD_DDR_ECC_FWC);
+}
+
+#define to_mci(k) container_of(k, struct mem_ctl_info, dev)
+
+static ssize_t cadence_mc_inject_ctrl(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mem_ctl_info *mci = to_mci(dev);
+	u16 synd;
+
+	if (kstrtou16(buf, 16, &synd))
+		return -EINVAL;
+
+	cadence_mc_err_inject(mci, synd);
+
+	return count;
+}
+
+static DEVICE_ATTR(inject_ctrl, S_IWUSR, NULL, cadence_mc_inject_ctrl);
+
+static struct of_device_id cad_ddr_ctrl_of_match[] = {
+	{ .compatible = "cadence,ddr-ctrl" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, cad_ddr_ctrl_of_match);
+
+static int cadence_mc_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *id;
+	struct edac_mc_layer layers[2];
+	struct mem_ctl_info *mci;
+	struct cad_mc_drvdata *drvdata;
+	struct dimm_info *dimm;
+	struct resource *r;
+	struct clk *clk;
+	u32 val;
+	int irq;
+	int res = 0;
+
+	id = of_match_device(cad_ddr_ctrl_of_match, &pdev->dev);
+	if (!id)
+		return -ENODEV;
+
+	layers[0].type = EDAC_MC_LAYER_CHIP_SELECT;
+	layers[0].size = 1;
+	layers[0].is_virt_csrow = true;
+	layers[1].type = EDAC_MC_LAYER_CHANNEL;
+	layers[1].size = 1;
+	layers[1].is_virt_csrow = false;
+	mci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,
+			    sizeof(struct cad_mc_drvdata));
+	if (!mci)
+		return -ENOMEM;
+
+	mci->pdev = &pdev->dev;
+	drvdata = mci->pvt_info;
+	platform_set_drvdata(pdev, mci);
+
+	if (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL))
+		return -ENOMEM;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "Unable to get mem resource\n");
+		res = -ENODEV;
+		goto err;
+	}
+
+	if (!devm_request_mem_region(&pdev->dev, r->start,
+				     resource_size(r), dev_name(&pdev->dev))) {
+		dev_err(&pdev->dev, "Error while requesting mem region\n");
+		res = -EBUSY;
+		goto err;
+	}
+
+	drvdata->io_base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
+	if (!drvdata->io_base) {
+		dev_err(&pdev->dev, "Unable to map regs\n");
+		res = -ENOMEM;
+		goto err;
+	}
+
+	/* If we have a clock, enable it - and keep hold on it */
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (!IS_ERR(clk))
+		clk_prepare_enable(clk);
+
+	val = readb(drvdata->io_base + CAD_DDR_ECC_ENABLE);
+	if (!val)
+		mci->edac_cap = EDAC_FLAG_NONE;
+	else
+		mci->edac_cap = EDAC_FLAG_SECDED;
+
+	mci->mtype_cap = MEM_FLAG_DDR2 | MEM_FLAG_DDR3;
+	mci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;
+	mci->mod_name = pdev->dev.driver->name;
+	mci->mod_ver = "1";
+	mci->ctl_name = id->compatible;
+	mci->dev_name = dev_name(&pdev->dev);
+	mci->scrub_mode = SCRUB_SW_SRC;
+
+	/* Only a single 256MB DIMM is supported */
+	dimm = *mci->dimms;
+	dimm->nr_pages = MiB_TO_PAGES(SZ_256M);
+	dimm->grain = 1;
+	dimm->dtype = DEV_X8;
+
+	val = readb(drvdata->io_base + CAD_DDR_DDR_CLASS);
+	if ((val & 0xf) == 4)
+		dimm->mtype = MEM_DDR2;
+	else
+		dimm->mtype = MEM_DDR3;
+	dimm->edac_mode = EDAC_SECDED;
+
+	res = edac_mc_add_mc(mci);
+	if (res < 0)
+		goto err;
+
+	/* Mask out all interrupts */
+	writel(0xfffff, drvdata->io_base + CAD_DDR_ECC_INT_MASK);
+
+	irq = platform_get_irq(pdev, 0);
+	res = devm_request_irq(&pdev->dev, irq, cadence_mc_err_handler,
+			       0, dev_name(&pdev->dev), mci);
+	if (res < 0) {
+		dev_err(&pdev->dev, "Unable to request irq %d\n", irq);
+		goto err2;
+	}
+
+	device_create_file(&mci->dev, &dev_attr_inject_ctrl);
+
+	devres_close_group(&pdev->dev, NULL);
+
+	/* Enable ECC error and port protection interrupts */
+	writel(~(CAD_DDR_ECC_INT_STAT_CE | CAD_DDR_ECC_INT_STAT_UE |
+			CAD_DDR_ECC_INT_STAT_PORT) & 0xfffff,
+	       drvdata->io_base + CAD_DDR_ECC_INT_MASK);
+
+	dev_info(&pdev->dev, "DDR EDAC (Error Detection And Correction): ECC %s\n",
+		(mci->edac_cap == EDAC_FLAG_NONE) ? "Disabled" : "Enabled");
+
+	return 0;
+err2:
+	edac_mc_del_mc(&pdev->dev);
+err:
+	devres_release_group(&pdev->dev, NULL);
+	edac_mc_free(mci);
+	return res;
+}
+
+static int cadence_mc_remove(struct platform_device *pdev)
+{
+	struct mem_ctl_info *mci = platform_get_drvdata(pdev);
+
+	device_remove_file(&mci->dev, &dev_attr_inject_ctrl);
+	edac_mc_del_mc(&pdev->dev);
+	edac_mc_free(mci);
+	return 0;
+}
+
+static struct platform_driver cadence_mc_edac_driver = {
+	.probe = cadence_mc_probe,
+	.remove = cadence_mc_remove,
+	.driver = {
+		.name = "cadence_mc_edac",
+		.of_match_table = cad_ddr_ctrl_of_match,
+	},
+};
+
+module_platform_driver(cadence_mc_edac_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Renesas Electronics Europe Ltd.");
+MODULE_DESCRIPTION("EDAC Driver for Cadence DDR Controller");
diff --git a/drivers/gpio/gpio-dwapb.c b/drivers/gpio/gpio-dwapb.c
index 6193f62..40e3d0f 100644
--- a/drivers/gpio/gpio-dwapb.c
+++ b/drivers/gpio/gpio-dwapb.c
@@ -27,6 +27,7 @@
 #include <linux/spinlock.h>
 #include <linux/platform_data/gpio-dwapb.h>
 #include <linux/slab.h>
+#include <linux/clk.h>
 
 #include "gpiolib.h"
 
@@ -528,6 +529,7 @@ static int dwapb_gpio_probe(struct platform_device *pdev)
 	int err;
 	struct device *dev = &pdev->dev;
 	struct dwapb_platform_data *pdata = dev_get_platdata(dev);
+	struct clk *clk;
 
 	if (!pdata) {
 		pdata = dwapb_gpio_get_pdata(dev);
@@ -555,6 +557,10 @@ static int dwapb_gpio_probe(struct platform_device *pdev)
 	if (IS_ERR(gpio->regs))
 		return PTR_ERR(gpio->regs);
 
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (!IS_ERR(clk) && clk_prepare_enable(clk))
+		dev_info(&pdev->dev, "no clock source\n");
+
 	for (i = 0; i < gpio->nr_ports; i++) {
 		err = dwapb_gpio_add_port(gpio, &pdata->properties[i], i);
 		if (err)
diff --git a/drivers/mailbox/pl320-ipc.c b/drivers/mailbox/pl320-ipc.c
index 2dbed87..c887ce5 100644
--- a/drivers/mailbox/pl320-ipc.c
+++ b/drivers/mailbox/pl320-ipc.c
@@ -37,6 +37,9 @@
 #define IPCMxMCLEAR(m)		(((m) * 0x40) + 0x018)
 #define IPCMxMSTATUS(m)		(((m) * 0x40) + 0x01C)
 #define IPCMxSEND(m)		(((m) * 0x40) + 0x020)
+ #define IPCMxSEND_FREE         0
+ #define IPCMxSEND_SEND		BIT(0)
+ #define IPCMxSEND_ACK		BIT(1)
 #define IPCMxDR(m, dr)		(((m) * 0x40) + ((dr) * 4) + 0x024)
 
 #define IPCMMIS(irq)		(((irq) * 8) + 0x800)
@@ -44,7 +47,7 @@
 
 #define MBOX_MASK(n)		(1 << (n))
 #define IPC_TX_MBOX		1
-#define IPC_RX_MBOX		2
+#define IPC_RX_MBOX		0
 
 #define CHAN_MASK(n)		(1 << (n))
 #define A9_SOURCE		1
@@ -53,7 +56,6 @@
 static void __iomem *ipc_base;
 static int ipc_irq;
 static DEFINE_MUTEX(ipc_m1_lock);
-static DECLARE_COMPLETION(ipc_completion);
 static ATOMIC_NOTIFIER_HEAD(ipc_notifier);
 
 static inline void set_destination(int source, int mbox)
@@ -73,7 +75,7 @@ static void __ipc_send(int mbox, u32 *data)
 	int i;
 	for (i = 0; i < 7; i++)
 		writel_relaxed(data[i], ipc_base + IPCMxDR(mbox, i));
-	writel_relaxed(0x1, ipc_base + IPCMxSEND(mbox));
+	writel_relaxed(IPCMxSEND_SEND, ipc_base + IPCMxSEND(mbox));
 }
 
 static u32 __ipc_rcv(int mbox, u32 *data)
@@ -81,26 +83,28 @@ static u32 __ipc_rcv(int mbox, u32 *data)
 	int i;
 	for (i = 0; i < 7; i++)
 		data[i] = readl_relaxed(ipc_base + IPCMxDR(mbox, i));
-	return data[1];
+	return data[0];
 }
 
-/* blocking implmentation from the A9 side, not usuable in interrupts! */
 int pl320_ipc_transmit(u32 *data)
 {
-	int ret;
+	int ret = 0;
+	u32 mxsend;
+
+	if (ipc_base == NULL)
+		return -ENODEV;
 
 	mutex_lock(&ipc_m1_lock);
 
-	init_completion(&ipc_completion);
-	__ipc_send(IPC_TX_MBOX, data);
-	ret = wait_for_completion_timeout(&ipc_completion,
-					  msecs_to_jiffies(1000));
-	if (ret == 0) {
-		ret = -ETIMEDOUT;
+	/* Are we waiting for the last message to be acked? */
+	mxsend = __raw_readl(ipc_base + IPCMxSEND(IPC_TX_MBOX));
+	if (!(mxsend & IPCMxSEND_ACK) && (mxsend & IPCMxSEND_SEND)) {
+		ret = -EBUSY;
 		goto out;
 	}
 
-	ret = __ipc_rcv(IPC_TX_MBOX, data);
+	__ipc_send(IPC_TX_MBOX, data);
+
 out:
 	mutex_unlock(&ipc_m1_lock);
 	return ret;
@@ -112,15 +116,11 @@ static irqreturn_t ipc_handler(int irq, void *dev)
 	u32 irq_stat;
 	u32 data[7];
 
-	irq_stat = readl_relaxed(ipc_base + IPCMMIS(1));
-	if (irq_stat & MBOX_MASK(IPC_TX_MBOX)) {
-		writel_relaxed(0, ipc_base + IPCMxSEND(IPC_TX_MBOX));
-		complete(&ipc_completion);
-	}
+	irq_stat = readl_relaxed(ipc_base + IPCMMIS(A9_SOURCE));
 	if (irq_stat & MBOX_MASK(IPC_RX_MBOX)) {
 		__ipc_rcv(IPC_RX_MBOX, data);
 		atomic_notifier_call_chain(&ipc_notifier, data[0], data + 1);
-		writel_relaxed(2, ipc_base + IPCMxSEND(IPC_RX_MBOX));
+		writel_relaxed(IPCMxSEND_FREE, ipc_base + IPCMxSEND(IPC_RX_MBOX));
 	}
 
 	return IRQ_HANDLED;
@@ -158,7 +158,7 @@ static int pl320_probe(struct amba_device *adev, const struct amba_id *id)
 		       ipc_base + IPCMxSOURCE(IPC_TX_MBOX));
 	writel_relaxed(CHAN_MASK(M3_SOURCE),
 		       ipc_base + IPCMxDSET(IPC_TX_MBOX));
-	writel_relaxed(CHAN_MASK(M3_SOURCE) | CHAN_MASK(A9_SOURCE),
+	writel_relaxed(CHAN_MASK(M3_SOURCE),
 		       ipc_base + IPCMxMSET(IPC_TX_MBOX));
 
 	/* Init receive mailbox */
@@ -166,7 +166,7 @@ static int pl320_probe(struct amba_device *adev, const struct amba_id *id)
 		       ipc_base + IPCMxSOURCE(IPC_RX_MBOX));
 	writel_relaxed(CHAN_MASK(A9_SOURCE),
 		       ipc_base + IPCMxDSET(IPC_RX_MBOX));
-	writel_relaxed(CHAN_MASK(M3_SOURCE) | CHAN_MASK(A9_SOURCE),
+	writel_relaxed(CHAN_MASK(A9_SOURCE),
 		       ipc_base + IPCMxMSET(IPC_RX_MBOX));
 
 	return 0;
diff --git a/drivers/misc/eeprom/Kconfig b/drivers/misc/eeprom/Kconfig
index c4e41c2..40da55f 100644
--- a/drivers/misc/eeprom/Kconfig
+++ b/drivers/misc/eeprom/Kconfig
@@ -29,11 +29,12 @@ config EEPROM_AT24
 	  will be called at24.
 
 config EEPROM_AT25
-	tristate "SPI EEPROMs from most vendors"
+	tristate "SPI EEPROMs/FRAMs from most vendors"
 	depends on SPI && SYSFS
 	select NVMEM
 	help
-	  Enable this driver to get read/write support to most SPI EEPROMs,
+	  Enable this driver to get read/write support to most SPI EEPROMs
+	  and Cypress FRAMs,
 	  after you configure the board init code to know about each eeprom
 	  on your target board.
 
diff --git a/drivers/misc/eeprom/at25.c b/drivers/misc/eeprom/at25.c
index 5afe4cd..ef34518 100644
--- a/drivers/misc/eeprom/at25.c
+++ b/drivers/misc/eeprom/at25.c
@@ -1,7 +1,9 @@
 /*
  * at25.c -- support most SPI EEPROMs, such as Atmel AT25 models
+ *           and Cypress FRAMs FM25 models
  *
  * Copyright (C) 2006 David Brownell
+ *               2014 Jiri Prchal
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,6 +16,7 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/device.h>
+#include <linux/of_device.h>
 #include <linux/sched.h>
 
 #include <linux/nvmem-provider.h>
@@ -35,6 +38,7 @@ struct at25_data {
 	unsigned		addrlen;
 	struct nvmem_config	nvmem_config;
 	struct nvmem_device	*nvmem;
+	int			has_sernum;
 };
 
 #define	AT25_WREN	0x06		/* latch the write enable */
@@ -43,6 +47,9 @@ struct at25_data {
 #define	AT25_WRSR	0x01		/* write status register */
 #define	AT25_READ	0x03		/* read byte(s) */
 #define	AT25_WRITE	0x02		/* write byte(s)/sector */
+#define	FM25_SLEEP	0xb9		/* enter sleep mode */
+#define	FM25_RDID	0x9f		/* read device ID */
+#define	FM25_RDSN	0xc3		/* read S/N */
 
 #define	AT25_SR_nRDY	0x01		/* nRDY = write-in-progress */
 #define	AT25_SR_WEN	0x02		/* write enable (latched) */
@@ -52,6 +59,9 @@ struct at25_data {
 
 #define	AT25_INSTR_BIT3	0x08		/* Additional address bit in instr */
 
+#define	FM25_ID_LEN	9		/* ID length */
+#define	FM25_SN_LEN	8		/* serial number length */
+
 #define EE_MAXADDRLEN	3		/* 24 bit addresses, up to 2 MBytes */
 
 /* Specs often allow 5 msec for a page write, sometimes 20 msec;
@@ -59,10 +69,84 @@ struct at25_data {
  */
 #define	EE_TIMEOUT	25
 
+#define	IS_EEPROM	0
+#define	IS_FRAM		1
+
 /*-------------------------------------------------------------------------*/
 
 #define	io_limit	PAGE_SIZE	/* bytes */
 
+static ssize_t
+fm25_id_read(struct spi_device *spi, char *buf)
+{
+	u8			command = FM25_RDID;
+	ssize_t			status;
+	struct spi_transfer	t[2];
+	struct spi_message	m;
+
+	spi_message_init(&m);
+	memset(t, 0, sizeof t);
+
+	t[0].tx_buf = &command;
+	t[0].len = 1;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = buf;
+	t[1].len = FM25_ID_LEN;
+	spi_message_add_tail(&t[1], &m);
+
+	status = spi_sync(spi, &m);
+	dev_dbg(&spi->dev,
+		"read %Zd bytes of ID --> %d\n",
+		FM25_ID_LEN, (int) status);
+
+	return status ? status : FM25_ID_LEN;
+}
+
+static ssize_t
+fm25_sernum_read(struct spi_device *spi, char *buf)
+{
+	u8			command = FM25_RDSN;
+	ssize_t			status;
+	struct spi_transfer	t[2];
+	struct spi_message	m;
+
+	spi_message_init(&m);
+	memset(t, 0, sizeof t);
+
+	t[0].tx_buf = &command;
+	t[0].len = 1;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].rx_buf = buf;
+	t[1].len = FM25_SN_LEN;
+	spi_message_add_tail(&t[1], &m);
+
+	status = spi_sync(spi, &m);
+	dev_dbg(&spi->dev,
+		"read %Zd bytes of serial number --> %d\n",
+		FM25_SN_LEN, (int) status);
+
+	return status ? status : FM25_SN_LEN;
+}
+
+static ssize_t
+sernum_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	char			binbuf[FM25_SN_LEN];
+	struct at25_data	*at25;
+	int			i;
+	char			*pbuf = buf;
+
+	at25 = dev_get_drvdata(dev);
+	fm25_sernum_read(at25->spi, binbuf);
+	for (i = 0; i < FM25_SN_LEN; i++)
+		pbuf += sprintf(pbuf, "%02x ", binbuf[i]);
+	sprintf(--pbuf, "\n");
+	return (3 * i);
+}
+static const DEVICE_ATTR_RO(sernum);
+
 static int at25_ee_read(void *priv, unsigned int offset,
 			void *val, size_t count)
 {
@@ -244,13 +328,19 @@ static int at25_ee_write(void *priv, unsigned int off, void *val, size_t count)
 
 /*-------------------------------------------------------------------------*/
 
-static int at25_fw_to_chip(struct device *dev, struct spi_eeprom *chip)
+static int at25_fw_to_chip(struct device *dev, struct spi_eeprom *chip, int is_fram)
 {
 	u32 val;
 
 	memset(chip, 0, sizeof(*chip));
 	strncpy(chip->name, "at25", sizeof(chip->name));
 
+	if (is_fram) {
+		if (of_find_property(dev->of_node, "read-only", NULL))
+			chip->flags |= EE_READONLY;
+		return 0;
+	}
+
 	if (device_property_read_u32(dev, "size", &val) == 0 ||
 	    device_property_read_u32(dev, "at25,byte-len", &val) == 0) {
 		chip->byte_len = val;
@@ -297,6 +387,13 @@ static int at25_fw_to_chip(struct device *dev, struct spi_eeprom *chip)
 	return 0;
 }
 
+static const struct of_device_id at25_of_match[] = {
+	{ .compatible = "atmel,at25", .data = (const void *)IS_EEPROM },
+	{ .compatible = "cypress,fm25", .data = (const void *)IS_FRAM },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, at25_of_match);
+
 static int at25_probe(struct spi_device *spi)
 {
 	struct at25_data	*at25 = NULL;
@@ -304,27 +401,23 @@ static int at25_probe(struct spi_device *spi)
 	int			err;
 	int			sr;
 	int			addrlen;
+	char			id[FM25_ID_LEN];
+	const struct of_device_id *of_dev_id;
+	int			is_fram = 0;
+
+	of_dev_id = of_match_device(at25_of_match, &spi->dev);
+	if (!of_dev_id)
+		return -ENODEV;
+	is_fram = (int)of_dev_id->data;
 
 	/* Chip description */
 	if (!spi->dev.platform_data) {
-		err = at25_fw_to_chip(&spi->dev, &chip);
+		err = at25_fw_to_chip(&spi->dev, &chip, is_fram);
 		if (err)
 			return err;
 	} else
 		chip = *(struct spi_eeprom *)spi->dev.platform_data;
 
-	/* For now we only support 8/16/24 bit addressing */
-	if (chip.flags & EE_ADDR1)
-		addrlen = 1;
-	else if (chip.flags & EE_ADDR2)
-		addrlen = 2;
-	else if (chip.flags & EE_ADDR3)
-		addrlen = 3;
-	else {
-		dev_dbg(&spi->dev, "unsupported address type\n");
-		return -EINVAL;
-	}
-
 	/* Ping the chip ... the status register is pretty portable,
 	 * unlike probing manufacturer IDs.  We do expect that system
 	 * firmware didn't write it in the past few milliseconds!
@@ -340,9 +433,68 @@ static int at25_probe(struct spi_device *spi)
 		return -ENOMEM;
 
 	mutex_init(&at25->lock);
-	at25->chip = chip;
 	at25->spi = spi;
 	spi_set_drvdata(spi, at25);
+
+	if (is_fram) {
+		/* Get ID of chip */
+		fm25_id_read(spi, id);
+		if (id[6] != 0xc2) {
+			dev_err(&spi->dev,
+				"Error: no Cypress FRAM (id %02x)\n", id[6]);
+			return -ENODEV;
+		}
+		/* set size found in ID */
+		switch (id[7]) {
+			case 0x21:
+				chip.byte_len = 16 * 1024;
+				break;
+			case 0x22:
+				chip.byte_len = 32 * 1024;
+				break;
+			case 0x23:
+				chip.byte_len = 64 * 1024;
+				break;
+			case 0x24:
+				chip.byte_len = 128 * 1024;
+				break;
+			case 0x25:
+				chip.byte_len = 256 * 1024;
+				break;
+			default:
+				dev_err(&spi->dev,
+					"Error: unsupported size (id %02x)\n",
+					id[7]);
+				return -ENODEV;
+				break;
+		}
+
+		if (chip.byte_len > 64 * 1024)
+			chip.flags |= EE_ADDR3;
+		else
+			chip.flags |= EE_ADDR2;
+
+		if (id[8])
+			at25->has_sernum = 1;
+		else
+			at25->has_sernum = 0;
+
+		chip.page_size = PAGE_SIZE;
+	}
+
+	/* For now we only support 8/16/24 bit addressing */
+	if (chip.flags & EE_ADDR1)
+		addrlen = 1;
+	else if (chip.flags & EE_ADDR2)
+		addrlen = 2;
+	else if (chip.flags & EE_ADDR3)
+		addrlen = 3;
+	else {
+		dev_dbg(&spi->dev, "unsupported address type\n");
+		return -EINVAL;
+	}
+
+	at25->chip = chip;
 	at25->addrlen = addrlen;
 
 	at25->nvmem_config.name = dev_name(&spi->dev);
@@ -359,14 +511,22 @@ static int at25_probe(struct spi_device *spi)
 	at25->nvmem_config.word_size = 1;
 	at25->nvmem_config.size = chip.byte_len;
 
+	/* Export the FM25 serial number */
+	if (at25->has_sernum) {
+		err = device_create_file(&spi->dev, &dev_attr_sernum);
+		if (err)
+			return err;
+	}
+
 	at25->nvmem = nvmem_register(&at25->nvmem_config);
 	if (IS_ERR(at25->nvmem))
 		return PTR_ERR(at25->nvmem);
 
-	dev_info(&spi->dev, "%d %s %s eeprom%s, pagesize %u\n",
+	dev_info(&spi->dev, "%d %s %s %s%s, pagesize %u\n",
 		(chip.byte_len < 1024) ? chip.byte_len : (chip.byte_len / 1024),
 		(chip.byte_len < 1024) ? "Byte" : "KByte",
 		at25->chip.name,
+		is_fram ? "fram" : "eeprom",
 		(chip.flags & EE_READONLY) ? " (readonly)" : "",
 		at25->chip.page_size);
 	return 0;
@@ -384,12 +544,6 @@ static int at25_remove(struct spi_device *spi)
 
 /*-------------------------------------------------------------------------*/
 
-static const struct of_device_id at25_of_match[] = {
-	{ .compatible = "atmel,at25", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, at25_of_match);
-
 static struct spi_driver at25_driver = {
 	.driver = {
 		.name		= "at25",
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 7b7a887..0b6312d 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -295,6 +295,12 @@ config MTD_NAND_DOCG4
 	  by the block containing the saftl partition table.  This is probably
 	  typical.
 
+config MTD_NAND_EVATRONIX
+	tristate "Enable Evatronix NANDFLASH-CTRL driver"
+	help
+	  NAND hardware driver for Evatronix NANDFLASH-CTRL
+	  NAND flash controller.
+
 config MTD_NAND_SHARPSL
 	tristate "Support for NAND Flash on Sharp SL Series (C7xx + others)"
 	depends on ARCH_PXA
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index cafde6f..1dccc18 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
 obj-$(CONFIG_MTD_NAND_DAVINCI)		+= davinci_nand.o
 obj-$(CONFIG_MTD_NAND_DISKONCHIP)	+= diskonchip.o
 obj-$(CONFIG_MTD_NAND_DOCG4)		+= docg4.o
+obj-$(CONFIG_MTD_NAND_EVATRONIX)	+= evatronix_nand.o
 obj-$(CONFIG_MTD_NAND_FSMC)		+= fsmc_nand.o
 obj-$(CONFIG_MTD_NAND_SHARPSL)		+= sharpsl.o
 obj-$(CONFIG_MTD_NAND_NANDSIM)		+= nandsim.o
diff --git a/drivers/mtd/nand/evatronix_nand.c b/drivers/mtd/nand/evatronix_nand.c
new file mode 100644
index 0000000..12287bc
--- /dev/null
+++ b/drivers/mtd/nand/evatronix_nand.c
@@ -0,0 +1,2055 @@
+/*
+ * evatronix_nand.c - NAND Flash Driver for Evatronix NANDFLASH-CTRL
+ * NAND Flash Controller IP.
+ *
+ * Intended to handle one NFC, with up to two connected NAND flash chips,
+ * one per bank.
+ *
+ * This implementation has been designed against Rev 1.15 and Rev 1.16 of the
+ * NANDFLASH-CTRL Design Specification.
+ * Note that Rev 1.15 specifies up to 8 chip selects, whereas Rev 1.16
+ * only specifies one. We keep the definitions for the multiple chip
+ * selects though for future reference.
+ *
+ * The corresponding IP version is NANDFLASH-CTRL-DES-6V09H02RE08 .
+ *
+ * Copyright (c) 2016 Axis Communication AB, Lund, Sweden.
+ * Portions Copyright (c) 2010 ST Microelectronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/dma.h>
+#include <linux/bitops.h> /* for ffs() */
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/concat.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+
+/* Driver configuration */
+
+/* Some of this could potentially be moved to DT, but it represents stuff
+ * that is either untested, only used for debugging, or things we really
+ * don't want anyone to change, so we keep it here until a clear use case
+ * emerges.
+ */
+
+#undef NFC_DMA64BIT /* NFC hardware support for 64-bit DMA transfers */
+
+#undef POLLED_XFERS /* Use polled rather than interrupt based transfers */
+
+#undef CLEAR_DMA_BUF_AFTER_WRITE /* Useful for debugging */
+
+/* DMA buffer for page transfers. */
+#define DMA_BUF_SIZE (8192 + 640) /* main + spare for 8k page flash */
+
+/* # bytes into the OOB we put our ECC */
+#define ECC_OFFSET 2
+
+/* Number of bytes that we read using READID command.
+ * When reading IDs the IP requires us set up the number of bytes to read
+ * prior to executing the operation, whereas the NAND subsystem would rather
+ * like us to be able to read one byte at a time from the chip. So we fake
+ * this by reading a set number of ID bytes, and then let the NAND subsystem
+ * read from our DMA buffer.
+ */
+#define READID_LENGTH 8
+
+/* Debugging */
+
+#define MTD_TRACE(FORMAT, ...) pr_debug("%s: " FORMAT, __func__, ## __VA_ARGS__)
+
+/* Register offsets for Evatronix NANDFLASH-CTRL IP */
+
+/* Register field shift values and masks are interespersed as it makes
+ * them easier to locate.
+ *
+ * We use shift values rather than direct masks (e.g. 0x0000d000), as the
+ * hardware manual lists the bit number, making the definitions below
+ * easier to verify against the manual.
+ *
+ * All (known) registers are here, but we only put in the bit fields
+ * for the fields we need.
+ *
+ * We try to be consistent regarding _SIZE/_MASK/_value macros so as to
+ * get a consistent layout here, except for trivial cases where there is
+ * only a single bit or field in a register at bit offset 0.
+ */
+
+#define COMMAND_REG		0x00
+/* The masks reflect the input data to the MAKE_COMMAND macro, rather than
+ * the bits in the register itself. These macros are not intended to be
+ * used by the user, who should use the MAKE_COMMAND et al macros.
+ */
+#define _CMD_SEQ_SHIFT			0
+#define _INPUT_SEL_SHIFT		6
+#define _DATA_SEL_SHIFT			7
+#define _CMD_0_SHIFT			8
+#define _CMD_1_3_SHIFT			16
+#define _CMD_2_SHIFT			24
+
+#define _CMD_SEQ_MASK			0x3f
+#define _INPUT_SEL_MASK			1
+#define _DATA_SEL_MASK			1
+#define _CMD_MASK			0xff /* for all CMD_foo */
+
+#define MAKE_COMMAND(CMD_SEQ, INPUT_SEL, DATA_SEL, CMD_0, CMD_1_3, CMD_2) \
+	((((CMD_SEQ)	& _CMD_SEQ_MASK)	<< _CMD_SEQ_SHIFT)	| \
+	 (((INPUT_SEL)	& _INPUT_SEL_MASK)	<< _INPUT_SEL_SHIFT)	| \
+	 (((DATA_SEL)	& _DATA_SEL_MASK)	<< _DATA_SEL_SHIFT)	| \
+	 (((CMD_0)	& _CMD_MASK)		<< _CMD_0_SHIFT)	| \
+	 (((CMD_1_3)	& _CMD_MASK)		<< _CMD_1_3_SHIFT)	| \
+	 (((CMD_2)	& _CMD_MASK)		<< _CMD_2_SHIFT))
+
+#define INPUT_SEL_SIU			0
+#define INPUT_SEL_DMA			1
+#define DATA_SEL_FIFO			0
+#define DATA_SEL_DATA_REG		1
+
+#define CONTROL_REG		0x04
+#define CONTROL_BLOCK_SIZE_32		(0 << 6)
+#define CONTROL_BLOCK_SIZE_64		(1 << 6)
+#define CONTROL_BLOCK_SIZE_128		(2 << 6)
+#define CONTROL_BLOCK_SIZE_256		(3 << 6)
+#define CONTROL_BLOCK_SIZE(SIZE)	((ffs(SIZE) - 6) << 6)
+#define CONTROL_ECC_EN			(1 << 5)
+#define CONTROL_INT_EN			(1 << 4)
+#define CONTROL_ECC_BLOCK_SIZE_256	(0 << 1)
+#define CONTROL_ECC_BLOCK_SIZE_512	(1 << 1)
+#define CONTROL_ECC_BLOCK_SIZE_1024	(2 << 1)
+#define CONTROL_ECC_BLOCK_SIZE(SIZE)	((ffs(SIZE) - 9) << 1)
+#define STATUS_REG		0x08
+#define STATUS_MEM_ST(CS)		(1 << (CS))
+#define STATUS_CTRL_STAT		(1 << 8)
+#define STATUS_MASK_REG		0x0C
+#define STATE_MASK_SHIFT		0
+#define STATUS_MASK_STATE_MASK(MASK)	(((MASK) & 0xff) << STATE_MASK_SHIFT)
+#define ERROR_MASK_SHIFT		8
+#define STATUS_MASK_ERROR_MASK(MASK)	(((MASK) & 0xff) << ERROR_MASK_SHIFT)
+#define INT_MASK_REG		0x10
+#define INT_MASK_ECC_INT_EN(CS)		(1 << (24 + (CS)))
+#define INT_MASK_STAT_ERR_INT_EN(CS)	(1 << (16 + (CS)))
+#define INT_MASK_MEM_RDY_INT_EN(CS)	(1 << (8 + (CS)))
+#define INT_MASK_DMA_INT_EN		(1 << 3)
+#define INT_MASK_DATA_REG_EN		(1 << 2)
+#define INT_MASK_CMD_END_INT_EN		(1 << 1)
+#define INT_STATUS_REG		0x14
+#define INT_STATUS_ECC_INT_FL(CS)	(1 << (24 + (CS)))
+#define INT_STATUS_STAT_ERR_INT_FL(CS)	(1 << (16 + (CS)))
+#define INT_STATUS_MEM_RDY_INT_FL(CS)	(1 << (8 + (CS)))
+#define INT_STATUS_DMA_INT_FL		(1 << 3)
+#define INT_STATUS_DATA_REG_FL		(1 << 2)
+#define INT_STATUS_CMD_END_INT_FL	(1 << 1)
+#define ECC_CTRL_REG		0x18
+#define ECC_CTRL_ECC_CAP_2		(0 << 0)
+#define ECC_CTRL_ECC_CAP_4		(1 << 0)
+#define ECC_CTRL_ECC_CAP_8		(2 << 0)
+#define ECC_CTRL_ECC_CAP_16		(3 << 0)
+#define ECC_CTRL_ECC_CAP_24		(4 << 0)
+#define ECC_CTRL_ECC_CAP_32		(5 << 0)
+#define ECC_CTRL_ECC_CAP(B)		((B) < 24 ? ffs(B) - 2 : (B) / 6)
+/* # ECC corrections that are acceptable during read before setting OVER flag */
+#define ECC_CTRL_ECC_THRESHOLD(VAL)	(((VAL) & 0x3f) << 8)
+#define ECC_OFFSET_REG		0x1C
+#define ECC_STAT_REG		0x20
+/* Correctable error flag(s) */
+#define ECC_STAT_ERROR(CS)		(1 << (0 + (CS)))
+/* Uncorrectable error flag(s) */
+#define ECC_STAT_UNC(CS)		(1 << (8 + (CS)))
+/* Acceptable errors level overflow flag(s) */
+#define ECC_STAT_OVER(CS)		(1 << (16 + (CS)))
+#define ADDR0_COL_REG		0x24
+#define ADDR0_ROW_REG		0x28
+#define ADDR1_COL_REG		0x2C
+#define ADDR1_ROW_REG		0x30
+#define PROTECT_REG		0x34
+#define FIFO_DATA_REG		0x38
+#define DATA_REG_REG		0x3C
+#define DATA_REG_SIZE_REG	0x40
+#define DATA_REG_SIZE_DATA_REG_SIZE(SIZE) (((SIZE) - 1) & 3)
+#define DEV0_PTR_REG		0x44
+#define DEV1_PTR_REG		0x48
+#define DEV2_PTR_REG		0x4C
+#define DEV3_PTR_REG		0x50
+#define DEV4_PTR_REG		0x54
+#define DEV5_PTR_REG		0x58
+#define DEV6_PTR_REG		0x5C
+#define DEV7_PTR_REG		0x60
+#define DMA_ADDR_L_REG		0x64
+#define DMA_ADDR_H_REG		0x68
+#define DMA_CNT_REG		0x6C
+#define DMA_CTRL_REG		0x70
+#define DMA_CTRL_DMA_START		(1 << 7) /* start on command */
+#define DMA_CTRL_DMA_MODE_SG		(1 << 5) /* scatter/gather mode */
+#define DMA_CTRL_DMA_BURST_I_P_4	(0 << 2) /* incr. precise burst */
+#define DMA_CTRL_DMA_BURST_S_P_16	(1 << 2) /* stream precise burst */
+#define DMA_CTRL_DMA_BURST_SINGLE	(2 << 2) /* single transfer */
+#define DMA_CTRL_DMA_BURST_UNSPEC	(3 << 2) /* burst of unspec. length */
+#define DMA_CTRL_DMA_BURST_I_P_8	(4 << 2) /* incr. precise burst */
+#define DMA_CTRL_DMA_BURST_I_P_16	(5 << 2) /* incr. precise burst */
+#define DMA_CTRL_ERR_FLAG		(1 << 1) /* read only */
+#define DMA_CTRL_DMA_READY		(1 << 0) /* read only */
+#define BBM_CTRL_REG		0x74
+#define MEM_CTRL_REG		0x80
+#define MEM_CTRL_MEM_CE(CE)		(((CE) & 7) << 0)
+#define MEM_CTRL_BANK_SEL(BANK)		(((BANK) & 7) << 16)
+#define MEM_CTRL_MEM0_WR	BIT(8)
+#define DATA_SIZE_REG		0x84
+#define TIMINGS_ASYN_REG	0x88
+#define TIMINGS_SYN_REG		0x8C
+#define TIME_SEQ_0_REG		0x90
+#define TIME_SEQ_1_REG		0x94
+#define TIME_GEN_SEQ_0_REG	0x98
+#define TIME_GEN_SEQ_1_REG	0x9C
+#define TIME_GEN_SEQ_2_REG	0xA0
+#define FIFO_INIT_REG		0xB0
+#define FIFO_INIT_FIFO_INIT			1 /* Flush FIFO */
+#define FIFO_STATE_REG		0xB4
+#define FIFO_STATE_DF_W_EMPTY		(1 << 7)
+#define FIFO_STATE_DF_R_FULL		(1 << 6)
+#define FIFO_STATE_CF_ACCPT_W		(1 << 5)
+#define FIFO_STATE_CF_ACCPT_R		(1 << 4)
+#define FIFO_STATE_CF_FULL		(1 << 3)
+#define FIFO_STATE_CF_EMPTY		(1 << 2)
+#define FIFO_STATE_DF_W_FULL		(1 << 1)
+#define FIFO_STATE_DF_R_EMPTY		(1 << 0)
+#define GEN_SEQ_CTRL_REG	0xB8		/* aka GENERIC_SEQ_CTRL */
+#define _CMD0_EN_SHIFT			0
+#define _CMD1_EN_SHIFT			1
+#define _CMD2_EN_SHIFT			2
+#define _CMD3_EN_SHIFT			3
+#define _COL_A0_SHIFT			4
+#define _COL_A1_SHIFT			6
+#define _ROW_A0_SHIFT			8
+#define _ROW_A1_SHIFT			10
+#define _DATA_EN_SHIFT			12
+#define _DELAY_EN_SHIFT			13
+#define _IMD_SEQ_SHIFT			15
+#define _CMD3_SHIFT			16
+#define ECC_CNT_REG		0x14C
+#define ECC_CNT_ERR_LVL_MASK		0x3F
+
+#define _CMD0_EN_MASK			1
+#define _CMD1_EN_MASK			1
+#define _CMD2_EN_MASK			1
+#define _CMD3_EN_MASK			1
+#define _COL_A0_MASK			3
+#define _COL_A1_MASK			3
+#define _ROW_A0_MASK			3
+#define _ROW_A1_MASK			3
+#define _DATA_EN_MASK			1
+#define _DELAY_EN_MASK			3
+#define _IMD_SEQ_MASK			1
+#define _CMD3_MASK			0xff
+
+/* DELAY_EN field values, non-shifted */
+#define _BUSY_NONE			0
+#define _BUSY_0				1
+#define _BUSY_1				2
+
+/* Slightly confusingly, the DELAYx_EN fields enable BUSY phases. */
+#define MAKE_GEN_CMD(CMD0_EN, CMD1_EN, CMD2_EN, CMD3_EN, \
+		     COL_A0, ROW_A0, COL_A1, ROW_A1, \
+		     DATA_EN, BUSY_EN, IMMEDIATE_SEQ, CMD3) \
+	((((CMD0_EN)	& _CMD0_EN_MASK)	<< _CMD0_EN_SHIFT)	| \
+	 (((CMD1_EN)	& _CMD1_EN_MASK)	<< _CMD1_EN_SHIFT)	| \
+	 (((CMD2_EN)	& _CMD2_EN_MASK)	<< _CMD2_EN_SHIFT)	| \
+	 (((CMD3_EN)	& _CMD3_EN_MASK)	<< _CMD3_EN_SHIFT)	| \
+	 (((COL_A0)	& _COL_A0_MASK)		<< _COL_A0_SHIFT)	| \
+	 (((COL_A1)	& _COL_A1_MASK)		<< _COL_A1_SHIFT)	| \
+	 (((ROW_A0)	& _ROW_A0_MASK)		<< _ROW_A0_SHIFT)	| \
+	 (((ROW_A1)	& _ROW_A1_MASK)		<< _ROW_A1_SHIFT)	| \
+	 (((DATA_EN)	& _DATA_EN_MASK)	<< _DATA_EN_SHIFT)	| \
+	 (((BUSY_EN)	& _DELAY_EN_MASK)	<< _DELAY_EN_SHIFT)	| \
+	 (((IMMEDIATE_SEQ) & _IMD_SEQ_MASK)	<< _IMD_SEQ_SHIFT)	| \
+	 (((CMD3)	& _CMD3_MASK)		<< _CMD3_SHIFT))
+
+/* The sequence encodings are not trivial. The ones we use are listed here. */
+#define _SEQ_0			0x00 /* send one cmd, then wait for ready */
+#define _SEQ_1			0x21 /* send one cmd, one addr, fetch data */
+#define _SEQ_2			0x22 /* send one cmd, one addr, fetch data */
+#define _SEQ_4			0x24 /* single cycle write then read */
+#define _SEQ_10			0x2A /* read page */
+#define _SEQ_12			0x0C /* write page, don't wait for R/B */
+#define _SEQ_18			0x32 /* read page using general cycle */
+#define _SEQ_19			0x13 /* write page using general cycle */
+#define _SEQ_14			0x0E /* 3 address cycles, for block erase */
+
+#define MLUN_REG		0xBC
+#define DEV0_SIZE_REG		0xC0
+#define DEV1_SIZE_REG		0xC4
+#define DEV2_SIZE_REG		0xC8
+#define DEV3_SIZE_REG		0xCC
+#define DEV4_SIZE_REG		0xD0
+#define DEV5_SIZE_REG		0xD4
+#define DEV6_SIZE_REG		0xD8
+#define DEV7_SIZE_REG		0xDC
+#define SS_CCNT0_REG		0xE0
+#define SS_CCNT1_REG		0xE4
+#define SS_SCNT_REG		0xE8
+#define SS_ADDR_DEV_CTRL_REG	0xEC
+#define SS_CMD0_REG		0xF0
+#define SS_CMD1_REG		0xF4
+#define SS_CMD2_REG		0xF8
+#define SS_CMD3_REG		0xFC
+#define SS_ADDR_REG		0x100
+#define SS_MSEL_REG		0x104
+#define SS_REQ_REG		0x108
+#define SS_BRK_REG		0x10C
+#define DMA_TLVL_REG		0x114
+#define DMA_TLVL_MAX		0xFF
+#define AES_CTRL_REG		0x118
+#define AES_DATAW_REG		0x11C
+#define AES_SVECT_REG		0x120
+#define CMD_MARK_REG		0x124
+#define LUN_STATUS_0_REG	0x128
+#define LUN_STATUS_1_REG	0x12C
+#define TIMINGS_TOGGLE_REG	0x130
+#define TIME_GEN_SEQ_3_REG	0x134
+#define SQS_DELAY_REG		0x138
+#define CNE_MASK_REG		0x13C
+#define CNE_VAL_REG		0x140
+#define CNA_CTRL_REG		0x144
+#define INTERNAL_STATUS_REG	0x148
+#define ECC_CNT_REG		0x14C
+#define PARAM_REG_REG		0x150
+
+/* NAND flash command generation */
+
+/* NAND flash command codes */
+#define NAND_RESET		0xff
+#define NAND_READ_STATUS	0x70
+#define NAND_READ_ID		0x90
+#define NAND_READ_ID_ADDR_STD	0x00	/* address written to ADDR0_COL */
+#define NAND_READ_ID_ADDR_ONFI	0x20	/* address written to ADDR0_COL */
+#define NAND_READ_ID_ADDR_JEDEC	0x40	/* address written to ADDR0_COL */
+#define NAND_PARAM		0xEC
+#define NAND_PARAM_SIZE_MAX		768 /* bytes */
+#define NAND_PAGE_READ		0x00
+#define NAND_PAGE_READ_END	0x30
+#define NAND_BLOCK_ERASE	0x60
+#define NAND_BLOCK_ERASE_END	0xd0
+#define NAND_PAGE_WRITE		0x80
+#define NAND_PAGE_WRITE_END	0x10
+
+#define _DONT_CARE 0x00 /* When we don't have anything better to say */
+
+
+/* Assembled values for putting into COMMAND register */
+
+/* Reset NAND flash */
+
+/* Uses SEQ_0: non-directional sequence, single command, wait for ready */
+#define COMMAND_RESET \
+	MAKE_COMMAND(_SEQ_0, INPUT_SEL_SIU, DATA_SEL_FIFO, \
+		NAND_RESET, _DONT_CARE, _DONT_CARE)
+
+/* Read status */
+
+/* Uses SEQ_4: single command, then read data via DATA_REG */
+#define COMMAND_READ_STATUS \
+	MAKE_COMMAND(_SEQ_4, INPUT_SEL_SIU, DATA_SEL_DATA_REG, \
+		NAND_READ_STATUS, _DONT_CARE, _DONT_CARE)
+
+/* Read ID */
+
+/* Uses SEQ_1: single command, ADDR0_COL, then read data via FIFO */
+/* ADDR0_COL is set to NAND_READ_ID_ADDR_STD for non-ONFi, and
+ * NAND_READ_ID_ADDR_ONFI for ONFi.
+ * The controller reads 5 bytes in the non-ONFi case, and 4 bytes in the
+ * ONFi case, so the data reception (DMA or FIFO_REG) needs to be set up
+ * accordingly.
+ */
+#define COMMAND_READ_ID \
+	MAKE_COMMAND(_SEQ_1, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_READ_ID, _DONT_CARE, _DONT_CARE)
+
+#define COMMAND_PARAM \
+	MAKE_COMMAND(_SEQ_2, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PARAM, _DONT_CARE, _DONT_CARE)
+
+/* Page read via slave interface (FIFO_DATA register) */
+
+/* Standard 5-cycle read command, with 0x30 end-of-cycle marker */
+/* Uses SEQ_10: CMD0 + 5 address cycles + CMD2, read data */
+#define COMMAND_READ_PAGE_STD \
+	MAKE_COMMAND(_SEQ_10, INPUT_SEL_SIU, DATA_SEL_FIFO, \
+		NAND_PAGE_READ, _DONT_CARE, NAND_PAGE_READ_END)
+
+/* 4-cycle read command, together with GEN_SEQ_CTRL_READ_PAGE_4CYCLE */
+/* Uses SEQ_18 (generic command sequence, see GEN_SEQ_ECTRL_READ_PAGE_4CYCLE)):
+ * CMD0 + 2+2 address cycles + CMD2, read data
+ */
+#define COMMAND_READ_PAGE_GEN \
+	MAKE_COMMAND(_SEQ_18, INPUT_SEL_SIU, DATA_SEL_FIFO, \
+		NAND_PAGE_READ, _DONT_CARE, NAND_PAGE_READ_END)
+
+/* Page read via master interface (DMA) */
+
+/* Standard 5-cycle read command, with 0x30 end-of-cycle marker */
+/* Uses SEQ_10: CMD0 + 5 address cycles + CMD2, read data */
+#define COMMAND_READ_PAGE_DMA_STD \
+	MAKE_COMMAND(_SEQ_10, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PAGE_READ, _DONT_CARE, NAND_PAGE_READ_END)
+
+/* 4-cycle read command, together with GEN_SEQ_CTRL_READ_PAGE_4CYCLE */
+/* Uses SEQ_18 (generic command sequence, see GEN_SEQ_ECTRL_READ_PAGE_4CYCLE)):
+ * CMD0 + 2+2 address cycles + CMD2, read data
+ */
+#define COMMAND_READ_PAGE_DMA_GEN \
+	MAKE_COMMAND(_SEQ_18, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PAGE_READ, _DONT_CARE, NAND_PAGE_READ_END)
+
+/* Page write via master interface (DMA) */
+
+/* Uses SEQ_12: CMD0 + 5 address cycles + write data + CMD1 */
+#define COMMAND_WRITE_PAGE_DMA_STD \
+	MAKE_COMMAND(_SEQ_12, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PAGE_WRITE, NAND_PAGE_WRITE_END, _DONT_CARE)
+
+/* Uses SEQ_19: CMD0 + 4 address cycles + write data + CMD1 */
+#define COMMAND_WRITE_PAGE_DMA_GEN \
+	MAKE_COMMAND(_SEQ_19, INPUT_SEL_DMA, DATA_SEL_FIFO, \
+		NAND_PAGE_WRITE, NAND_PAGE_WRITE_END, _DONT_CARE)
+
+/* Block erase */
+
+/* Uses SEQ_14: CMD0 + 3 address cycles + CMD1 */
+#define COMMAND_BLOCK_ERASE \
+	MAKE_COMMAND(_SEQ_14, INPUT_SEL_SIU, DATA_SEL_FIFO, \
+		NAND_BLOCK_ERASE, NAND_BLOCK_ERASE_END, _DONT_CARE)
+
+/* Assembled values for putting into GEN_SEQ_CTRL register */
+
+/* General command sequence specification for 4 cycle PAGE_READ command */
+#define GEN_SEQ_CTRL_READ_PAGE_4CYCLE \
+	MAKE_GEN_CMD(1, 0, 1, 0,	/* enable command 0 and 2 phases */ \
+		     2, 2,		/* col A0 2 cycles, row A0 2 cycles */ \
+		     0, 0,		/* col A1, row A1 not used */ \
+		     1,			/* data phase enabled */ \
+		     _BUSY_0,		/* busy0 phase enabled */ \
+		     0,			/* immediate cmd execution disabled */ \
+		     _DONT_CARE)	/* command 3 code not needed */
+
+/* General command sequence specification for 4 cycle PAGE_PROGRAM command */
+#define GEN_SEQ_CTRL_WRITE_PAGE_4CYCLE \
+	MAKE_GEN_CMD(1, 1, 0, 0,	/* enable command 0 and 1 phases */ \
+		     2, 2,		/* col A0 2 cycles, row A0 2 cycles */ \
+		     0, 0,		/* col A1, row A1 not used */ \
+		     1,			/* data phase enabled */ \
+		     _BUSY_1,		/* busy1 phase enabled */ \
+		     0,			/* immediate cmd execution disabled */ \
+		     _DONT_CARE)	/* command 3 code not needed */
+
+/* BCH ECC size calculations. */
+/* From "Mr. NAND's Wild Ride: Warning: Suprises Ahead", by Robert Pierce,
+ * Denali Software Inc. 2009, table on page 5
+ */
+/* Use 8 bit correction as base. */
+#define ECC8_BYTES(BLKSIZE) (ffs(BLKSIZE) + 3)
+/* The following would be valid for 4..24 bits of correction. */
+#define ECC_BYTES_PACKED(CAP, BLKSIZE) ((ECC8_BYTES(BLKSIZE) * (CAP) + 7) / 8)
+/* Our hardware however requires more bytes than strictly necessary due to
+ * the internal design.
+ */
+#define ECC_BYTES(CAP, BLKSIZE) ((ECC8_BYTES(1024) * (CAP) + 7) / 8)
+
+/* Read modes */
+enum nfc_read_mode {
+	NFC_READ_STD, /* Standard page read with ECC */
+	NFC_READ_RAW, /* Raw mode read of main area without ECC */
+	NFC_READ_OOB, /* Read oob only (no ECC) */
+	NFC_READ_ALL  /* Read main+oob in raw mode (no ECC) */
+};
+
+/* Timing parameters, from DT */
+struct nfc_timings {
+	uint32_t time_seq_0;
+	uint32_t time_seq_1;
+	uint32_t timings_asyn;
+	uint32_t time_gen_seq_0;
+	uint32_t time_gen_seq_1;
+	uint32_t time_gen_seq_2;
+	uint32_t time_gen_seq_3;
+};
+
+/* Configuration, from DT */
+struct nfc_setup {
+	struct nfc_timings timings;
+	bool use_bank_select; /* CE selects 'bank' rather than 'chip' */
+	bool rb_wired_and;    /* Ready/busy wired AND rather than per-chip */
+	unsigned int oob_reserved;
+};
+
+/* DMA buffer, from both software (buf) and hardware (phys) perspective. */
+struct nfc_dma {
+	void *buf; /* mapped address */
+	dma_addr_t phys; /* physical address */
+	int bytes_left; /* how much data left to read from buffer? */
+	int buf_bytes; /* how much allocated data in the buffer? */
+	uint8_t *ptr; /* work pointer */
+};
+
+#ifndef POLLED_XFERS
+/* Interrupt management */
+struct nfc_irq {
+	int done; /* interrupt triggered, consequently we're done. */
+	uint32_t int_status; /* INT_STATUS at time of interrupt */
+	wait_queue_head_t wq; /* For waiting on controller interrupt */
+};
+#endif
+
+/* Information common to all chips, including the NANDFLASH-CTRL IP */
+struct nfc_info {
+	void __iomem *regbase;
+	unsigned long clk_rate;
+	struct device *dev;
+	struct nand_hw_control *controller;
+	struct nfc_setup *setup;
+	struct nfc_dma dma;
+#ifndef POLLED_XFERS
+	struct nfc_irq irq;
+#endif
+};
+
+/* Per-chip controller configuration */
+struct nfc_config {
+	uint32_t mem_ctrl;
+	uint32_t control;
+	uint32_t ecc_ctrl;
+	uint32_t mem_status_mask;
+	uint32_t cs;
+};
+
+/* Cache for info that we need to save across calls to nfc_command */
+struct nfc_cmd_cache {
+	unsigned int command;
+	int page;
+	int column;
+	int write_size;
+	int oob_required;
+	int write_raw;
+};
+
+/* Information for each physical NAND chip. */
+struct chip_info {
+	struct nand_chip chip;
+	struct nfc_cmd_cache cmd_cache;
+	struct nfc_config nfc_config;
+};
+
+/* What we tell mtd is an mtd_info actually is a complete chip_info */
+#define TO_CHIP_INFO(mtd) ((struct chip_info *)(mtd_to_nand(mtd)))
+
+/* This is a global pointer, as we only support one single instance of the NFC.
+ * For multiple instances, we would need to add nfc_info as a parameter to
+ * several functions, as well as adding it as a member of the chip_info struct.
+ * Since most likely a system would only have one NFC instance, we don't
+ * go all the way implementing that feature now.
+ */
+static struct nfc_info *nfc_info;
+
+/* The timing setup is expected to come via DT. We keep some default timings
+ * here for reference, based on a 100 MHz reference clock.
+ */
+
+static const struct nfc_timings default_mode0_pll_enabled = {
+	0x0d151533, 0x000b0515, 0x00000046,
+	0x00150000, 0x00000000, 0x00000005, 0x00000015 };
+
+/**** Utility routines. */
+
+/* Count the number of 0's in buff up to a max of max_bits */
+/* Used to determine how many bitflips there are in an allegedly erased block */
+static int count_zero_bits(uint8_t *buff, int size, int max_bits)
+{
+	int k, zero_bits = 0;
+
+	for (k = 0; k < size; k++) {
+		zero_bits += hweight8(~buff[k]);
+		if (zero_bits > max_bits)
+			break;
+	}
+
+	return zero_bits;
+}
+
+/**** Low level stuff. Read and write registers, interrupt routine, etc. */
+
+/* Read and write NFC SFR registers */
+
+static uint32_t nfc_read(uint reg_offset)
+{
+	return readl_relaxed(nfc_info->regbase + reg_offset);
+}
+
+static void nfc_write(uint32_t data, uint reg_offset)
+{
+	/* Note: According to NANDFLASH-CTRL Design Specification, rev 1.14,
+	 * p19, the NFC SFR's can only be written when STATUS.CTRL_STAT is 0.
+	 * However, this doesn't seem to be an issue in practice.
+	 */
+	writel_relaxed(data, nfc_info->regbase  + reg_offset);
+}
+
+#ifndef POLLED_XFERS
+static irqreturn_t nfc_irq(int irq, void *device_info)
+{
+	/* Note that device_info = nfc_info, so if we don't want a global
+	 * nfc_info we can get it via device_info.
+	 */
+
+	/* Save interrupt status in case caller wants to check what actually
+	 * happened.
+	 */
+	nfc_info->irq.int_status = nfc_read(INT_STATUS_REG);
+
+	MTD_TRACE("Got interrupt %d, INT_STATUS 0x%08x\n",
+		  irq, nfc_info->irq.int_status);
+
+	/* disable global NFC interrupt */
+	nfc_write(nfc_read(CONTROL_REG) & ~CONTROL_INT_EN, CONTROL_REG);
+
+	nfc_info->irq.done = 1;
+	wake_up(&nfc_info->irq.wq);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/* Get resources from platform: register bank mapping, irqs, etc */
+static int nfc_init_resources(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *resource;
+	struct clk *clk;
+#ifndef POLLED_XFERS
+	int irq;
+#endif
+	int res;
+
+	/* Register base for controller, ultimately from device tree */
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!resource) {
+		dev_err(dev, "No register addresses configured!\n");
+		return -ENOMEM;
+	}
+	nfc_info->regbase = devm_ioremap_resource(dev, resource);
+	if (IS_ERR(nfc_info->regbase))
+		return PTR_ERR(nfc_info->regbase);
+
+	dev_dbg(dev, "Got SFRs at phys %pR, mapped to %pa\n",
+		resource, nfc_info->regbase);
+
+	/* find the clocks */
+	clk = devm_clk_get(dev, "clka");
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+	res = clk_prepare_enable(clk);
+	if (res) {
+		dev_err(dev, "can not enable the NAND clka clock\n");
+		return res;
+	}
+
+	clk = devm_clk_get(dev, "clkb");
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+	res = clk_prepare_enable(clk);
+	if (res) {
+		dev_err(dev, "can not enable the NAND clkb clock\n");
+		return res;
+	}
+
+	res = clk_prepare_enable(clk);
+	if (res) {
+		dev_err(dev, "failed to enable clock\n");
+		return res;
+	}
+
+	nfc_info->clk_rate = clk_get_rate(clk);
+	if (nfc_info->clk_rate == 0) {
+		dev_err(dev, "NAND clock rate cannot be 0\n");
+		return -EIO;
+	}
+
+	/* A DMA buffer */
+	nfc_info->dma.buf =
+		dma_alloc_coherent(dev, DMA_BUF_SIZE,
+				   &nfc_info->dma.phys, GFP_KERNEL);
+	if (nfc_info->dma.buf == NULL) {
+		dev_err(dev, "dma_alloc_coherent failed!\n");
+		return -ENOMEM;
+	}
+
+	dev_dbg(dev, "DMA buffer %p at physical %p\n",
+		 nfc_info->dma.buf, (void *)nfc_info->dma.phys);
+
+#ifndef POLLED_XFERS
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "No irq configured\n");
+		return irq;
+	}
+	res = devm_request_irq(dev, irq, nfc_irq, 0, "evatronix-nand", nfc_info);
+	if (res < 0) {
+		dev_err(dev, "request_irq failed\n");
+		return res;
+	}
+	dev_dbg(dev, "Successfully registered IRQ %d\n", irq);
+#endif
+
+	return 0;
+}
+
+/* Write timing setup to controller */
+static void setup_nfc_timing(struct nfc_setup *nfc_setup)
+{
+	nfc_write(nfc_setup->timings.time_seq_0, TIME_SEQ_0_REG);
+	nfc_write(nfc_setup->timings.time_seq_1, TIME_SEQ_1_REG);
+	nfc_write(nfc_setup->timings.timings_asyn, TIMINGS_ASYN_REG);
+	nfc_write(nfc_setup->timings.time_gen_seq_0, TIME_GEN_SEQ_0_REG);
+	nfc_write(nfc_setup->timings.time_gen_seq_1, TIME_GEN_SEQ_1_REG);
+	nfc_write(nfc_setup->timings.time_gen_seq_2, TIME_GEN_SEQ_2_REG);
+	nfc_write(nfc_setup->timings.time_gen_seq_3, TIME_GEN_SEQ_3_REG);
+}
+
+/*
+ * Calculate the number of clock cycles that exceeds a time in ps, minus 1.
+ * ALso limit the result so it fits in a specified number of bits.
+ */
+static uint32_t ps_to_cycles(uint64_t clockperiod_ps, uint32_t ps, int maxbits)
+{
+	uint32_t tmp = 0;
+	const uint32_t max = (1 << maxbits) - 1;
+
+	while (ps > clockperiod_ps) {
+		ps -= clockperiod_ps;
+		tmp++;
+		if (tmp == max)
+			return max;
+	}
+
+	return tmp;
+}
+
+static void nfc_program_timings(struct device *dev, uint32_t clkrate, int mode)
+{
+	const struct nand_sdr_timings *t;
+	uint32_t reg, tmp, tCCS;
+	uint64_t clk_period;	/* in pico seconds */
+	uint32_t io = 5000;	/* additional I/O delay */
+
+	/* mode field is a bit mask of supported modes, bit 0 for mode 0,
+	 * bit 1 for mode 1, bit 2 for mode 2, bit 3 for mode 3, etc. */
+	if (mode)
+		mode = fls(mode) - 1;
+
+	t = onfi_async_timing_mode_to_sdr_timings(mode);
+	if (IS_ERR(t)) {
+		dev_err(dev, "Can't get NAND ONFi timings!\n");
+		return;
+	}
+
+	dev_info(dev, "Using NAND ONFi mode %d timings\n", mode);
+
+	/* 1/pico-second shifted down 8 bits is 3906250000U */
+	clk_period = 3906250000UL / (clkrate / 256);
+
+	tCCS = 5 * t->tWC_min;
+	reg = (ps_to_cycles(clk_period, t->tWHR_min + io, 6) << 24) |
+	      (ps_to_cycles(clk_period, t->tRHW_min + io, 6) << 16) |
+	      (ps_to_cycles(clk_period, t->tADL_min + io, 6) << 8) |
+	       ps_to_cycles(clk_period, tCCS + io, 6);
+	nfc_write(reg, TIME_SEQ_0_REG);
+
+	reg = (ps_to_cycles(clk_period, t->tWW_min + io, 6) << 16) |
+	      (ps_to_cycles(clk_period, t->tRR_min + io, 6) << 8) |
+	       ps_to_cycles(clk_period, t->tWB_max + io, 6);
+	nfc_write(reg, TIME_SEQ_1_REG);
+
+	/* tRWH [7:4]  RE# or WE# high hold time */
+	/* tRWP [3:0]  RE# or WE# pulse width */
+	tmp = max(t->tREH_min, t->tWH_min) + io;
+	reg = ps_to_cycles(clk_period, tmp, 4) << 4;
+	/* Note: tRWP requires an extra cycle */
+	tmp = max(t->tRP_min,  t->tWP_min) + io;
+	tmp = ps_to_cycles(clk_period, tmp, 4) + 1;
+	reg |= min(tmp, (uint32_t)(1 << 4) - 1);
+	nfc_write(reg, TIMINGS_ASYN_REG);
+}
+
+/* Write per-chip specific config to controller */
+static void config_nfc(struct nfc_config *nfc_config, void *ref)
+{
+	static void *saved_ref;
+
+	/* To avoid rewriting these unnecessarily every time, we only do
+	 * it when the ref has changed, or if ref == NULL (=> force).
+	 */
+	if (ref) {
+		if (ref == saved_ref)
+			return;
+		saved_ref = ref; /* only save if non-null */
+	}
+
+	nfc_write(nfc_config->mem_ctrl, MEM_CTRL_REG);
+	nfc_write(nfc_config->control, CONTROL_REG);
+	nfc_write(nfc_config->ecc_ctrl, ECC_CTRL_REG);
+}
+
+
+#ifndef POLLED_XFERS
+/* Set up interrupt and wq, with supplied interrupt mask */
+static void setup_int(uint32_t what)
+{
+	/* Flag waited on by wq */
+	nfc_info->irq.done = 0;
+
+	/* clear interrupt status bits */
+	nfc_write(0, INT_STATUS_REG);
+
+	/* set interrupt mask */
+	nfc_write(what, INT_MASK_REG);
+
+	/* enable global NFC interrupt. Ooooh... */
+	nfc_write(nfc_read(CONTROL_REG) | CONTROL_INT_EN, CONTROL_REG);
+}
+#endif
+
+/* Set up interrupt, send command, then wait for (any bit of) expected state */
+/* Before issuing a command, we could check if the controller is ready.
+ * We can't check INT_STATUS_REG.MEM0_RDY_INT_FL as it is not a status bit,
+ * it is set on an nfc state transition after the completion of for
+ * instance a page program command (so we can use it as a command
+ * completed trigger).
+ * (See NFC Design Spec (rev 1.15) figure 35 for illustration.)
+ * However, we could check STATUS.CTRL_STAT, which should always
+ * be 0 prior to issuing a command, indicating the controller is not
+ * busy, however, this should never be necessary as we always wait for
+ * the controller to finish the previous command before going on with the
+ * next one. If we time out while waiting it means something has gone really
+ * haywire with the controller so it's probably not worth trying to wait
+ * for it to become ready at a later time either.
+ */
+static void command_and_wait(uint32_t nfc_command, uint32_t int_state)
+#ifndef POLLED_XFERS
+{
+	long timeout;
+
+	/* Set up interrupt condition. Here we utilize the fact that the
+	 * bits in INT_STATE are the same as in INT_MASK.
+	 */
+	setup_int(int_state);
+
+	/* Send command */
+	nfc_write(nfc_command, COMMAND_REG);
+
+	/* The timeout should only trigger in abnormal situations, so
+	 * we leave it at one second for now. (nand_base uses 20ms for write
+	 * and 400ms for erase, respectively.)
+	 */
+	/* A special case might be an unconnected flash chip during probe.
+	 * If that causes the timeout to be triggered, we might want to lower
+	 * it, and even make it dependent on the NAND flash command being
+	 * executed.
+	 */
+	timeout = wait_event_timeout(nfc_info->irq.wq, nfc_info->irq.done,
+				     1 * HZ);
+	if (timeout <= 0) {
+		dev_info(nfc_info->dev,
+			 "Request 0x%08x timed out waiting for 0x%08x\n",
+			 nfc_command, int_state);
+	}
+}
+#else /* POLLED_XFERS */
+{
+	int cmd_loops = 0;
+	uint32_t read_status, read_int_status, dma_status;
+
+	/* Clear interrupt status bits */
+	nfc_write(0, INT_STATUS_REG);
+
+	/* Send command */
+	nfc_write(nfc_command, COMMAND_REG);
+
+	/* Wait for command to complete */
+	MTD_TRACE("Waiting for 0x%08x bit(s) to be set in int_status\n",
+		  int_state);
+
+#define MAX_CMD_LOOPS 100000
+	do {
+		cmd_loops++;
+		read_status = nfc_read(STATUS_REG);
+		read_int_status = nfc_read(INT_STATUS_REG);
+		dma_status = nfc_read(DMA_CTRL_REG);
+		MTD_TRACE("Wait for command done: 0x%08x/0x%08x/0x%08x (%d)\n",
+			  read_status, read_int_status, dma_status, cmd_loops);
+	} while (!(read_int_status & int_state) && cmd_loops < MAX_CMD_LOOPS);
+
+	/*
+	 * Ensure that the status is read before any reads to the DMA buffer.
+	 */
+	rmb();
+
+	if (cmd_loops >= MAX_CMD_LOOPS)
+		MTD_TRACE("Int wait for 0x%08x timed out after %d loops: STATUS = 0x%08x, INT_STATUS=0x%08x, DMA_CTRL = 0x%08x, command 0x%08x\n",
+			  int_state, cmd_loops, read_status, read_int_status,
+			  dma_status, nfc_command);
+}
+#endif
+
+/* Initialize DMA, wq and interrupt status for upcoming transfer. */
+static void init_dma(uint64_t addr, int bytes)
+{
+	int dma_trig_level;
+
+	/* DMA control */
+
+	/* Start when COMMAND register written, set burst type/size */
+	nfc_write(DMA_CTRL_DMA_START | DMA_CTRL_DMA_BURST_I_P_4, DMA_CTRL_REG);
+
+	/*
+	 * Ensure that writes to the DMA buffer are done before we tell the
+	 * hardware about it.
+	 */
+	wmb();
+
+	/* DMA address and length */
+#ifdef NFC_DMA64BIT
+	/* The manual says this register does not 'occur' (sic) unless
+	 * 64 bit DMA support is included.
+	 */
+	nfc_write(addr >> 32, DMA_ADDR_H_REG);
+#endif
+	nfc_write(addr, DMA_ADDR_L_REG);
+
+	/* Byte counter */
+	/* Round up to nearest 32-bit word */
+	nfc_write((bytes + 3) & 0xfffffffc, DMA_CNT_REG);
+
+	/* Cap DMA trigger level at FIFO size */
+	dma_trig_level = bytes * 8 / 32; /* 32-bit entities */
+	if (dma_trig_level > DMA_TLVL_MAX)
+		dma_trig_level = DMA_TLVL_MAX;
+	nfc_write(dma_trig_level, DMA_TLVL_REG);
+}
+
+/* Initialize transfer to or from DMA buffer */
+static void init_dmabuf(int bytes)
+{
+	nfc_info->dma.ptr = nfc_info->dma.buf;
+	nfc_info->dma.buf_bytes = nfc_info->dma.bytes_left = bytes;
+}
+
+/* Initialize controller for DATA_REG readout */
+static void init_dreg_read(int bytes)
+{
+	/* Transfer to DATA_REG register */
+	nfc_write(DATA_REG_SIZE_DATA_REG_SIZE(bytes), DATA_REG_SIZE_REG);
+}
+
+/* Set up for ECC if needed */
+static void setup_ecc(struct chip_info *info, int enable_ecc, int column)
+{
+	uint32_t control;
+	struct mtd_info *mtd = nand_to_mtd(&info->chip);
+
+	/* When reading the oob, we never want ECC, when reading the
+	 * main area, it depends.
+	 */
+	control = nfc_read(CONTROL_REG) & ~CONTROL_ECC_EN;
+	if (enable_ecc) {
+		nfc_write(ECC_OFFSET + mtd->writesize +
+			  info->chip.ecc.bytes * column / info->chip.ecc.size,
+			  ECC_OFFSET_REG);
+		control |= CONTROL_ECC_EN;
+	}
+	nfc_write(control, CONTROL_REG);
+}
+
+/* Read from flash using DMA */
+/* Assumes basic setup for DMA has been done previously. */
+/* The MTD framework never reads a complete page (main + oob) in one go
+ * when using HW ECC, so we don't need to support NFC_READ_ALL in this mode.
+ * For SW ECC we read the whole page on one go in ALL mode however.
+ */
+static void read_dma(struct chip_info *info, int page, int column,
+		     enum nfc_read_mode m)
+{
+	int size;
+	uint32_t command;
+	struct mtd_info *mtd = nand_to_mtd(&info->chip);
+
+	switch (m) {
+	case NFC_READ_OOB:
+		size = mtd->oobsize;
+		break;
+	case NFC_READ_ALL:
+		size = mtd->oobsize + mtd->writesize;
+		break;
+	case NFC_READ_STD:
+	case NFC_READ_RAW:
+		/* If the column is set to anything but 0 in this mode
+		 * we're doing a partial page read so we need to decrease
+		 * the size accordingly.
+		 */
+		size = mtd->writesize - column;
+		break;
+	default:
+		BUG();
+	}
+
+	/* Set up ECC depending on mode */
+	setup_ecc(info, m == NFC_READ_STD, column);
+
+	/* Set up DMA and transfer size */
+
+	init_dmabuf(size);
+	init_dma(nfc_info->dma.phys, size);
+	nfc_write(size, DATA_SIZE_REG);
+
+	/* Set up addresses */
+
+	if (m == NFC_READ_OOB)
+		column += mtd->writesize;
+	nfc_write(column, ADDR0_COL_REG);
+	nfc_write(page, ADDR0_ROW_REG);
+
+	/* For devices > 128 MiB we have 5 address cycles and can use a
+	 * standard NFC command sequence. For smaller devices we have
+	 * 4 address cycles and need to use a Generic Command Sequence.
+	 */
+	if (info->chip.chipsize > (128 << 20)) {
+		command = COMMAND_READ_PAGE_DMA_STD;
+	} else {
+		nfc_write(GEN_SEQ_CTRL_READ_PAGE_4CYCLE, GEN_SEQ_CTRL_REG);
+		command = COMMAND_READ_PAGE_DMA_GEN;
+	}
+
+	command_and_wait(command, INT_STATUS_DMA_INT_FL);
+}
+
+/* Write using DMA */
+/* Assumes DMA has been set up previously and buffer contains data. */
+/* Contrary to read, column is set to writesize when writing to oob, by mtd.
+ * oob is set when the caller wants to write oob data along with the main data.
+ */
+static void write_dma(struct chip_info *info, int page, int column,
+		int oob, int raw)
+{
+	int size = info->cmd_cache.write_size;
+	uint32_t command;
+	struct mtd_info *mtd = nand_to_mtd(&info->chip);
+
+	if (column >= mtd->writesize || oob)
+		raw = 1;
+
+	setup_ecc(info, !raw, column);
+
+	/* Dump selected parts of buffer */
+	MTD_TRACE("Write %d bytes: 0x%08x 0x%08x .. 0x%08x\n", size,
+		  ((uint32_t *)(nfc_info->dma.buf))[0],
+		  ((uint32_t *)(nfc_info->dma.buf))[1],
+		  ((uint32_t *)(nfc_info->dma.buf))[size / 4 - 1]);
+
+	/* Set up DMA and transfer size */
+	init_dma(nfc_info->dma.phys, size);
+	nfc_write(size, DATA_SIZE_REG);
+
+	/* Set up addresses */
+
+	nfc_write(column, ADDR0_COL_REG);
+	nfc_write(page, ADDR0_ROW_REG);
+
+	/* For devices > 128 MiB we have 5 address cycles and can use a
+	 * standard NFC command sequence. For smaller devices we have
+	 * 4 address cycles and need to use a Generic Command Sequence.
+	 */
+	if (info->chip.chipsize > (128 << 20)) {
+		command = COMMAND_WRITE_PAGE_DMA_STD;
+	} else {
+		nfc_write(GEN_SEQ_CTRL_WRITE_PAGE_4CYCLE, GEN_SEQ_CTRL_REG);
+		command = COMMAND_WRITE_PAGE_DMA_GEN;
+	}
+
+	command_and_wait(command, INT_STATUS_DMA_INT_FL);
+
+	/* Don't need to check error status (INT_STATUS_REG.STAT_ERR_INT0_FL)
+	 * here, as the NAND subsystem checks device error status anyway after
+	 * the write command.
+	 */
+
+#ifdef CLEAR_DMA_BUF_AFTER_WRITE
+	/* clear buffer so it doesn't contain the written data anymore */
+	memset(nfc_info->dma.buf, 0, DMA_BUF_SIZE);
+#endif
+}
+
+/* Block erase */
+static void block_erase(int page, int cs)
+{
+	/* Set up addresses */
+	nfc_write(page, ADDR0_ROW_REG);
+	MTD_TRACE("Erase block containing page %d\n", page);
+
+	/* Send 3 address cycle block erase command */
+	command_and_wait(COMMAND_BLOCK_ERASE, INT_STATUS_MEM_RDY_INT_FL(cs));
+
+#ifndef POLLED_XFERS
+	MTD_TRACE("Erase block: INT_STATUS 0x%08x\n", nfc_info->irq.int_status);
+#endif
+
+	/* Don't need to check error status (INT_STATUS_REG.STAT_ERR_INT0_FL)
+	 * here, as the NAND subsystem checks device error status anyway after
+	 * the erase command. The error bit in practice probably just indicates
+	 * that the flash didn't pull R/_B low within tWB.
+	 */
+}
+
+/* Check for erased page.
+ * The prerequisite to calling this routine is: page has been read with
+ * HW ECC, which has returned an 'ecc uncorrectable' status, so either the
+ * page does in fact contain too many bitflips for the ECC algorithm to correct
+ * or the page is in fact erased, which results in the all-FF's ECC to
+ * be invalid relative to the all-FF's data on the page.
+ * Since with the Evatronix NFC we don't have access to either the ECC bytes
+ * or the oob area after a HW ECC read, the following algorithm is adopted:
+ * - Count the number of 0's in the main area. If there are more than
+ *   the ECC strength per ECC block we assume the page wasn't in fact erased,
+ *   and return with an error status.
+ * - If the main area appears erased, we still need to determine if the oob is
+ *   also erased, if not, it would appear that the page wasn't in fact erased,
+ *   and what we're looking at is a page of mostly-FF data with an invalid ECC.
+ *   - Thus we need to read the oob, leaving the main area at the start of the
+ *     DMA buffer in case someone actually wants to read the data later (e.g.
+ *     nanddump).
+ *   - We then count the number of non-zero bits in the oob. The accepted
+ *     number of zeros could be determined by figuring the the size ratio
+ *     of the oob compared to an ECC block. For instance, if the oob is 64
+ *     bytes, an ECC block 512 bytes, and the error correction capability
+ *     of 8 bits, then the accepted number of zeros for the oob to be
+ *     considered erased would be 64/512 * 8 = 1. Alternatively we could just
+ *     accept an error correction capability number of zeros.
+ *     If there are less than this threshold number of zero bits, the page
+ *     is considered erased. In this case we return an all-FF page to the user.
+ *     Otherwise, we consider ourselves to have an ECC error on our hands,
+ *     and we return the appropriate error status while at the same time leaving
+ *     original main area data in place, for potential scrutiny by a user space
+ *     application (e.g. nanddump).
+ * Caveat: It could be that there are some cases for which an almost-FF page
+ * yields an almost-FF ECC. If there are fewer than the error correction
+ * capability number of zero bits, we could conclude that such a page would
+ * be erased when in fact it actually contains data with too many bitflips.
+ * Experience will have to determine whether this can actually occur. From
+ * past experiences with ECC codes it seems unlikely that that trivial
+ * data will in fact result in a trivial ECC code. Even the fairly basic
+ * 1-bit error correction capability Hamming code does not on its own return
+ * an all-FF ECC for all-FF data.
+ *
+ * Function returns 1 if the page is in fact (considered) erased, 0 if not.
+ */
+static int check_erased_page(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+	struct nand_chip *chip = &info->chip;
+
+	int eccsteps =  chip->ecc.steps;
+	int eccsize = chip->ecc.size;
+	int eccstrength = chip->ecc.strength;
+
+	int main_area_zeros = 0;
+
+	int step;
+	uint8_t *bufpos = buf;
+
+	MTD_TRACE("%s: %d byte page, ecc steps %d, size %d, strength %d\n",
+		  __func__, len, eccsteps, eccsize, eccstrength);
+
+	/* Check that main area appears erased. If not, return */
+
+	for (step = 0; step < eccsteps; step++) {
+		int zeros = count_zero_bits(bufpos, eccsize, eccstrength);
+
+		if (zeros > eccstrength)
+			return 0;
+		bufpos += eccsize;
+		main_area_zeros += zeros;
+	}
+
+	/* Ok, main area seems erased. Read oob so we can check it too. */
+
+	/* Note that this will overwrite the DMA buffer with the oob data,
+	 * which is ok since the main area data has already been copied
+	 * to buf earlier.
+	 */
+	read_dma(info, info->cmd_cache.page, info->cmd_cache.column,
+		 NFC_READ_OOB);
+
+	/* We go for the simple approach and accept eccstrength zero bits */
+	/* We only check the BBM and ECC bytes, the rest may be file system */
+	if (count_zero_bits(nfc_info->dma.buf,
+		(chip->ecc.bytes * chip->ecc.steps) + ECC_OFFSET,
+		eccstrength) > eccstrength)
+		return 0;
+
+	MTD_TRACE("%s: Page is erased.%s\n", __func__,
+		  main_area_zeros != 0 ? " Clearing main area to 0xff." : "");
+
+	if (main_area_zeros != 0)
+		memset(buf, 0xff, len);
+
+	return 1;
+}
+
+
+/**** MTD API ****/
+
+/* For cmd_ctrl (and possibly others) we need to do absolutely nothing, but the
+ * pointer is still required to point to a valid function.
+ */
+static void nfc_dummy_cmd_ctrl(struct mtd_info *mtd, int cmd,
+		unsigned int ctrl)
+{
+}
+
+/* Read state of ready pin */
+static int nfc_dev_ready(struct mtd_info *mtd)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+	struct nfc_config *nfc_config = &info->nfc_config;
+
+	MTD_TRACE("mtd %p\n", mtd);
+
+	return !!(nfc_read(STATUS_REG) & nfc_config->mem_status_mask);
+
+}
+
+/* Read byte from DMA buffer */
+/* Not used directly, only via nfc_read_byte */
+static uint8_t nfc_read_dmabuf_byte(struct mtd_info *mtd)
+{
+	if (nfc_info->dma.bytes_left) {
+		MTD_TRACE("mtd %02x\n", *nfc_info->dma.ptr);
+		nfc_info->dma.bytes_left--;
+		return *nfc_info->dma.ptr++;
+	} else
+		return 0; /* no data */
+}
+
+/* Read block of data from DMA buffer */
+static void nfc_read_dmabuf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	MTD_TRACE("mtd %p, buf %p, len %d\n", mtd, buf, len);
+	if (len > nfc_info->dma.bytes_left) {
+		dev_crit(nfc_info->dev,
+			 "Trying to read %d bytes with %d bytes remaining\n",
+			 len, nfc_info->dma.bytes_left);
+		BUG();
+	}
+	memcpy(buf, nfc_info->dma.ptr, len);
+	nfc_info->dma.ptr += len;
+	nfc_info->dma.bytes_left -= len;
+}
+
+/* Set readout position in DMA buffer. Used for NAND_CMD_RNDOUT. */
+static void nfc_set_dmabuf_read_position(struct mtd_info *mtd, int offset)
+{
+	MTD_TRACE("mtd %p, offset %d\n", mtd, offset);
+	if (offset > nfc_info->dma.buf_bytes) {
+		dev_crit(nfc_info->dev,
+			 "Trying to read outside (%d) DMA buffer (%d bytes)\n",
+			 offset, nfc_info->dma.buf_bytes);
+		/* We could BUG() here but it seems a bit severe. */
+		/* Just set sane value for offset. */
+		offset = nfc_info->dma.buf_bytes;
+	}
+	nfc_info->dma.ptr = nfc_info->dma.buf;
+	nfc_info->dma.ptr += offset;
+	nfc_info->dma.bytes_left = nfc_info->dma.buf_bytes - offset;
+}
+
+/* Write block of data to DMA buffer */
+static void nfc_write_dmabuf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	MTD_TRACE("mtd %p, buf %p, len %d\n", mtd, buf, len);
+	if (len > nfc_info->dma.bytes_left) {
+		dev_crit(nfc_info->dev,
+			 "Trying to write %d bytes with %d bytes remaining\n",
+			 len, nfc_info->dma.bytes_left);
+		BUG();
+	}
+	memcpy(nfc_info->dma.ptr, buf, len);
+	nfc_info->dma.ptr += len;
+	nfc_info->dma.bytes_left -= len;
+	info->cmd_cache.write_size += len; /* calculate total length to write */
+}
+
+/* Read byte from DMA buffer or DATA_REG, depending on previous command. */
+/* Used by MTD for reading ID bytes, and chip status */
+static uint8_t nfc_read_byte(struct mtd_info *mtd)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+	uint8_t status_value;
+
+	/*
+	 * If the controller is not ready (e.g. no NAND attached), return dummy
+	 * data out to ensure we don't lock up waiting for data.
+	 */
+	if (nfc_read(STATUS_REG) & STATUS_CTRL_STAT)
+		return 0xff;
+
+	if (info->cmd_cache.command != NAND_CMD_STATUS)
+		return nfc_read_dmabuf_byte(mtd);
+
+	MTD_TRACE("Read status\n");
+
+	/* In order to read status, we need to send a READ_STATUS command
+	 * to the NFC first, in order to get the data into the DATA_REG.
+	 */
+	init_dreg_read(1);
+	/* We want to read all status bits from the device */
+	nfc_write(STATUS_MASK_STATE_MASK(0xff), STATUS_MASK_REG);
+	command_and_wait(COMMAND_READ_STATUS, INT_STATUS_DATA_REG_FL);
+	status_value = nfc_read(DATA_REG_REG) & 0xff;
+	MTD_TRACE("Status 0x%08x\n", status_value);
+	return status_value;
+}
+
+/* Do the dirty work for read_page_foo */
+static int nfc_read_page_mode(struct mtd_info *mtd, struct nand_chip *chip,
+		int offset, int len, uint8_t *buf, int oob_required, int page,
+		enum nfc_read_mode m)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+	unsigned int max_bitflips;
+	uint32_t ecc_status;
+
+	MTD_TRACE("page %d, col %d, offs %d, size %d\n",
+		  page, info->cmd_cache.column, offset, len);
+
+	if (page != info->cmd_cache.page) {
+		MTD_TRACE("Warning: Read page has different page number than READ0: %d vs. %d\n",
+			  page, info->cmd_cache.page);
+	}
+
+	if (m == NFC_READ_STD) {
+		/* ECC error flags and counters are not cleared automatically
+		 * so we do it here.
+		 * Note that the design spec says nothing about having to
+		 * zero ECC_STAT (although it explicitly says that ECC_CNT
+		 * needs to be zeroed by software), but testing on actual
+		 * hardware reveals that this is in fact the case.
+		 */
+		nfc_write(0, ECC_STAT_REG);
+		nfc_write(0, ECC_CNT_REG);
+	}
+
+	read_dma(info, info->cmd_cache.page, info->cmd_cache.column + offset, m);
+
+	/* This is actually nfc_read_dmabuf */
+	/* We add the offset here because the nand_base expects the data
+	 * to be in the corresponding place in the page buffer, rather than
+	 * at the beginning.
+	 */
+	chip->read_buf(mtd, buf + offset, len);
+
+	if (m == NFC_READ_RAW)
+		return 0;
+
+	/* Get ECC status from controller */
+	ecc_status = nfc_read(ECC_STAT_REG);
+	max_bitflips = nfc_read(ECC_CNT_REG) & ECC_CNT_ERR_LVL_MASK;
+
+	if (ecc_status & ECC_STAT_UNC(info->nfc_config.cs))
+		if (!check_erased_page(mtd, buf, mtd->writesize)) {
+			dev_warn(nfc_info->dev, "Uncorrected errors!\n");
+			mtd->ecc_stats.failed++;
+		}
+
+	/* The following is actually not really correct, as the stats should
+	 * reflect _all_ bitflips, not just the largest one in the latest read.
+	 * We could rectify this by reading chip->ecc.bytes at a time,
+	 * and accumulating the statistics per read, but at least for now
+	 * the additional overhead doesn't seem to warrant the increased
+	 * accuracy of the statistics, since the important figure is the
+	 * max number of bitflips in a single ECC block returned by this
+	 * function.
+	 */
+	mtd->ecc_stats.corrected += max_bitflips;
+
+	MTD_TRACE("ECC read status: %s%s%s%s, correction count %d\n",
+		  ecc_status & ECC_STAT_UNC(info->nfc_config.cs) ?
+			"Uncorrected " : "",
+		  ecc_status & ECC_STAT_ERROR(info->nfc_config.cs)
+			? "Corrected " : "",
+		  ecc_status & ECC_STAT_OVER(info->nfc_config.cs)
+			? "Over limit " : "",
+		  ecc_status & (ECC_STAT_UNC(info->nfc_config.cs) |
+				ECC_STAT_ERROR(info->nfc_config.cs) |
+				ECC_STAT_OVER(info->nfc_config.cs))
+			?  "" : "ok",
+		  max_bitflips);
+
+	/* We shouldn't see oob_required for ECC reads. */
+	if (oob_required) {
+		dev_crit(nfc_info->dev, "Need separate read for the OOB\n");
+		BUG();
+	}
+
+	return max_bitflips;
+}
+
+/* Read page with HW ECC */
+static int nfc_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+		uint8_t *buf, int oob_required, int page)
+{
+	MTD_TRACE("page %d, oobreq %d\n", page, oob_required);
+	return nfc_read_page_mode(mtd, chip, 0, mtd->writesize, buf,
+				  oob_required, page, NFC_READ_STD);
+}
+
+/* Read page with no ECC */
+static int nfc_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+		uint8_t *buf, int oob_required, int page)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	MTD_TRACE("page %d, oobreq %d\n", page, oob_required);
+	/* Since we're doing a raw read we can safely ignore the return value
+	 * as it is the number of bit flips in ECC mode only.
+	 */
+	nfc_read_page_mode(mtd, chip, 0, mtd->writesize, buf, oob_required,
+			   page, NFC_READ_RAW);
+
+	if (!oob_required)
+		return 0;
+
+	/* Read OOB */
+	read_dma(info, info->cmd_cache.page, info->cmd_cache.column,
+		 NFC_READ_OOB);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/* Write page with HW ECC */
+/* This is the only place where we know we'll be writing w/ ECC */
+static int nfc_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+		const uint8_t *buf, int oob_required, int page)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	MTD_TRACE("oob_required %d\n", oob_required);
+
+	/* The controller can't write data to the oob when ECC is enabled,
+	 * so we set oob_required to 0 here and don't process the oob
+	 * further even if requested. This could happen for instance if
+	 * using nandwrite -o without -n .
+	 */
+	if (oob_required)
+		dev_warn(nfc_info->dev, "Tried to write OOB with ECC!\n");
+	info->cmd_cache.oob_required = 0;
+	info->cmd_cache.write_raw = 0;
+
+	nfc_write_dmabuf(mtd, buf, mtd->writesize);
+
+	return 0;
+}
+
+/* Write page with no ECC */
+/* This is the only place where we know we won't be writing w/ ECC */
+static int nfc_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+		const uint8_t *buf, int oob_required, int page)
+{
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	MTD_TRACE("oob_required %d\n", oob_required);
+
+	/* We need this for the upcoming PAGEPROG command */
+	info->cmd_cache.oob_required = oob_required;
+	info->cmd_cache.write_raw = 1;
+
+	nfc_write_dmabuf(mtd, buf, mtd->writesize);
+
+	if (oob_required)
+		chip->write_buf(mtd, info->chip.oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/* Handle commands from MTD NAND layer */
+static void nfc_command(struct mtd_info *mtd, unsigned int command,
+			     int column, int page_addr)
+{
+	/* We know that an mtd belonging to us is actually only the first
+	 * struct in a multi-struct structure.
+	 */
+	struct chip_info *info = TO_CHIP_INFO(mtd);
+
+	/* Save command so that other parts of the API can figure out
+	 * what's actually going on.
+	 */
+	info->cmd_cache.command = command;
+
+	/* Configure the NFC for the flash chip in question. */
+	config_nfc(&info->nfc_config, info);
+
+	/* Some commands we execute immediately, while some need to be
+	 * deferred until we have all the data needed, i.e. for page read,
+	 * we can't initiate the read until we know if we are going to be
+	 * using raw mode or not.
+	 */
+	switch (command) {
+	case NAND_CMD_READ0:
+		MTD_TRACE("READ0 page %d, column %d, ecc mode %s\n",
+			  page_addr, column,
+			  info->chip.ecc.mode == NAND_ECC_HW ? "hardware" :
+							       "software");
+		if (info->chip.ecc.mode == NAND_ECC_HW) {
+			/* We do not yet know if the caller wants to
+			 * read the page with or without ECC, so we
+			 * just store the page number and main/oob flag
+			 * here.
+			 * (The page number also arrives via the subsequent
+			 * read_page call, so we don't really need to store it).
+			 */
+			info->cmd_cache.page = page_addr;
+			info->cmd_cache.column = column;
+		} else {
+			/* Read the whole page including oob */
+			info->cmd_cache.oob_required = 1;
+			read_dma(info, page_addr, column, NFC_READ_ALL);
+		}
+		break;
+	case NAND_CMD_READOOB:
+		MTD_TRACE("READOOB page %d, column %d\n", page_addr, column);
+		/* In contrast to READ0, where nand_base always calls
+		 * a read_page_foo function before reading the data,
+		 * for READOOB, read_buf is called instead.
+		 * We don't want the actual read in read_buf, so
+		 * we put it here.
+		 */
+		read_dma(info, page_addr, column, NFC_READ_OOB);
+		break;
+	case NAND_CMD_RNDOUT:
+		MTD_TRACE("RNDOUT column %d\n", column);
+		/* Just set read position in buffer of previously performed
+		 * read operation.
+		 */
+		nfc_set_dmabuf_read_position(mtd, column);
+		break;
+	case NAND_CMD_ERASE1:
+		MTD_TRACE("ERASE1 page %d\n", page_addr);
+		/* Just grab page parameter, wait until ERASE2 to do
+		 * something.
+		 */
+		info->cmd_cache.page = page_addr;
+		break;
+	case NAND_CMD_ERASE2:
+		MTD_TRACE("ERASE2 page %d, do it\n", info->cmd_cache.page);
+		/* Off we go! */
+		block_erase(info->cmd_cache.page, info->nfc_config.cs);
+		break;
+	case NAND_CMD_RESET:
+		MTD_TRACE("chip reset\n");
+		/* Clear the FIFOs */
+		nfc_write(FIFO_INIT_FIFO_INIT, FIFO_INIT_REG);
+		command_and_wait(COMMAND_RESET,
+				 INT_STATUS_CMD_END_INT_FL);
+		break;
+	case NAND_CMD_SEQIN:
+		MTD_TRACE("SEQIN column %d, page %d\n", column, page_addr);
+		/* Just grab some parameters, then wait until
+		 * PAGEPROG to do the actual operation.
+		 */
+		info->cmd_cache.page = page_addr;
+		info->cmd_cache.column = column;
+		info->cmd_cache.write_size = 0; /* bumped by nfc_write_dmabuf */
+		/* Prepare DMA buffer for data. We don't yet know
+		 * how much data there is, so set size to max.
+		 */
+		init_dmabuf(DMA_BUF_SIZE);
+		break;
+	case NAND_CMD_PAGEPROG:
+		/* Used for both main area and oob */
+		MTD_TRACE("PAGEPROG page %d, column %d, w/oob %d, raw %d\n",
+			  info->cmd_cache.page, info->cmd_cache.column,
+			  info->cmd_cache.oob_required,
+			  info->cmd_cache.write_raw);
+		write_dma(info, info->cmd_cache.page,
+			  info->cmd_cache.column,
+			  info->cmd_cache.oob_required,
+			  info->cmd_cache.write_raw);
+		break;
+	case NAND_CMD_READID:
+		MTD_TRACE("READID (0x%02x)\n", column);
+
+		/* Read specified ID bytes */
+		/* 0x00 would be NAND_READ_ID_ADDR_STD
+		 * 0x20 would be NAND_READ_ID_ADDR_ONFI
+		 * 0x40 would be NAND_READ_ID_ADDR_JEDEC
+		 * but NAND subsystem knows this and sends us the
+		 * address values directly.
+		 */
+
+		nfc_write(column, ADDR0_COL_REG);
+		nfc_write(0, ADDR0_ROW_REG);
+
+		/*
+		 * If the controller is not ready (e.g. no NAND attached), bail
+		 * out to ensure we don't lock up later on.
+		 */
+		if (nfc_read(STATUS_REG) & STATUS_CTRL_STAT)
+			return;
+
+		init_dmabuf(READID_LENGTH);
+		init_dma(nfc_info->dma.phys, READID_LENGTH);
+		nfc_write(READID_LENGTH, DATA_SIZE_REG);
+
+		/* Send read id command */
+		command_and_wait(COMMAND_READ_ID,
+				 INT_STATUS_DMA_INT_FL);
+		break;
+	case NAND_CMD_STATUS:
+		MTD_TRACE("STATUS, defer to later read byte\n");
+		/* Don't do anything now, wait until we need to
+		 * actually read status.
+		 */
+		break;
+	case NAND_CMD_PARAM:
+		MTD_TRACE("PARAM (0x%02x)\n", column);
+
+		nfc_write(column, ADDR0_COL_REG);
+		nfc_write(0, ADDR0_ROW_REG);
+
+		init_dmabuf(NAND_PARAM_SIZE_MAX);
+		init_dma(nfc_info->dma.phys, NAND_PARAM_SIZE_MAX);
+		nfc_write(NAND_PARAM_SIZE_MAX, DATA_SIZE_REG);
+
+		command_and_wait(COMMAND_PARAM,
+				 INT_STATUS_DMA_INT_FL);
+		break;
+	default:
+		MTD_TRACE("Unhandled command 0x%02x (col %d, page addr %d)\n",
+			  command, column, page_addr);
+		break;
+	}
+}
+
+/**** Top level probing and device management ****/
+
+/* Select an appropriate ECC BCH strength */
+static u32 nand_select_ecc(struct mtd_info *mtd, u32 ecc_blksize,
+	u32 oob_reserved)
+{
+	u32 avail = mtd->oobsize - ECC_OFFSET - oob_reserved;
+	u32 bytes_per_codeword = (avail * ecc_blksize) / mtd->writesize;
+	u8 lut[] = { 56, 42, 28, 14, 7, 4 };
+	u8 bch[] = { 32, 24, 16,  8, 4, 2 };
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lut); i++)
+		if (bytes_per_codeword >= lut[i])
+			return bch[i];
+
+	return 0;
+}
+
+/* Verify ECC configuration set by nand_base.c, set defaults if needed */
+static void nfc_verify_ecc_config(struct mtd_info *mtd,
+				  struct platform_device *pdev,
+				  struct nand_chip *chip)
+{
+	struct device *dev = &pdev->dev;
+
+	/* ECC parameters */
+	if ((chip->ecc.mode != NAND_ECC_HW &&
+	     chip->ecc.mode != NAND_ECC_SOFT) ||
+	    chip->ecc.algo != NAND_ECC_BCH) {
+		dev_warn(dev, "Unsupported/unset ECC mode, setting HW BCH\n");
+		chip->ecc.mode = NAND_ECC_HW;
+		chip->ecc.algo = NAND_ECC_BCH;
+	}
+
+	if (chip->ecc.size != 256 && chip->ecc.size != 512 &&
+	    chip->ecc.size != 1024) {
+		chip->ecc.size = 512;
+		dev_warn(dev, "Unsupported ECC step size, using default %d\n",
+			 chip->ecc.size);
+	}
+
+	/* Select an appropriate ECC BCH strength if not specified */
+	if (chip->ecc.strength == 0) {
+		chip->ecc.strength = nand_select_ecc(mtd,
+					chip->ecc.size,
+					nfc_info->setup->oob_reserved);
+		if (!chip->ecc.strength) {
+			dev_err(dev, "NAND device unusable as OOB is too small!\n");
+			return;
+		}
+	}
+
+	/* NFC can handle 2 bits but ECC_BYTES macro can't and it's
+	 * highly unlikely we'd ever need to support 2 bits correction
+	 * in practice, so don't allow that case here.
+	 */
+	if (chip->ecc.strength != 4 && chip->ecc.strength != 8 &&
+	    chip->ecc.strength != 16 && chip->ecc.strength != 24 &&
+	    chip->ecc.strength != 32) {
+		chip->ecc.strength = 8;
+		dev_warn(dev, "Unsupported ECC strength, using default %d\n",
+			 chip->ecc.strength);
+	}
+}
+
+/* Get proprietary configuration from device tree */
+/* (nand_base.c sets up ECC and BBT parameters for us) */
+static int nfc_get_dt_config(struct platform_device *pdev)
+{
+	struct nfc_setup *nfc_setup = dev_get_platdata(&pdev->dev);
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	int res, timings;
+
+	if (!np) {
+		dev_err(dev, "Can't retrieve device tree configuration!\n");
+		return -EINVAL;
+	}
+
+	timings = sizeof(nfc_setup->timings) / sizeof(u32);
+	res = of_property_read_u32_array(np, "evatronix,timings",
+					 (u32 *)&nfc_setup->timings, timings);
+	if (res < 0) {
+		dev_warn(dev, "NAND timing setup missing, using defaults\n");
+		/* Default values have been set, but we don't know what
+		 * read_u32_array does if it fails during parsing, so reset
+		 * them here again.
+		 */
+		memcpy(&nfc_setup->timings, &default_mode0_pll_enabled,
+		       sizeof(nfc_setup->timings));
+	}
+
+	res = !!of_get_property(np, "evatronix,use-bank-select", NULL);
+	if (res)
+		nfc_setup->use_bank_select = true;
+
+	res = !!of_get_property(np, "evatronix,rb-wired-and", NULL);
+	if (res)
+		nfc_setup->rb_wired_and = true;
+
+	nfc_setup->oob_reserved = 0;
+	of_property_read_u32(np, "oob-reserved", &nfc_setup->oob_reserved);
+
+	return 0;
+}
+
+/* Number of ecc bytes needed, helper for ooblayout functions */
+static int nfc_eccbytes(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct device *dev = &mtd->dev;
+	int eccbytes = chip->ecc.bytes * (mtd->writesize / chip->ecc.size);
+
+	if (ECC_OFFSET + eccbytes > mtd->oobsize) {
+		dev_err(dev, "Need %d bytes for ECC and BBM, only have %d bytes in OOB\n",
+			ECC_OFFSET + eccbytes, mtd->oobsize);
+		eccbytes = mtd->oobsize - ECC_OFFSET;
+	}
+
+	return eccbytes;
+}
+
+/* Callbacks for ECC layout */
+
+/* We put the ECC just after the 2-byte bad block marker */
+static int nfc_ooblayout_ecc(struct mtd_info *mtd, int section,
+			     struct mtd_oob_region *oobregion)
+{
+	if (section)
+		return -ERANGE; /* We have only one section */
+
+	oobregion->offset = ECC_OFFSET;
+	oobregion->length = nfc_eccbytes(mtd);
+
+	return 0;
+}
+
+/* Everything after the ECC is considered free. */
+static int nfc_ooblayout_free(struct mtd_info *mtd, int section,
+			      struct mtd_oob_region *oobregion)
+{
+	if (section)
+		return -ERANGE; /* Only one free section */
+
+	oobregion->offset = ECC_OFFSET + nfc_eccbytes(mtd);
+	oobregion->length = mtd->oobsize - oobregion->offset;
+
+	return 0;
+}
+
+static const struct mtd_ooblayout_ops nfc_ooblayout_ops = {
+	.ecc = nfc_ooblayout_ecc,
+	.free = nfc_ooblayout_free,
+};
+
+/* Per-NAND-chip initialization. */
+static
+struct mtd_info *nfc_flash_probe(struct platform_device *pdev,
+				 unsigned int bank_no)
+{
+	struct mtd_info *mtd;
+	struct chip_info *this;
+	struct device *dev = &pdev->dev;
+	int pages_per_block, ecc_blksize, ecc_strength;
+	struct nfc_setup *nfc_setup = nfc_info->setup;
+
+	/* Allocate memory for NAND device structure (including mtd) */
+	this = devm_kzalloc(dev, sizeof(struct chip_info), GFP_KERNEL);
+	if (!this)
+		return NULL;
+
+	/* Link the nand data with the mtd structure */
+	mtd = nand_to_mtd(&this->chip);
+	nand_set_flash_node(&this->chip, pdev->dev.of_node);
+
+	/* Set up basic config for NAND controller hardware */
+
+	/* Device control. */
+	if (nfc_setup->use_bank_select) {
+		/* Separate chips regarded as different banks. */
+		this->nfc_config.mem_ctrl =
+			MEM_CTRL_BANK_SEL(bank_no) | MEM_CTRL_MEM0_WR;
+		this->nfc_config.cs = 0;
+	} else {
+		/* Separate chips regarded as different chip selects. */
+		this->nfc_config.mem_ctrl =
+			MEM_CTRL_MEM_CE(bank_no) | MEM_CTRL_MEM0_WR;
+		this->nfc_config.cs = bank_no;
+	}
+
+	if (nfc_setup->rb_wired_and) {
+		/* Ready/busy from all flash chips wired-AND:ed */
+		this->nfc_config.mem_status_mask = STATUS_MEM_ST(0);
+	} else {
+		/* Ready/busy from nand flash as separate per-device signals */
+		this->nfc_config.mem_status_mask = STATUS_MEM_ST(bank_no);
+	}
+
+	/* Our interface to the mtd API */
+	this->chip.cmdfunc = nfc_command;
+	this->chip.cmd_ctrl = nfc_dummy_cmd_ctrl;
+	this->chip.dev_ready = nfc_dev_ready;
+	this->chip.read_byte = nfc_read_byte;
+	this->chip.read_buf = nfc_read_dmabuf;
+	this->chip.write_buf = nfc_write_dmabuf;
+
+	/* ONFi Mode 0 timings */
+	nfc_program_timings(dev, nfc_info->clk_rate, 0);
+
+	/* Scan to find existence of the device */
+	/* Note that the NFC is not completely set up at this time, but
+	 * that is ok as we only need to identify the device here.
+	 */
+	if (nand_scan_ident(mtd, 1, NULL))
+		return NULL;
+
+	/* Adjust timing to fastest supported ONFi mode */
+	nfc_program_timings(dev, nfc_info->clk_rate,
+		onfi_get_async_timing_mode(&this->chip));
+
+	/* nand_scan_ident() sets up general DT properties, including
+	 * NAND_BUSWIDTH_16 which we don't support.
+	 */
+	if (this->chip.options & NAND_BUSWIDTH_16) {
+		dev_err(dev, "16 bit bus mode not supported\n");
+		return NULL;
+	}
+
+	/* Set up rest of config for NAND controller hardware */
+
+	/* Since nand_scan_ident() sets up the ECC config from DT, we
+	 * check its validity here before going on, and set defaults
+	 * (and display a warning) if the values are unacceptable.
+	 */
+	nfc_verify_ecc_config(mtd, pdev, &this->chip);
+
+	/* ECC block size and pages per block */
+	pages_per_block = mtd->erasesize / mtd->writesize;
+	ecc_blksize = this->chip.ecc.size;
+	ecc_strength = this->chip.ecc.strength;
+	this->nfc_config.control = CONTROL_ECC_BLOCK_SIZE(ecc_blksize) |
+				   CONTROL_BLOCK_SIZE(pages_per_block);
+
+	/* Set up ECC control and offset of ECC data */
+	/* We don't use the threshold capability of the controller, as we
+	 * let mtd handle that, so set the threshold to same as capability.
+	 */
+	this->nfc_config.ecc_ctrl = ECC_CTRL_ECC_THRESHOLD(ecc_strength) |
+				    ECC_CTRL_ECC_CAP(ecc_strength);
+
+	/* Since we've now completed the configuration, we need to force it to
+	 * be written to the NFC, else the caching in config_nfc will leave
+	 * the nfc_config values written since nand_scan_ident unwritten.
+	 */
+	config_nfc(&this->nfc_config, NULL);
+
+	/* ECC setup */
+
+	/* ECC API */
+	/* Override the following functions when using hardware ECC,
+	 * otherwise we use the defaults set up by nand_base.
+	 */
+	if (this->chip.ecc.mode == NAND_ECC_HW) {
+		this->chip.ecc.read_page = nfc_read_page_hwecc;
+		this->chip.ecc.read_page_raw = nfc_read_page_raw;
+		this->chip.ecc.write_page = nfc_write_page_hwecc;
+		this->chip.ecc.write_page_raw = nfc_write_page_raw;
+		this->chip.options |= NAND_NO_SUBPAGE_WRITE;
+	}
+
+	/* Not sure if these really need to be set for HW ECC; but if
+	 * nothing else we use the values for our lower level driver
+	 * to have a common point where it is all set up.
+	 */
+	this->chip.ecc.bytes = ECC_BYTES(ecc_strength, ecc_blksize);
+	mtd_set_ooblayout(mtd, &nfc_ooblayout_ops);
+
+	/* We set the bitflip_threshold at 75% of the error correction
+	 * level to get some margin in case bitflips happen in parts of the
+	 * flash that we don't read that often.
+	 */
+	/* We add 1 so that an ECC strength of 1 gives us a threshold of 1;
+	 * rather academic though, as we only support BCH anyway...
+	 */
+	mtd->bitflip_threshold = (ecc_strength + 1) * 3 / 4;
+
+	if (this->chip.bbt_options & NAND_BBT_USE_FLASH)
+		/* Enable the use of a flash based bad block table.
+		 * Since the OOB is not ECC protected we don't put BBT stuff
+		 * there. We also don't mark user-detected badblocks as bad in
+		 * their oob, only in the BBT, to avoid potential chip problems
+		 * when attempting to write bad blocks (writing to bad blocks
+		 * is not recommended according to flash manufacturers).
+		 */
+		this->chip.bbt_options |= NAND_BBT_NO_OOB | NAND_BBT_NO_OOB_BBM;
+
+	this->chip.controller = nfc_info->controller;
+
+	/* Finalize NAND scan, including BBT if requested */
+	if (nand_scan_tail(mtd))
+		return NULL;
+
+	mtd->dev.parent = &pdev->dev;
+
+	return mtd;
+}
+
+/* Main probe function. Called to probe and set up device. */
+static int nfc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtd_info *main_mtd;
+	struct nfc_setup *nfc_setup;
+	struct nand_hw_control *controller;
+	int err = 0;
+
+	dev_info(dev, "Initializing Evatronix NANDFLASH-CTRL driver\n");
+
+	/* nfc_info is where we keep runtime information about the NFC */
+	nfc_info = devm_kzalloc(dev, sizeof(*nfc_info), GFP_KERNEL);
+	if (!nfc_info)
+		return -ENOMEM;
+
+	nfc_info->dev = dev;
+
+	/* Set up a controller struct to act as shared lock for all devices */
+	controller = devm_kzalloc(dev, sizeof(*controller), GFP_KERNEL);
+	if (!controller)
+		return -ENOMEM;
+
+	spin_lock_init(&controller->lock);
+	init_waitqueue_head(&controller->wq);
+	nfc_info->controller = controller;
+
+	/* nfc_setup is where we keep settings from DT, in digested form */
+	nfc_setup = devm_kzalloc(dev, sizeof(*nfc_setup), GFP_KERNEL);
+	if (!nfc_setup)
+		return -ENOMEM;
+
+	pdev->dev.platform_data = nfc_setup;
+	nfc_info->setup = nfc_setup;
+
+	memcpy(&nfc_setup->timings, &default_mode0_pll_enabled,
+	       sizeof(nfc_setup->timings));
+
+	/* Get config from device tree. */
+	err = nfc_get_dt_config(pdev);
+	if (err)
+		return err;
+
+	/* Initialize interrupts and DMA etc. */
+	err = nfc_init_resources(pdev);
+	if (err)
+		return err;
+
+	setup_nfc_timing(nfc_setup);
+
+#ifndef POLLED_XFERS
+	init_waitqueue_head(&nfc_info->irq.wq);
+#endif
+
+	main_mtd = nfc_flash_probe(pdev, 0);
+	if (!main_mtd)
+		return -ENXIO;
+
+	dev_info(dev, "ECC using %s mode with strength %i and block size %i.\n",
+		 mtd_to_nand(main_mtd)->ecc.mode == NAND_ECC_HW ? "hardware" :
+								  "software",
+		 mtd_to_nand(main_mtd)->ecc.strength,
+		 mtd_to_nand(main_mtd)->ecc.size);
+
+	/* Map mtd partitions from DT */
+	err = mtd_device_register(main_mtd, NULL, 0);
+
+	return err;
+}
+
+static const struct of_device_id nfc_id_table[] = {
+	{ .compatible = "evatronix,nandflash-ctrl" },
+	{} /* sentinel */
+};
+MODULE_DEVICE_TABLE(of, nfc_id_table);
+
+static struct platform_driver nfc_driver = {
+	.driver = {
+		.name   = "evatronix-nand",
+		.of_match_table = of_match_ptr(nfc_id_table),
+	},
+	.probe = nfc_probe,
+};
+
+module_platform_driver(nfc_driver);
+
+MODULE_AUTHOR("Ricard Wanderlof <ricardw@axis.com>");
+MODULE_DESCRIPTION("Evatronix NANDFLASH-CTRL driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mtd/spi-nor/Kconfig b/drivers/mtd/spi-nor/Kconfig
index 4a682ee..3a99975 100644
--- a/drivers/mtd/spi-nor/Kconfig
+++ b/drivers/mtd/spi-nor/Kconfig
@@ -76,4 +76,22 @@ config SPI_NXP_SPIFI
 	  Flash. Enable this option if you have a device with a SPIFI
 	  controller and want to access the Flash as a mtd device.
 
+
+config RZN1_QSPI
+	tristate "RZ/N1 Cadence Quad SPI controller"
+	depends on ARCH_RZN1
+	help
+	  This enables support for the Quad SPI controller in master mode.
+
+config RZN1_QSPI_NR_CS
+	int "Max Number of QSPI chips"
+	range 1 16
+	default 2
+	depends on RZN1_QSPI
+	help
+	  Specifies the maximum number of chips handled by the driver.
+	  from 1 to 4, the bitfield method of CS selection can be used
+	  (this is the default, simple mode). When using more than 4,
+	  the 'encoding' mode needs be be used. See Datasheet for details.
+
 endif # MTD_SPI_NOR
diff --git a/drivers/mtd/spi-nor/Makefile b/drivers/mtd/spi-nor/Makefile
index 121695e..aacc238 100644
--- a/drivers/mtd/spi-nor/Makefile
+++ b/drivers/mtd/spi-nor/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_SPI_FSL_QUADSPI)	+= fsl-quadspi.o
 obj-$(CONFIG_SPI_HISI_SFC)	+= hisi-sfc.o
 obj-$(CONFIG_MTD_MT81xx_NOR)    += mtk-quadspi.o
 obj-$(CONFIG_SPI_NXP_SPIFI)	+= nxp-spifi.o
+obj-$(CONFIG_RZN1_QSPI)		+= rzn1-qspi.o
diff --git a/drivers/mtd/spi-nor/rzn1-qspi.c b/drivers/mtd/spi-nor/rzn1-qspi.c
new file mode 100644
index 0000000..f6b7070
--- /dev/null
+++ b/drivers/mtd/spi-nor/rzn1-qspi.c
@@ -0,0 +1,905 @@
+/*
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd.
+ *
+ * Using some material derived from:
+ * (C) 2014 Altera Corporation <www.altera.com>
+ * (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/completion.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/spi-nor.h>
+
+#include "rzn1-qspi.h"
+
+#define CQSPI_CAL_DELAY(tdelay_ns, tref_ns, tsclk_ns)	\
+	(((tdelay_ns) > (tsclk_ns)) ? \
+		((((tdelay_ns) - (tsclk_ns)) / (tref_ns))) : 0)
+
+/* these are default */
+#define CONFIG_CQSPI_TSHSL_NS	200
+#define CONFIG_CQSPI_TSD2D_NS	255
+#define CONFIG_CQSPI_TCHSH_NS	20
+#define CONFIG_CQSPI_TSLCH_NS	20
+
+
+struct rzn1_qspi_slave {
+	u32	cs;
+	u32	clk_rate;	/* target rate */
+	unsigned int pha: 1, pol: 1,
+		read_cmd: 8, dummy_clk: 4,
+		mux_address: 1, cap_delay: 4;
+
+	/* these are cached register values for this slave, contains
+	 * clock speed, mode, CS etc */
+	struct {
+		u32 cfg;
+		u32 delay;
+		u32 devsz;
+		u32 rddatacap;
+	} reg;
+	/* corresponds to the cfg register value, clock polarity/rate etc */
+	u32	cfg_base;
+	struct rzn1_qspi *host;
+	struct mtd_info *mtd;
+	struct spi_nor nor;
+};
+
+struct rzn1_qspi {
+	/* keep it const prevents stupidly writing to reg */
+	const struct cadence_qspi __iomem *reg;
+	u32 slave_count;
+	struct rzn1_qspi_slave slave[CONFIG_RZN1_QSPI_NR_CS];
+	void __iomem *ahb_base; /* Used when read from AHB bus */
+	struct device *dev;
+	int use_cs_mux;		/* renesas,rzn1-cs_mux */
+	struct clk *clk, *clk_fw;
+	int disable_count;
+};
+
+/* made to bypass the const used in the rzn1_qspi->reg structure, and
+ * therefore make sure a writel is done instead of a direct assign */
+#define qspi_writel(_v, _a) writel((_v), (void *)(_a))
+
+/* Do not re-enable controller while multiple function might have disabled it */
+static void _rzn1_qspi_enable(struct rzn1_qspi *q)
+{
+	if (q->disable_count)
+		q->disable_count--;
+	if (q->disable_count)
+		return;
+	qspi_writel(readl(&q->reg->cfg) | CQSPI_REG_CONFIG_ENABLE_MASK,
+		&q->reg->cfg);
+}
+
+static void _rzn1_qspi_disable(struct rzn1_qspi *q)
+{
+	q->disable_count++;
+	qspi_writel(readl(&q->reg->cfg) & ~CQSPI_REG_CONFIG_ENABLE_MASK,
+		&q->reg->cfg);
+}
+
+/* Return 1 if idle, otherwise return 0 (busy). */
+static u32 _rzn1_qspi_wait_idle(struct rzn1_qspi *q)
+{
+	u32 count = 0;
+	u32 timeout = 50;
+
+	while (count < timeout) {
+		if ((readl(&q->reg->cfg) >> CQSPI_REG_CONFIG_IDLE_LSB) & 1) {
+			count++;
+			schedule_timeout_interruptible(HZ / 10000);
+		} else {
+			count = 0;
+		}
+		/*
+		 * Ensure the QSPI controller is in true idle state after
+		 * reading back the same idle status consecutively
+		 */
+		if (count >= CQSPI_POLL_IDLE_RETRY)
+			return 1;
+	}
+
+	/* Timeout, still in busy mode. */
+	dev_warn(q->dev, "still busy after poll for %d times.\n",
+	       CQSPI_REG_RETRY);
+	return 0;
+}
+
+static u32 _rzn1_qspi_set_baudrate_div(
+	struct rzn1_qspi_slave *s,
+	u32 ref_clk_hz,
+	u32 sclk_hz)
+{
+	u32 reg;
+	u32 div;
+	u32 actual_div;
+
+	_rzn1_qspi_disable(s->host);
+	reg = readl(&s->host->reg->cfg);
+	reg &= ~(CQSPI_REG_CONFIG_BAUD_MASK << CQSPI_REG_CONFIG_BAUD_LSB);
+
+	/* Recalculate the baudrate divisor based on QSPI specification. */
+	div = DIV_ROUND_UP(ref_clk_hz, 2 * sclk_hz) - 1;
+	if (div > 15)
+		div = 15;
+
+	actual_div = (div + 1) << 1;
+
+	dev_dbg(s->host->dev, "%s: ref_clk %dHz sclk %dHz Div 0x%x\n", __func__,
+	      ref_clk_hz, sclk_hz, div);
+	dev_info(s->host->dev, "%s: output clock is %dHz (div = %d)\n", __func__,
+	      ref_clk_hz / actual_div, actual_div);
+
+	div = (div & CQSPI_REG_CONFIG_BAUD_MASK) << CQSPI_REG_CONFIG_BAUD_LSB;
+	reg |= div;
+	qspi_writel(reg, &s->host->reg->cfg);
+
+	_rzn1_qspi_enable(s->host);
+
+	return ref_clk_hz / actual_div;
+}
+
+static void _rzn1_qspi_set_clk_mode(
+	struct rzn1_qspi_slave *s)
+{
+	u32 reg;
+
+	_rzn1_qspi_disable(s->host);
+	reg = readl(&s->host->reg->cfg);
+	reg &= ~((1 << CQSPI_REG_CONFIG_CLK_POL_LSB) |
+		(1 << CQSPI_REG_CONFIG_CLK_PHA_LSB));
+
+	reg |= s->pol << CQSPI_REG_CONFIG_CLK_POL_LSB;
+	reg |= s->pha << CQSPI_REG_CONFIG_CLK_PHA_LSB;
+
+	qspi_writel(reg, &s->host->reg->cfg);
+
+	_rzn1_qspi_enable(s->host);
+}
+
+static void _rzn1_qspi_set_cs(
+	struct rzn1_qspi_slave *s)
+{
+	struct rzn1_qspi *q = s->host;
+	u32 reg;
+	int chip_select = s->cs;
+
+	_rzn1_qspi_disable(s->host);
+
+	dev_dbg(s->host->dev, "set CS:%d decode %d\n",
+		chip_select, q->use_cs_mux);
+
+	reg = readl(&s->host->reg->cfg);
+	/* decoder */
+	if (q->use_cs_mux) {
+		reg |= CQSPI_REG_CONFIG_DECODE_MASK;
+	} else {
+		reg &= ~CQSPI_REG_CONFIG_DECODE_MASK;
+		/* Convert CS if without decoder.
+		 * CS0 to 4b'1110
+		 * CS1 to 4b'1101
+		 * CS2 to 4b'1011
+		 * CS3 to 4b'0111
+		 */
+		chip_select = 0xF & ~(1 << chip_select);
+	}
+
+	reg &= ~(CQSPI_REG_CONFIG_CHIPSELECT_MASK
+			<< CQSPI_REG_CONFIG_CHIPSELECT_LSB);
+	reg |= (chip_select & CQSPI_REG_CONFIG_CHIPSELECT_MASK)
+			<< CQSPI_REG_CONFIG_CHIPSELECT_LSB;
+	qspi_writel(reg, &s->host->reg->cfg);
+
+	_rzn1_qspi_enable(s->host);
+}
+
+static void _rzn1_qspi_set_device_size(
+	struct rzn1_qspi_slave *s)
+{
+	struct spi_nor *nor = &(s->nor);
+	u32 reg;
+
+	_rzn1_qspi_disable(s->host);
+
+	/* Configure the device size and address bytes */
+	reg = readl(&s->host->reg->devsz);
+	/* Clear the previous value */
+	reg &= ~(CQSPI_REG_SIZE_PAGE_MASK << CQSPI_REG_SIZE_PAGE_LSB);
+	reg &= ~(CQSPI_REG_SIZE_BLOCK_MASK << CQSPI_REG_SIZE_BLOCK_LSB);
+	reg |= (nor->page_size << CQSPI_REG_SIZE_PAGE_LSB);
+	reg |= (ilog2(nor->mtd.erasesize) << CQSPI_REG_SIZE_BLOCK_LSB);
+	reg |= (nor->addr_width - 1);
+	qspi_writel(reg, &s->host->reg->devsz);
+
+	_rzn1_qspi_enable(s->host);
+}
+
+static void _rzn1_qspi_set_readdelay(
+	struct rzn1_qspi_slave *s,
+	unsigned int delay)
+{
+	unsigned int reg;
+
+	_rzn1_qspi_disable(s->host);
+
+	reg = readl(&s->host->reg->rddatacap);
+
+	reg |= (1 << CQSPI_REG_RD_DATA_CAPTURE_BYPASS_LSB) |
+		(1 << CQSPI_REG_RD_DATA_CAPTURE_EDGE_LSB);
+
+	reg &= ~(CQSPI_REG_RD_DATA_CAPTURE_DELAY_MASK
+		<< CQSPI_REG_RD_DATA_CAPTURE_DELAY_LSB);
+
+	reg |= ((delay & CQSPI_REG_RD_DATA_CAPTURE_DELAY_MASK)
+		<< CQSPI_REG_RD_DATA_CAPTURE_DELAY_LSB);
+
+	qspi_writel(reg, &s->host->reg->rddatacap);
+
+	_rzn1_qspi_enable(s->host);
+}
+
+static void _rzn1_qspi_set_delay(
+	struct rzn1_qspi_slave *s,
+	u32 ref_clk, u32 sclk_hz,
+	u32 tshsl_ns, u32 tsd2d_ns,
+	u32 tchsh_ns, u32 tslch_ns)
+{
+	u32 ref_clk_ns;
+	u32 sclk_ns;
+	u32 tshsl, tchsh, tslch, tsd2d;
+	u32 reg;
+
+	_rzn1_qspi_disable(s->host);
+
+	/* Convert to ns. */
+	ref_clk_ns = 1000000000 / ref_clk;
+
+	/* Convert to ns. */
+	sclk_ns = 1000000000 / sclk_hz;
+
+	tshsl = CQSPI_CAL_DELAY(tshsl_ns, ref_clk_ns, sclk_ns);
+	tchsh = CQSPI_CAL_DELAY(tchsh_ns, ref_clk_ns, sclk_ns);
+	tslch = CQSPI_CAL_DELAY(tslch_ns, ref_clk_ns, sclk_ns);
+	tsd2d = CQSPI_CAL_DELAY(tsd2d_ns, ref_clk_ns, sclk_ns);
+
+	reg = (tshsl & CQSPI_REG_DELAY_TSHSL_MASK)
+			<< CQSPI_REG_DELAY_TSHSL_LSB;
+	reg |= (tchsh & CQSPI_REG_DELAY_TCHSH_MASK)
+			<< CQSPI_REG_DELAY_TCHSH_LSB;
+	reg |= (tslch & CQSPI_REG_DELAY_TSLCH_MASK)
+			<< CQSPI_REG_DELAY_TSLCH_LSB;
+	reg |= (tsd2d & CQSPI_REG_DELAY_TSD2D_MASK)
+			<< CQSPI_REG_DELAY_TSD2D_LSB;
+	dev_dbg(s->host->dev, "%s: delay reg = 0x%X\n", __func__, reg);
+	qspi_writel(reg, &s->host->reg->delay);
+
+	_rzn1_qspi_enable(s->host);
+}
+
+static void rzn1_qspi_set_speed(struct rzn1_qspi_slave *s)
+{
+	unsigned long rate = clk_get_rate(s->host->clk);
+	unsigned long hz = _rzn1_qspi_set_baudrate_div(
+					s, rate, s->clk_rate);
+
+	/* Reconfigure delay timing if speed is changed. */
+	_rzn1_qspi_set_delay(s,
+		rate, hz,
+		CONFIG_CQSPI_TSHSL_NS, CONFIG_CQSPI_TSD2D_NS,
+		CONFIG_CQSPI_TCHSH_NS, CONFIG_CQSPI_TSLCH_NS);
+}
+
+static u32
+_rzn1_qspi_set_address(
+	struct rzn1_qspi_slave *s,
+	u32 addr,
+	u32 reg)
+{
+	/* Command with address */
+	reg |= 1 << CQSPI_REG_CMDCTRL_ADDR_EN_LSB;
+	/* Number of bytes to write. */
+	reg |= ((s->nor.addr_width - 1) & CQSPI_REG_CMDCTRL_ADD_BYTES_MASK)
+		<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;
+
+	qspi_writel(addr, &s->host->reg->flashcmdaddr);
+
+	return reg;
+}
+
+static int _rzn1_qspi_exec_cmd(
+	struct rzn1_qspi_slave *s,
+	u32 reg)
+{
+	u32 retry = CQSPI_REG_RETRY;
+
+	/* Write the CMDCTRL without start execution. */
+	qspi_writel(reg, &s->host->reg->flashcmd);
+	/* Start execute */
+	reg |= CQSPI_REG_CMDCTRL_EXECUTE_MASK;
+	qspi_writel(reg, &s->host->reg->flashcmd);
+
+	while (retry--) {
+		reg = readl(&s->host->reg->flashcmd);
+		if ((reg & CQSPI_REG_CMDCTRL_INPROGRESS_MASK) == 0)
+			break;
+		schedule_timeout_interruptible(HZ / 10000);
+	}
+
+	if (!retry) {
+		dev_err(s->host->dev, "flash command execution timeout\n");
+		return -EIO;
+	}
+
+	/* Polling QSPI idle status. */
+	if (!_rzn1_qspi_wait_idle(s->host))
+		return -EIO;
+
+	return 0;
+}
+
+/* We use this function to do some basic init for spi_nor_scan(). */
+static int rzn1_qspi_nor_setup(struct rzn1_qspi *q)
+{
+	u32 reg = 0;
+
+	_rzn1_qspi_disable(q);
+
+	/* Configure the remap address register, no remap */
+	qspi_writel(0, &q->reg->remapaddr);
+
+	/* Disable all interrupts */
+	qspi_writel(0, &q->reg->irqmask);
+
+	/* this is the defaul SPI mode for most SPI NOR flashes */
+	reg |= (1 << CQSPI_REG_CONFIG_CLK_POL_LSB);
+	reg |= (1 << CQSPI_REG_CONFIG_CLK_PHA_LSB);
+	/* This is the only setup we need; enable memory mapped range */
+	reg |= CQSPI_REG_CONFIG_DIRECT_MASK;
+	/* Enable AHB write protection, to prevent random write access
+	 * that could nuke the flash memory. Instead you have to explicitly
+	 * go thru the write command.
+	 * We set the protection range to the maximum, so the whole
+	 * address range should be protected, regardless of what size
+	 * is actually used.
+	 */
+	qspi_writel(0, &q->reg->lowwrprot);
+	qspi_writel(~0, &q->reg->uppwrprot);
+	qspi_writel(CQSPI_REG_WRPROT_ENABLE_MASK, &q->reg->wrprot);
+
+	qspi_writel(reg, &q->reg->cfg);
+
+	_rzn1_qspi_enable(q);
+	return 0;
+}
+
+static int rzn1_qspi_read_reg(
+	struct spi_nor *nor, u8 opcode, u8 *buf, int len)
+{
+	int ret;
+	struct rzn1_qspi_slave *s = nor->priv;
+	struct rzn1_qspi *q = s->host;
+	u32 reg;
+	uint32_t rx[2];
+
+	if (len > CQSPI_STIG_DATA_LEN_MAX || buf == NULL) {
+		dev_err(q->dev, "%s CS:%d 0x%2x Invalid size len:%d\n",
+			__func__, s->cs, opcode, len);
+		return -EINVAL;
+	}
+
+	reg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;
+	reg |= 1 << CQSPI_REG_CMDCTRL_RD_EN_LSB;
+
+	/* 0 means 1 byte. */
+	reg |= ((len - 1) & CQSPI_REG_CMDCTRL_RD_BYTES_MASK)
+		<< CQSPI_REG_CMDCTRL_RD_BYTES_LSB;
+	ret = _rzn1_qspi_exec_cmd(s, reg);
+	if (ret != 0)
+		return ret;
+	/* copy the IO registers into a non io buffer, then into the dest one */
+	rx[0] = readl(&q->reg->flashcmdrddatalo);
+	if (len > 4)
+		rx[1] = readl(&q->reg->flashcmdrddataup);
+	memcpy(buf, rx, len);
+
+	return 0;
+}
+
+static int rzn1_qspi_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)
+{
+	struct rzn1_qspi_slave *s = nor->priv;
+	struct rzn1_qspi *q = s->host;
+	int ret;
+	u32 reg;
+
+	if (len > CQSPI_STIG_DATA_LEN_MAX) {
+		dev_err(q->dev, "%s CS:%d 0x%2x Invalid size len:%d\n",
+			__func__, s->cs, opcode, len);
+		return -EINVAL;
+	}
+
+	reg = opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;
+	if (buf && len) {
+		const uint32_t *src = (uint32_t *)buf;
+		const uint32_t *d = &q->reg->flashcmdwrdatalo;
+		int i;
+
+		for (i = 0; i < 1 + (len / 4); i++, src++, d++)
+			qspi_writel(*src, d);
+		reg |= 1 << CQSPI_REG_CMDCTRL_WR_EN_LSB;
+		/* Number of bytes to write. */
+		reg |= ((len - 1) & CQSPI_REG_CMDCTRL_WR_BYTES_MASK)
+			<< CQSPI_REG_CMDCTRL_WR_BYTES_LSB;
+	}
+
+	ret = _rzn1_qspi_exec_cmd(s, reg);
+
+	return ret;
+}
+
+static ssize_t rzn1_qspi_write(struct spi_nor *nor, loff_t to,
+		size_t len, const u_char *buf)
+{
+	struct rzn1_qspi_slave *s = nor->priv;
+	struct rzn1_qspi *q = s->host;
+
+	qspi_writel(0, &q->reg->wrprot);
+	memcpy(q->ahb_base + to, buf, len);
+
+	qspi_writel(CQSPI_REG_WRPROT_ENABLE_MASK,
+	       &q->reg->wrprot);
+
+	return len;
+}
+
+static ssize_t rzn1_qspi_read(struct spi_nor *nor, loff_t from,
+		size_t len, u_char *buf)
+{
+	struct rzn1_qspi_slave *s = nor->priv;
+	struct rzn1_qspi *q = s->host;
+
+	/* Read out the data directly from the AHB buffer.*/
+	memcpy(buf, q->ahb_base + from, len);
+
+	return len;
+}
+
+static int rzn1_qspi_erase(struct spi_nor *nor, loff_t offs)
+{
+	struct rzn1_qspi_slave *s = nor->priv;
+	struct rzn1_qspi *q = s->host;
+	int ret;
+	u32 reg;
+
+	dev_dbg(nor->dev, "Erase %dKiB at 0x%08x [o:%02x a:%d]\n",
+		nor->mtd.erasesize / 1024, (u32)offs,
+		s->nor.erase_opcode, s->nor.addr_width);
+
+	/* Send write enable, then erase commands. */
+	ret = nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0);
+	if (ret)
+		return ret;
+
+	reg = s->nor.erase_opcode << CQSPI_REG_CMDCTRL_OPCODE_LSB;
+	reg = _rzn1_qspi_set_address(s, offs, reg);
+	/*
+	 * Here we do not use the synchronous function, as the
+	 * erase is so slow we want to let the mtd pool the status until
+	 * it's done instead of locking the driver in that opperation
+	 */
+	/* Write the CMDCTRL without start execution. */
+	qspi_writel(reg, &q->reg->flashcmd);
+	/* Start execute */
+	reg |= CQSPI_REG_CMDCTRL_EXECUTE_MASK;
+	qspi_writel(reg, &q->reg->flashcmd);
+
+	return ret;
+}
+
+static int rzn1_qspi_prep(struct spi_nor *nor, enum spi_nor_ops ops)
+{
+	struct rzn1_qspi_slave *s = nor->priv;
+	struct rzn1_qspi *q = s->host;
+	u32 rd_reg = s->read_cmd << CQSPI_REG_RD_INSTR_OPCODE_LSB;
+	u32 wr_reg = nor->program_opcode << CQSPI_REG_WR_INSTR_OPCODE_LSB;
+
+	_rzn1_qspi_disable(q);
+
+	switch (nor->flash_read) {
+	case SPI_NOR_DUAL:
+		rd_reg |= (CQSPI_INST_TYPE_DUAL <<
+				CQSPI_REG_RD_INSTR_TYPE_DATA_LSB);
+		if (s->mux_address)
+			rd_reg |= (CQSPI_INST_TYPE_DUAL <<
+				CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB);
+		break;
+	case SPI_NOR_QUAD:
+		rd_reg |= (CQSPI_INST_TYPE_QUAD <<
+				CQSPI_REG_RD_INSTR_TYPE_DATA_LSB);
+		if (s->mux_address)
+			rd_reg |= (CQSPI_INST_TYPE_QUAD <<
+				CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB);
+		break;
+	default: /* nothing to do for the other modes */
+		break;
+	}
+
+	if (s->dummy_clk) {
+		rd_reg |= (s->dummy_clk & CQSPI_REG_RD_INSTR_DUMMY_MASK) <<
+				CQSPI_REG_RD_INSTR_DUMMY_LSB;
+	}
+	qspi_writel(rd_reg, &q->reg->devrd);
+	qspi_writel(wr_reg, &q->reg->devwr);
+
+	qspi_writel(s->reg.devsz, &q->reg->devsz);
+	qspi_writel(s->reg.delay, &q->reg->delay);
+	qspi_writel(s->reg.rddatacap, &q->reg->rddatacap);
+	qspi_writel(0xff, &q->reg->modebit);
+
+	/* this also technically enable the controller, but doesn't matter */
+	qspi_writel(s->reg.cfg, &q->reg->cfg);
+
+	_rzn1_qspi_enable(q);
+
+	return 0;
+}
+
+static void rzn1_qspi_unprep(struct spi_nor *nor, enum spi_nor_ops ops)
+{
+
+}
+
+static irqreturn_t rzn1_qspi_irq_handler(int irq, void *dev_id)
+{
+	struct rzn1_qspi *q = dev_id;
+	u32 reg = readl(&q->reg->irqstat);
+
+	reg = 0;
+	qspi_writel(reg, &q->reg->irqstat);
+
+	return IRQ_HANDLED;
+}
+
+static const struct spi_nor nor_callbacks = {
+	.read_reg = rzn1_qspi_read_reg,
+	.write_reg = rzn1_qspi_write_reg,
+	.read = rzn1_qspi_read,
+	.write = rzn1_qspi_write,
+	.write_mmap = rzn1_qspi_write,
+	.erase = rzn1_qspi_erase,
+	.prepare = rzn1_qspi_prep,
+	.unprepare = rzn1_qspi_unprep,
+};
+
+/*
+ * Handles properties that are listed either as a bool, or as an integer. Like
+ *
+ *  {
+ *     renesas,rzn1-phase;
+ *  .. or
+ *     renesas,rzn1-phase = <0>;
+ *  }
+ */
+static int _of_property_bool_or_int(
+		struct device_node *np,
+		const char * name,
+		int default_value)
+{
+	struct property *prop;
+	int res = default_value;
+
+	prop = of_find_property(np, name, NULL);
+	if (prop && prop->length) {
+		u32 reg = default_value;
+
+		of_property_read_u32(np, name, &reg);
+		res = !!reg;
+	}
+	return res;
+}
+
+static int rzn1_get_slave_config(
+		struct device_node *np,
+		struct rzn1_qspi_slave *s)
+{
+	u32 reg = 0;
+	unsigned long clk = clk_get_rate(s->host->clk);
+	int mode = SPI_NOR_NORMAL;
+	u32 value;
+	const __be32 *read_mode;
+	int rm_len;
+
+	s->pha = s->pol = 0;
+
+	of_property_read_u32_index(np, "reg", 0, &s->cs);
+
+	read_mode = of_get_property(np, "renesas,rzn1-read-cmd", &rm_len);
+	if (read_mode) {
+		rm_len /= sizeof(read_mode[0]);
+		if (rm_len > 0)
+			s->read_cmd = be32_to_cpu(read_mode[0]);
+		if (rm_len > 1)
+			s->dummy_clk = be32_to_cpu(read_mode[1]);
+		if (rm_len > 2)
+			s->mux_address = read_mode[2] != 0;
+	}
+
+	if (of_find_property(np, "spi-cpha", NULL))
+		s->pha = 1;
+	if (of_find_property(np, "spi-cpol", NULL))
+		s->pol = 1;
+
+	if (!of_property_read_u32(np, "spi-rx-bus-width", &value)) {
+		switch (value) {
+		case 1:
+			break;
+		case 2:
+			mode |= SPI_NOR_DUAL;
+			break;
+		case 4:
+			mode |= SPI_NOR_QUAD;
+			break;
+		default:
+			dev_warn(s->host->dev,
+				"spi-rx-bus-width %d not supported\n",
+				value);
+			break;
+		}
+	}
+
+	of_property_read_u32(np, "spi-max-frequency", &s->clk_rate);
+	if (s->clk_rate > (clk / 2))
+		s->clk_rate = clk / 2;
+	if (s->clk_rate < (clk/32)) {
+		dev_warn(s->host->dev,
+			 "%s CS:%d Invalid rate %d, should be %ul<>%d\n",
+			__func__, s->cs, s->clk_rate,
+			(unsigned)(clk/32), (unsigned)(clk/2));
+	}
+	reg = 2;	/* default delay for full reads */
+	of_property_read_u32(np, "renesas,rzn1-readcap-delay", &reg);
+	s->cap_delay = reg;
+
+	return mode;
+}
+
+static int rzn1_qspi_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct rzn1_qspi *q;
+	struct resource *res;
+	int ret, i = 0;
+
+	q = devm_kzalloc(dev, sizeof(*q), GFP_KERNEL);
+	if (!q)
+		return -ENOMEM;
+
+	q->slave_count = of_get_child_count(dev->of_node);
+	if (!q->slave_count || q->slave_count > CONFIG_RZN1_QSPI_NR_CS) {
+		dev_err(dev, "Invalid number of flash slave chips\n");
+		return -ENODEV;
+	}
+
+	/* find the resources */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qspi");
+	q->reg = devm_ioremap_resource(dev, res);
+	if (IS_ERR(q->reg)) {
+		ret = PTR_ERR(q->reg);
+		goto map_failed;
+	}
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+					"qspi-mapping");
+	/* Make sure the IO mapping range is cacheable */
+	if (res)
+		res->flags |= IORESOURCE_CACHEABLE;
+	q->ahb_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(q->ahb_base)) {
+		ret = PTR_ERR(q->ahb_base);
+		goto map_failed;
+	}
+
+	/* find the clocks */
+	q->clk_fw = devm_clk_get(dev, "flexway");
+	if (IS_ERR(q->clk_fw)) {
+		ret = PTR_ERR(q->clk_fw);
+		goto clk_failed;
+	}
+	q->clk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(q->clk)) {
+		ret = PTR_ERR(q->clk);
+		goto clk_failed;
+	}
+	ret = clk_prepare_enable(q->clk_fw);
+	if (ret) {
+		dev_err(dev, "can not enable the qspi_fw clock\n");
+		goto clk_failed;
+	}
+	ret = clk_prepare_enable(q->clk);
+	if (ret) {
+		clk_disable_unprepare(q->clk_fw);
+		dev_err(dev, "can not enable the qspi clock\n");
+		goto clk_failed;
+	}
+
+	/* find the irq */
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0) {
+		dev_err(dev, "failed to get the irq\n");
+		goto irq_failed;
+	}
+
+	ret = devm_request_irq(dev, ret,
+			rzn1_qspi_irq_handler, 0, pdev->name, q);
+	if (ret) {
+		dev_err(dev, "failed to request irq.\n");
+		goto irq_failed;
+	}
+	/* handle either a boolean prop, or an explicit integer one */
+	q->use_cs_mux = _of_property_bool_or_int(np, "renesas,rzn1-cs_mux", 0);
+
+	q->dev = dev;
+	platform_set_drvdata(pdev, q);
+
+	ret = rzn1_qspi_nor_setup(q);
+	if (ret)
+		goto irq_failed;
+
+	/* iterate the subnodes. */
+	for_each_available_child_of_node(dev->of_node, np) {
+		struct rzn1_qspi_slave *s = &q->slave[i];
+		int mode = SPI_NOR_NORMAL;
+
+		q->slave[i].host = q;
+		/* Start by setting callbacks */
+		q->slave[i].nor = nor_callbacks;
+
+		s->mtd = &s->nor.mtd;
+		s->nor.dev = dev;
+		spi_nor_set_flash_node(&s->nor, np);
+		s->nor.priv = s;
+
+		/* get default properties from the node */
+		mode = rzn1_get_slave_config(np, s);
+
+		/* need to at least set the CS line properly here
+		 * as 'prepare' is not called */
+		/* For the clock, we use a slow one, as the 'probe' get ID
+		 * command sometime doesn't like the faster speed on some
+		 * devices */
+		_rzn1_qspi_set_baudrate_div(s,
+				clk_get_rate(q->clk), 1000000);
+		qspi_writel(0, &s->host->reg->delay);
+		/* Set clock phase/polarity */
+		_rzn1_qspi_set_clk_mode(s);
+		_rzn1_qspi_set_cs(s);
+		_rzn1_qspi_set_readdelay(s, 0);
+
+		if (spi_nor_scan(&s->nor, NULL, mode))
+			goto scan_failed;
+
+		if (s->read_cmd == 0)
+			s->read_cmd = s->nor.read_opcode;
+		/* Note: this relies on patch
+		 * 0b78a2cf2a73b5f32ffda8cde7866ca61ce0e0b7
+		 * That converts 'read_dummy' to 'bits' instead of bytes
+		 */
+		if (s->dummy_clk == 0)
+			s->dummy_clk = s->nor.read_dummy;
+
+		dev_dbg(dev, "CS:%d r:%02x p:%02x e:%02x addr:%d dummy:%d:%d\n",
+			s->cs, s->nor.read_opcode, s->nor.program_opcode,
+			s->nor.erase_opcode, s->nor.addr_width,
+			s->nor.read_dummy, s->dummy_clk);
+
+		rzn1_qspi_set_speed(s);
+		_rzn1_qspi_set_readdelay(s, s->cap_delay);
+
+		ret = mtd_device_register(s->mtd, NULL, 0);
+		if (ret)
+			goto scan_failed;
+		_rzn1_qspi_set_device_size(s);
+		dev_dbg(dev, "CS:%d size:%d width:%d devsz:%08x\n",
+			s->cs, (int)s->mtd->size/1024*1024,
+			s->nor.addr_width, readl(&q->reg->devsz));
+		/* cache the IO register values with our configutation */
+		s->reg.cfg = readl(&q->reg->cfg);
+		s->reg.delay = readl(&q->reg->delay);
+		s->reg.devsz = readl(&q->reg->devsz);
+		s->reg.rddatacap = readl(&q->reg->rddatacap);
+
+		/* force 4 bytes mode for device, even if it has specific
+		 * opcodes to handle 4 bytes addresses */
+		/* Normally spi_nor_scan() will switch into 4-byte address mode
+		 * if supported.
+		 * However, it will not switch Spansion (aka AMD) devices into
+		 * 4-byte mode as it selects dedicated 4-byte commands whilst
+		 * remaining in 3-byte mode. Since we allow users to specify
+		 * the commands, we switch into 4-byte mode here. */
+		if (s->mtd->size > 0x1000000 && s->nor.addr_width == 4) {
+			/* For spansion, it's special... grrrr */
+			u8 extadd = 0x80; /* Bank Register bit 7 */
+
+			/* Send BRWR command */
+			s->nor.write_reg(&s->nor, 0x17 , &extadd, 1);
+
+			/* for everyone but spansion, send 0xb7 command */
+			s->nor.write_reg(&s->nor, SPINOR_OP_EN4B, NULL, 0);
+
+			dev_dbg(dev, "CS:%d configured 4 bytes addressing\n",
+				s->cs);
+		}
+
+		i++;
+		continue;
+scan_failed:
+		dev_err(dev, "probe failed for CS:%d\n", s->cs);
+	}
+
+	dev_info(dev, "probed\n");
+	return 0;
+
+irq_failed:
+	clk_disable_unprepare(q->clk);
+	clk_disable_unprepare(q->clk_fw);
+clk_failed:
+map_failed:
+	dev_err(dev, "RZN1 QSPI probe failed\n");
+	return ret;
+}
+
+static int rzn1_qspi_remove(struct platform_device *pdev)
+{
+	struct rzn1_qspi *q = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < q->slave_count; i++)
+		mtd_device_unregister(q->slave[i].mtd);
+	clk_unprepare(q->clk);
+	clk_unprepare(q->clk_fw);
+
+	return 0;
+}
+
+
+static struct of_device_id rzn1_qspi_dt_ids[] = {
+	{ .compatible = "renesas,rzn1-qspi" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, rzn1_qspi_dt_ids);
+
+static struct platform_driver rzn1_qspi_driver = {
+	.driver = {
+		.name	= "rzn1-qspi",
+		.bus	= &platform_bus_type,
+		.of_match_table = rzn1_qspi_dt_ids,
+	},
+	.probe          = rzn1_qspi_probe,
+	.remove		= rzn1_qspi_remove,
+};
+module_platform_driver(rzn1_qspi_driver);
+
+MODULE_DESCRIPTION("RZN1 QSPI Controller Driver");
+MODULE_AUTHOR("Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mtd/spi-nor/rzn1-qspi.h b/drivers/mtd/spi-nor/rzn1-qspi.h
new file mode 100644
index 0000000..c0b8e85
--- /dev/null
+++ b/drivers/mtd/spi-nor/rzn1-qspi.h
@@ -0,0 +1,141 @@
+/*
+ * (C) Copyright 2014 Altera Corporation <www.altera.com>
+ * (C) Copyright 2015 Renesas Electronics Europe Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __CADENCE_QSPI_H__
+#define __CADENCE_QSPI_H__
+
+struct cadence_qspi {
+	u32	cfg;
+	u32	devrd;
+	u32	devwr;
+	u32	delay;
+	u32	rddatacap; /* 0x10 */
+	u32	devsz;
+	u32	srampart;
+	u32	indaddrtrig;
+	u32	dmaper; /* 0x20 */
+	u32	remapaddr;
+	u32	modebit;
+	u32	sramfill;
+	u32	txthresh; /* 0x30 */
+	u32	rxthresh;
+	u32	_pad_0x38_0x3f[2];
+	u32	irqstat;
+	u32	irqmask;
+	u32	_pad_0x48_0x4f[2];
+	u32	lowwrprot;
+	u32	uppwrprot;
+	u32	wrprot;
+	u32	_pad_0x5c_0x5f;
+	u32	indrd;
+	u32	indrdwater;
+	u32	indrdstaddr;
+	u32	indrdcnt;
+	u32	indwr; /* 0x70 */
+	u32	indwrwater;
+	u32	indwrstaddr;
+	u32	indwrcnt;
+	u32	_pad_0x80_0x8f[4];
+	u32	flashcmd;
+	u32	flashcmdaddr;
+	u32	_pad_0x98_0x9f[2];
+	u32	flashcmdrddatalo;
+	u32	flashcmdrddataup;
+	u32	flashcmdwrdatalo;
+	u32	flashcmdwrdataup;
+	u32	_pad_0xb0_0xfb[19];
+	u32	moduleid;
+};
+
+/* Controller's configuration and status register */
+#define	CQSPI_REG_CONFIG_CLK_POL_LSB		1
+#define	CQSPI_REG_CONFIG_CLK_PHA_LSB		2
+#define	CQSPI_REG_CONFIG_ENABLE_MASK		(1 << 0)
+#define	CQSPI_REG_CONFIG_DIRECT_MASK		(1 << 7)
+#define	CQSPI_REG_CONFIG_DECODE_MASK		(1 << 9)
+#define	CQSPI_REG_CONFIG_AHB_ENABLE_MASK	(1 << 16)
+#define	CQSPI_REG_CONFIG_XIP_IMM_MASK		(1 << 18)
+#define	CQSPI_REG_CONFIG_CHIPSELECT_LSB		10
+#define	CQSPI_REG_CONFIG_BAUD_LSB		19
+#define	CQSPI_REG_CONFIG_IDLE_LSB		31
+#define	CQSPI_REG_CONFIG_CHIPSELECT_MASK	0xF
+#define	CQSPI_REG_CONFIG_BAUD_MASK		0xF
+#define	CQSPI_REG_RD_INSTR_OPCODE_LSB		0
+#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB	8
+#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB	12
+#define	CQSPI_REG_RD_INSTR_TYPE_DATA_LSB	16
+#define	CQSPI_REG_RD_INSTR_MODE_EN_LSB		20
+#define	CQSPI_REG_RD_INSTR_DUMMY_LSB		24
+#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_TYPE_DATA_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_DUMMY_MASK		0x1F
+#define	CQSPI_REG_WR_INSTR_OPCODE_LSB		0
+#define	CQSPI_REG_DELAY_TSLCH_LSB		0
+#define	CQSPI_REG_DELAY_TCHSH_LSB		8
+#define	CQSPI_REG_DELAY_TSD2D_LSB		16
+#define	CQSPI_REG_DELAY_TSHSL_LSB		24
+#define	CQSPI_REG_DELAY_TSLCH_MASK		0xFF
+#define	CQSPI_REG_DELAY_TCHSH_MASK		0xFF
+#define	CQSPI_REG_DELAY_TSD2D_MASK		0xFF
+#define	CQSPI_REG_DELAY_TSHSL_MASK		0xFF
+#define	CQSPI_REG_RD_DATA_CAPTURE_BYPASS_LSB	0
+#define	CQSPI_REG_RD_DATA_CAPTURE_DELAY_LSB	1
+#define	CQSPI_REG_RD_DATA_CAPTURE_DELAY_MASK	0xF
+#define CQSPI_REG_RD_DATA_CAPTURE_EDGE_LSB	5
+#define	CQSPI_REG_SIZE_ADDRESS_LSB		0
+#define	CQSPI_REG_SIZE_PAGE_LSB			4
+#define	CQSPI_REG_SIZE_BLOCK_LSB		16
+#define	CQSPI_REG_SIZE_ADDRESS_MASK		0xF
+#define	CQSPI_REG_SIZE_PAGE_MASK		0xFFF
+#define	CQSPI_REG_SIZE_BLOCK_MASK		0x3F
+#define	CQSPI_REG_SRAMLEVEL_RD_LSB		0
+#define	CQSPI_REG_SRAMLEVEL_WR_LSB		16
+#define	CQSPI_REG_SRAMLEVEL_RD_MASK		0xFFFF
+#define	CQSPI_REG_SRAMLEVEL_WR_MASK		0xFFFF
+#define	CQSPI_REG_INDIRECTRD_START_MASK		(1 << 0)
+#define	CQSPI_REG_INDIRECTRD_CANCEL_MASK	(1 << 1)
+#define	CQSPI_REG_INDIRECTRD_INPROGRESS_MASK	(1 << 2)
+#define	CQSPI_REG_INDIRECTRD_DONE_MASK		(1 << 5)
+#define	CQSPI_REG_CMDCTRL_EXECUTE_MASK		(1 << 0)
+#define	CQSPI_REG_CMDCTRL_INPROGRESS_MASK	(1 << 1)
+#define	CQSPI_REG_CMDCTRL_DUMMY_LSB		7
+#define	CQSPI_REG_CMDCTRL_WR_BYTES_LSB		12
+#define	CQSPI_REG_CMDCTRL_WR_EN_LSB		15
+#define	CQSPI_REG_CMDCTRL_ADD_BYTES_LSB		16
+#define	CQSPI_REG_CMDCTRL_ADDR_EN_LSB		19
+#define	CQSPI_REG_CMDCTRL_RD_BYTES_LSB		20
+#define	CQSPI_REG_CMDCTRL_RD_EN_LSB		23
+#define	CQSPI_REG_CMDCTRL_OPCODE_LSB		24
+#define	CQSPI_REG_CMDCTRL_DUMMY_MASK		0x1F
+#define	CQSPI_REG_CMDCTRL_WR_BYTES_MASK		0x7
+#define	CQSPI_REG_CMDCTRL_ADD_BYTES_MASK	0x3
+#define	CQSPI_REG_CMDCTRL_RD_BYTES_MASK		0x7
+#define	CQSPI_REG_CMDCTRL_OPCODE_MASK		0xFF
+#define	CQSPI_REG_INDIRECTWR_START_MASK		(1 << 0)
+#define	CQSPI_REG_INDIRECTWR_CANCEL_MASK	(1 << 1)
+#define	CQSPI_REG_INDIRECTWR_INPROGRESS_MASK	(1 << 2)
+#define	CQSPI_REG_INDIRECTWR_DONE_MASK		(1 << 5)
+
+#define CQSPI_REG_WRPROT_ENABLE_MASK		(1 << 1)
+
+/* Transfer mode */
+#define CQSPI_INST_TYPE_SINGLE			0
+#define CQSPI_INST_TYPE_DUAL			1
+#define CQSPI_INST_TYPE_QUAD			2
+
+/* controller operation setting */
+#define CQSPI_READ_CAPTURE_MAX_DELAY		16
+#define CQSPI_REG_POLL_US			1
+#define CQSPI_REG_RETRY				10000
+#define CQSPI_POLL_IDLE_RETRY			3
+#define CQSPI_STIG_DATA_LEN_MAX			8
+
+#endif /* __CADENCE_QSPI_H__ */
diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c
index d0fc165..ac26b00 100644
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -869,9 +869,9 @@ static int spi_nor_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 	{ "mx25l3255e",  INFO(0xc29e16, 0, 64 * 1024,  64, SECT_4K) },
 	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, SECT_4K) },
 	{ "mx25u6435f",  INFO(0xc22537, 0, 64 * 1024, 128, SECT_4K) },
-	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
+	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
-	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
+	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
 	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_QUAD_READ) },
 	{ "mx66l1g55g",  INFO(0xc2261b, 0, 64 * 1024, 2048, SPI_NOR_QUAD_READ) },
@@ -1001,7 +1001,7 @@ static int spi_nor_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
-	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512, SECT_4K) },
+	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 
 	/* Catalyst / On Semiconductor -- non-JEDEC */
 	{ "cat25c11", CAT25_INFO(  16, 8, 16, 1, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
@@ -1168,6 +1168,20 @@ static int spi_nor_write(struct mtd_info *mtd, loff_t to, size_t len,
 	if (ret)
 		return ret;
 
+	/* Fast memory-mapped write support */
+	if (nor->write_mmap) {
+		ssize_t written;
+
+		ret = nor->write_mmap(nor, to, len, buf);
+		if (ret < 0)
+			goto write_err;
+		written = ret;
+		*retlen += written;
+		ret = spi_nor_wait_till_ready(nor);
+		spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_WRITE);
+		return ret;
+	}
+
 	for (i = 0; i < len; ) {
 		ssize_t written;
 
diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c
index 8d6208c..b480a0c 100644
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev.c
@@ -471,6 +471,9 @@ unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx)
 		struct can_frame *cf = (struct can_frame *)skb->data;
 		u8 dlc = cf->can_dlc;
 
+		if (!(skb->tstamp.tv64))
+			__net_timestamp(skb);
+
 		netif_rx(priv->echo_skb[idx]);
 		priv->echo_skb[idx] = NULL;
 
@@ -613,6 +616,7 @@ struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf)
 	if (unlikely(!skb))
 		return NULL;
 
+	__net_timestamp(skb);
 	skb->protocol = htons(ETH_P_CAN);
 	skb->pkt_type = PACKET_BROADCAST;
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
@@ -642,6 +646,7 @@ struct sk_buff *alloc_canfd_skb(struct net_device *dev,
 	if (unlikely(!skb))
 		return NULL;
 
+	__net_timestamp(skb);
 	skb->protocol = htons(ETH_P_CANFD);
 	skb->pkt_type = PACKET_BROADCAST;
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
diff --git a/drivers/net/can/sja1000/sja1000.c b/drivers/net/can/sja1000/sja1000.c
index 9f10779..353d0225 100644
--- a/drivers/net/can/sja1000/sja1000.c
+++ b/drivers/net/can/sja1000/sja1000.c
@@ -184,8 +184,10 @@ static void chipset_init(struct net_device *dev)
 {
 	struct sja1000_priv *priv = netdev_priv(dev);
 
-	/* set clock divider and output control register */
-	priv->write_reg(priv, SJA1000_CDR, priv->cdr | CDR_PELICAN);
+	if (!priv->cdr_missing) {
+		/* set clock divider and output control register */
+		priv->write_reg(priv, SJA1000_CDR, priv->cdr | CDR_PELICAN);
+	}
 
 	/* set acceptance filter (accept all) */
 	priv->write_reg(priv, SJA1000_ACCC0, 0x00);
@@ -210,8 +212,10 @@ static void sja1000_start(struct net_device *dev)
 		set_reset_mode(dev);
 
 	/* Initialize chip if uninitialized at this stage */
-	if (!(priv->read_reg(priv, SJA1000_CDR) & CDR_PELICAN))
-		chipset_init(dev);
+	if (!priv->cdr_missing) {
+		if (!(priv->read_reg(priv, SJA1000_CDR) & CDR_PELICAN))
+			chipset_init(dev);
+	}
 
 	/* Clear error counters and error code capture */
 	priv->write_reg(priv, SJA1000_TXERR, 0x0);
@@ -664,12 +668,14 @@ void free_sja1000dev(struct net_device *dev)
 
 int register_sja1000dev(struct net_device *dev)
 {
+	struct sja1000_priv *priv = netdev_priv(dev);
 	int ret;
 
 	if (!sja1000_probe_chip(dev))
 		return -ENODEV;
 
-	dev->flags |= IFF_ECHO;	/* we support local echo */
+	if (!priv->no_loopback)
+		dev->flags |= IFF_ECHO;	/* we support local echo */
 	dev->netdev_ops = &sja1000_netdev_ops;
 
 	set_reset_mode(dev);
diff --git a/drivers/net/can/sja1000/sja1000.h b/drivers/net/can/sja1000/sja1000.h
index 9d46398..a07529d 100644
--- a/drivers/net/can/sja1000/sja1000.h
+++ b/drivers/net/can/sja1000/sja1000.h
@@ -170,6 +170,8 @@ struct sja1000_priv {
 	u16 flags;		/* custom mode flags */
 	u8 ocr;			/* output control register */
 	u8 cdr;			/* clock divider register */
+	u8 cdr_missing;		/* missing clock divider register */
+	bool no_loopback;	/* HW doesn't see tx messages on rx */
 };
 
 struct net_device *alloc_sja1000dev(int sizeof_priv);
diff --git a/drivers/net/can/sja1000/sja1000_platform.c b/drivers/net/can/sja1000/sja1000_platform.c
index dc9c6db..b962f8f 100644
--- a/drivers/net/can/sja1000/sja1000_platform.c
+++ b/drivers/net/can/sja1000/sja1000_platform.c
@@ -25,6 +25,7 @@
 #include <linux/irq.h>
 #include <linux/can/dev.h>
 #include <linux/can/platform/sja1000.h>
+#include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
@@ -199,6 +200,12 @@ static void sp_populate_of(struct sja1000_priv *priv, struct device_node *of)
 
 	if (!of_property_read_bool(of, "nxp,no-comparator-bypass"))
 		priv->cdr |= CDR_CBP; /* default */
+
+	if (of_property_read_bool(of, "nxp,no-cdr"))
+		priv->cdr_missing = 1;
+
+	if (of_property_read_bool(of, "nxp,no-loopback"))
+		priv->no_loopback = true;
 }
 
 static struct sja1000_of_data technologic_data = {
@@ -225,6 +232,7 @@ static int sp_probe(struct platform_device *pdev)
 	const struct of_device_id *of_id;
 	const struct sja1000_of_data *of_data = NULL;
 	size_t priv_sz = 0;
+	struct clk *clk;
 
 	pdata = dev_get_platdata(&pdev->dev);
 	if (!pdata && !of) {
@@ -288,6 +296,13 @@ static int sp_probe(struct platform_device *pdev)
 		sp_populate(priv, pdata, res_mem->flags);
 	}
 
+	/* If we have a clock, enable it and use it to get the clock rate */
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (!IS_ERR(clk)) {
+		clk_prepare_enable(clk);
+		priv->can.clock.freq = clk_get_rate(clk) / 2;
+	}
+
 	platform_set_drvdata(pdev, dev);
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
diff --git a/drivers/net/can/slcan.c b/drivers/net/can/slcan.c
index eb71737..0fb0a03 100644
--- a/drivers/net/can/slcan.c
+++ b/drivers/net/can/slcan.c
@@ -207,6 +207,7 @@ static void slc_bump(struct slcan *sl)
 	if (!skb)
 		return;
 
+	__net_timestamp(skb);
 	skb->dev = sl->dev;
 	skb->protocol = htons(ETH_P_CAN);
 	skb->pkt_type = PACKET_BROADCAST;
diff --git a/drivers/net/can/vcan.c b/drivers/net/can/vcan.c
index 674f367..0ce868d 100644
--- a/drivers/net/can/vcan.c
+++ b/drivers/net/can/vcan.c
@@ -78,6 +78,9 @@ static void vcan_rx(struct sk_buff *skb, struct net_device *dev)
 	skb->dev       = dev;
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 
+	if (!(skb->tstamp.tv64))
+		__net_timestamp(skb);
+
 	netif_rx_ni(skb);
 }
 
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index 8cc7467..1391b94 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -112,6 +112,7 @@ source "drivers/net/ethernet/mellanox/Kconfig"
 source "drivers/net/ethernet/micrel/Kconfig"
 source "drivers/net/ethernet/microchip/Kconfig"
 source "drivers/net/ethernet/moxa/Kconfig"
+source "drivers/net/ethernet/morethanip/Kconfig"
 source "drivers/net/ethernet/myricom/Kconfig"
 
 config FEALNX
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index a09423d..90696ae 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -67,7 +67,6 @@ obj-$(CONFIG_NET_VENDOR_PASEMI) += pasemi/
 obj-$(CONFIG_NET_VENDOR_QLOGIC) += qlogic/
 obj-$(CONFIG_NET_VENDOR_QUALCOMM) += qualcomm/
 obj-$(CONFIG_NET_VENDOR_REALTEK) += realtek/
-obj-$(CONFIG_NET_VENDOR_RENESAS) += renesas/
 obj-$(CONFIG_NET_VENDOR_RDC) += rdc/
 obj-$(CONFIG_NET_VENDOR_ROCKER) += rocker/
 obj-$(CONFIG_NET_VENDOR_SAMSUNG) += samsung/
@@ -89,3 +88,5 @@ obj-$(CONFIG_NET_VENDOR_VIA) += via/
 obj-$(CONFIG_NET_VENDOR_WIZNET) += wiznet/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
+obj-$(CONFIG_NET_VENDOR_MORETHANIP) += morethanip/
+obj-$(CONFIG_NET_VENDOR_RENESAS) += renesas/
diff --git a/drivers/net/ethernet/morethanip/Kconfig b/drivers/net/ethernet/morethanip/Kconfig
new file mode 100644
index 0000000..9afc526
--- /dev/null
+++ b/drivers/net/ethernet/morethanip/Kconfig
@@ -0,0 +1,29 @@
+#
+# MoreThanIP device configuration
+#
+
+config NET_VENDOR_MORETHANIP
+	bool "MoreThanIP devices"
+	default n
+	---help---
+	  If you have a network (Ethernet) hardware belonging to this class, say
+	  Y and read the Ethernet-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
+
+	  Note that the answer to this question doesn't directly affect the
+	  kernel: saying N will just cause the configurator to skip all
+	  the questions about MoreThanIP drivers. If you say Y, you will be
+	  asked for your specific IP in the following questions.
+
+if NET_VENDOR_MORETHANIP
+
+config MTIP_SWITCH
+	tristate "Embedded MoreThanIP 5-port Ethernet switch"
+	depends on OF
+	select MII
+	select PHYLIB
+	---help---
+	  Embedded MoreThanIP 5-port Ethernet switch.
+	  The Renesas RZ/N1 device has this switch built in.
+
+endif # NET_VENDOR_MORETHANIP
diff --git a/drivers/net/ethernet/morethanip/Makefile b/drivers/net/ethernet/morethanip/Makefile
new file mode 100644
index 0000000..99c3bd7
--- /dev/null
+++ b/drivers/net/ethernet/morethanip/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the MoreThanIP device drivers.
+#
+
+obj-$(CONFIG_MTIP_SWITCH) += mtip_switch.o
diff --git a/drivers/net/ethernet/morethanip/mtip_switch.c b/drivers/net/ethernet/morethanip/mtip_switch.c
new file mode 100644
index 0000000..15f1313
--- /dev/null
+++ b/drivers/net/ethernet/morethanip/mtip_switch.c
@@ -0,0 +1,655 @@
+/*
+ * MoreThanIP 5-port switch MDIO driver
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd.
+ *
+ * Based on DaVinci MDIO Module driver
+ * Copyright (C) 2010 Texas Instruments.
+ *
+ * Shamelessly ripped out of davinci_emac.c, original copyrights follow:
+ * Copyright (C) 2009 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/io.h>
+#include <linux/if_ether.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <linux/pinctrl-rzn1.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#define DRV_NAME	"mt5pt_switch"
+#define DRV_VERSION	"0.1"
+
+/* Number of downstream ports */
+#define MT5PT_NR_PORTS 4
+
+#define MT5PT_UPSTREAM_PORT_NR	4
+
+#define MDIO_TIMEOUT		100 /* in MDIO clocks */
+#define DEFAULT_MTU		1500
+#define MAX_MTU			9216
+#define FRM_LENGTH_EXTRA	34
+
+#define PHY_REG_MASK		0x1f
+#define PHY_ID_MASK		0x1f
+
+/* MoreThanIP 5pt Switch regs */
+#define MT5PT_REVISION		0x0
+#define MT5PT_SCRATCH		0x4
+#define MT5PT_PORT_ENA		0x8
+#define  MT5PT_PORT_ENA_TX(x)	BIT((x) + 16)
+#define  MT5PT_PORT_ENA_RX(x)	BIT(x)
+#define  MT5PT_PORT_ENA_TXRX(x)	(MT5PT_PORT_ENA_TX(x) | MT5PT_PORT_ENA_RX(x))
+#define MT5PT_AUTH_PORT(x)	(0x240 + (x) * 4)
+#define  MT5PT_AUTH_PORT_AUTHORIZED	BIT(0)
+#define  MT5PT_AUTH_PORT_CONTROLLED	BIT(1)
+#define  MT5PT_AUTH_PORT_EAPOL_EN	BIT(2)
+#define  MT5PT_AUTH_PORT_GUEST		BIT(3)
+#define  MT5PT_AUTH_PORT_EAPOL_PORT(x)	((x) << 12)
+#define MDIO_CFG_STATUS		0x700
+#define  MDIO_CFG_STATUS_BUSY	BIT(0)
+#define  MDIO_CFG_STATUS_ERR	BIT(1)
+#define  MDIO_CFG_MIN_DIV	5
+#define  MDIO_CFG_MAX_DIV	511
+#define MDIO_COMMAND		0x704
+#define  MDIO_COMMAND_READ	BIT(15)
+#define MDIO_DATA		0x708
+#define MT5PT_MAC_CMD_CFG(x)	(0x808 + (x) * 0x400)
+#define  MT5PT_TX_ENA		BIT(0)
+#define  MT5PT_RX_ENA		BIT(1)
+#define  MT5PT_MBPS_1000	BIT(3)
+#define MT5PT_MAC_FRM_LENGTHn(x)	(0x814 + (x) * 0x400)
+
+struct mt5pt_switch_port {
+	struct net_device *ndev;
+	struct mt5pt_switch *mt5pt;
+	int port_nr;
+	int phy_addr;
+	phy_interface_t phy_if;
+	struct phy_device *phy_dev;
+	int speed;
+	int link;
+};
+
+struct mt5pt_switch {
+	void __iomem	*regs;
+	spinlock_t	lock;	/* protect access to MDIO bus */
+	struct clk	*clk;
+	struct device	*dev;
+	struct mii_bus	*bus;
+
+	unsigned long mdio_bus_freq;
+	int nr_ports;
+	struct mt5pt_switch_port *ports[PHY_MAX_ADDR];
+};
+
+static void mt5pt_switch_port_enable(void __iomem *regs, int port_nr)
+{
+	u32 val;
+
+	val = readl(regs + MT5PT_AUTH_PORT(port_nr));
+	val |= MT5PT_AUTH_PORT_AUTHORIZED;
+	writel(val, regs + MT5PT_AUTH_PORT(port_nr));
+
+	val = readl(regs + MT5PT_PORT_ENA);
+	val |= MT5PT_PORT_ENA_TXRX(port_nr);
+	writel(val, regs + MT5PT_PORT_ENA);
+}
+
+static void mt5pt_switch_port_disable(void __iomem *regs, int port_nr)
+{
+	u32 val;
+
+	val = readl(regs + MT5PT_PORT_ENA);
+	val &= ~MT5PT_PORT_ENA_TXRX(port_nr);
+	writel(val, regs + MT5PT_PORT_ENA);
+}
+
+static void mt5pt_switch_port_mtu(void __iomem *regs, int port_nr, int mtu)
+{
+	writel(mtu + FRM_LENGTH_EXTRA, regs + MT5PT_MAC_FRM_LENGTHn(port_nr));
+}
+
+static void mt5pt_switch_handle_link_change(struct net_device *dev)
+{
+	struct mt5pt_switch_port *port = netdev_priv(dev);
+	struct mt5pt_switch *mt5pt = port->mt5pt;
+	struct phy_device *phydev = port->phy_dev;
+
+	if (phydev->link && (port->speed != phydev->speed)) {
+		u32 val = readl(mt5pt->regs + MT5PT_MAC_CMD_CFG(port->port_nr));
+		val &= ~MT5PT_MBPS_1000;
+		if (phydev->speed == SPEED_1000)
+			val |= MT5PT_MBPS_1000;
+		writel(val, mt5pt->regs + MT5PT_MAC_CMD_CFG(port->port_nr));
+
+		port->speed = phydev->speed;
+	}
+
+	if ((port->link != phydev->link) || (port->speed != phydev->speed))
+		phy_print_status(phydev);
+
+	port->link = phydev->link;
+}
+
+static void mt5pt_switch_setup_mdio(struct mt5pt_switch *mt5pt)
+{
+	u32 mdio_in, div, val;
+
+	mdio_in = clk_get_rate(mt5pt->clk);
+	div = (mdio_in / 2) / mt5pt->mdio_bus_freq;
+	if (div > MDIO_CFG_MAX_DIV)
+		div = MDIO_CFG_MAX_DIV;
+	if (div < MDIO_CFG_MIN_DIV)
+		div = MDIO_CFG_MIN_DIV;
+	val = div << 7;
+
+	/* Set MDIO hold time to 1 cpu cycle (min) */
+	val |= 0 << 2;
+
+	dev_info(mt5pt->dev, "MDIO clk is %d Hz\n", mdio_in / (2 * div + 1));
+	writel(val, mt5pt->regs + MDIO_CFG_STATUS);
+}
+
+static int mt5pt_switch_reset(struct mii_bus *bus)
+{
+	struct mt5pt_switch *mt5pt = bus->priv;
+	u32 ver;
+	int i;
+
+	spin_lock(&mt5pt->lock);
+	mt5pt_switch_setup_mdio(mt5pt);
+	spin_unlock(&mt5pt->lock);
+
+	/* dump hardware version info */
+	ver = readl(mt5pt->regs + MT5PT_REVISION);
+	dev_info(mt5pt->dev, "MoreThanIP 5-port switch revision %d\n",
+		 ver & 0xffff);
+
+	/* Disable all downstream ports */
+	for (i = 0; i < MT5PT_NR_PORTS; i++) {
+		mt5pt_switch_port_disable(mt5pt->regs, i);
+		mt5pt_switch_port_mtu(mt5pt->regs, i, MAX_MTU);
+	}
+
+	/* Enable upstream port */
+	mt5pt_switch_port_enable(mt5pt->regs, MT5PT_UPSTREAM_PORT_NR);
+	mt5pt_switch_port_mtu(mt5pt->regs, MT5PT_UPSTREAM_PORT_NR, MAX_MTU);
+
+	return 0;
+}
+
+/* wait until hardware is ready for another user access */
+static inline int mt5pt_switch_wait_for_mdio(struct mt5pt_switch *mt5pt)
+{
+	unsigned long timeout;
+	u32 reg;
+
+	/* divide by 10 because we udelay for 10us */
+	timeout = ((MDIO_TIMEOUT * 1000000) / mt5pt->mdio_bus_freq) / 10;
+
+	while (timeout--) {
+		reg = readl(mt5pt->regs + MDIO_CFG_STATUS);
+		if ((reg & MDIO_CFG_STATUS_BUSY) == 0)
+			return 0;
+
+		udelay(10);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int mt5pt_switch_read(struct mii_bus *bus, int phy_id, int phy_reg)
+{
+	struct mt5pt_switch *mt5pt = bus->priv;
+	u32 reg;
+	int ret;
+
+	if (phy_reg & ~PHY_REG_MASK || phy_id & ~PHY_ID_MASK)
+		return -EINVAL;
+
+	reg = MDIO_COMMAND_READ | (phy_id << 5) | phy_reg;
+
+	spin_lock(&mt5pt->lock);
+
+	ret = mt5pt_switch_wait_for_mdio(mt5pt);
+	if (ret < 0) {
+		spin_unlock(&mt5pt->lock);
+		return ret;
+	}
+
+	writel(reg, mt5pt->regs + MDIO_COMMAND);
+
+	ret = mt5pt_switch_wait_for_mdio(mt5pt);
+	if (ret < 0) {
+		spin_unlock(&mt5pt->lock);
+		return ret;
+	}
+
+	ret = readl(mt5pt->regs + MDIO_DATA);
+
+	reg = readl(mt5pt->regs + MDIO_CFG_STATUS);
+	if (reg & MDIO_CFG_STATUS_ERR) {
+		spin_unlock(&mt5pt->lock);
+		return -EIO;
+	}
+
+	spin_unlock(&mt5pt->lock);
+
+	dev_dbg(mt5pt->dev, "phy[%d] reg%d=0x%x\n", phy_id, phy_reg, ret);
+	return ret;
+}
+
+static int mt5pt_switch_write(struct mii_bus *bus, int phy_id,
+			      int phy_reg, u16 phy_data)
+{
+	struct mt5pt_switch *mt5pt = bus->priv;
+	u32 reg;
+	int ret;
+
+	if (phy_reg & ~PHY_REG_MASK || phy_id & ~PHY_ID_MASK)
+		return -EINVAL;
+	dev_dbg(mt5pt->dev, "phy[%d] reg%d=0x%x\n", phy_id, phy_reg, phy_data);
+
+	reg = (phy_id << 5) | phy_reg;
+
+	spin_lock(&mt5pt->lock);
+
+	ret = mt5pt_switch_wait_for_mdio(mt5pt);
+	if (ret < 0) {
+		spin_unlock(&mt5pt->lock);
+		return ret;
+	}
+
+	writel(reg, mt5pt->regs + MDIO_COMMAND);
+	writel(phy_data, mt5pt->regs + MDIO_DATA);
+
+	/* Wait for it to complete */
+	ret = mt5pt_switch_wait_for_mdio(mt5pt);
+
+	spin_unlock(&mt5pt->lock);
+
+	return ret;
+}
+
+static void mt5pt_switch_reset_phy(struct platform_device *pdev)
+{
+	int err, phy_reset;
+	int msec = 1;
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!np)
+		return;
+
+	of_property_read_u32(np, "phy-reset-duration", &msec);
+
+	phy_reset = of_get_named_gpio(np, "phy-reset-gpios", 0);
+	if (!gpio_is_valid(phy_reset))
+		return;
+
+	err = devm_gpio_request_one(&pdev->dev, phy_reset,
+				    GPIOF_OUT_INIT_LOW, "phy-reset");
+	if (err) {
+		dev_err(&pdev->dev, "failed to get phy-reset-gpios: %d\n", err);
+		return;
+	}
+	msleep(msec);
+	gpio_set_value(phy_reset, 1);
+}
+
+static int mt5pt_switch_probe_dt(struct mt5pt_switch *mt5pt, struct device *dev)
+{
+	struct device_node *node = dev->of_node;
+	struct device_node *port_node;
+	u32 prop;
+	int nr_ports;
+	int port_nr = 0;
+
+	if (!node)
+		return -EINVAL;
+
+	if (of_property_read_u32(node, "bus_freq", &prop)) {
+		dev_err(dev, "Missing bus_freq property in DT\n");
+		return -EINVAL;
+	}
+	mt5pt->mdio_bus_freq = prop;
+
+	nr_ports = of_get_child_count(node);
+	if (nr_ports != MT5PT_NR_PORTS) {
+		dev_err(dev, "%s needs %d ports\n", node->full_name,
+			MT5PT_NR_PORTS);
+		return -EINVAL;
+	}
+
+	for_each_child_of_node(node, port_node) {
+		struct net_device *ndev;
+		struct mt5pt_switch_port *port;
+		struct device_node *phy_node;
+		int phy_mode;
+		int phy_addr;
+
+		/* If there is a phandle for the phy, go look there */
+		phy_node = of_parse_phandle(port_node, "phy-handle", 0);
+		if (!phy_node)
+			phy_node = port_node;
+
+		/* Do not directly assign to data->slave[i].phy_if as
+		 * phy_interface_t type is unsigned
+		 */
+		phy_mode = of_get_phy_mode(phy_node);
+		if (phy_mode < 0) {
+			dev_warn(dev, "%s missing phy-mode, skipping port\n",
+				 phy_node->full_name);
+			port_nr++;
+			continue;
+		}
+
+		phy_addr = of_mdio_parse_addr(dev, phy_node);
+		if (phy_addr < 0) {
+			dev_warn(dev, "%s missing phy addr, skipping port\n",
+				 phy_node->full_name);
+			port_nr++;
+			continue;
+		}
+
+		ndev = alloc_etherdev(sizeof(struct mt5pt_switch_port));
+		if (!ndev)
+			return -ENOMEM;
+
+		SET_NETDEV_DEV(ndev, dev);
+
+		port = netdev_priv(ndev);
+
+		mt5pt->ports[port_nr] = port;
+		port->ndev = ndev;
+		port->mt5pt = mt5pt;
+		port->port_nr = port_nr;
+		port->phy_addr = phy_addr;
+		port->phy_if = phy_mode;
+		port->phy_dev = NULL;
+
+		port_nr++;
+	}
+
+	/* Enable the upstream port */
+	mt5pt_switch_port_enable(mt5pt->regs, MT5PT_UPSTREAM_PORT_NR);
+
+	return 0;
+}
+
+static int mt5pt_switch_port_open(struct net_device *dev)
+{
+	struct mt5pt_switch_port *port = netdev_priv(dev);
+	struct mt5pt_switch *mt5pt = port->mt5pt;
+	struct phy_device *phydev = port->phy_dev;
+
+	dev_info(mt5pt->dev, "open port %c\n", 'A' + port->port_nr);
+
+	/* if the phy is not yet registered, retry later */
+	if (!phydev)
+		return -EAGAIN;
+
+	mt5pt_switch_port_enable(mt5pt->regs, port->port_nr);
+	dev->mtu = MAX_MTU;
+
+	/* schedule a link state check */
+	phy_start(phydev);
+
+	return 0;
+}
+
+static int mt5pt_switch_port_stop(struct net_device *dev)
+{
+	struct mt5pt_switch_port *port = netdev_priv(dev);
+	struct mt5pt_switch *mt5pt = port->mt5pt;
+
+	dev_info(mt5pt->dev, "stop port %c\n", 'A' + port->port_nr);
+
+	mt5pt_switch_port_disable(mt5pt->regs, port->port_nr);
+
+	return 0;
+}
+
+static int mt5pt_switch_port_ioctl(struct net_device *dev, struct ifreq *ifrq, int cmd)
+{
+	struct mt5pt_switch_port *port = netdev_priv(dev);
+	struct mt5pt_switch *mt5pt = port->mt5pt;
+	struct phy_device *phydev = port->phy_dev;
+
+	dev_dbg(mt5pt->dev, "ioctl port %c\n", 'A' + port->port_nr);
+
+	return phy_mii_ioctl(phydev, ifrq, cmd);
+}
+
+static netdev_tx_t mt5pt_switch_port_start_xmit(struct sk_buff *skb,
+						struct net_device *dev)
+{
+	struct mt5pt_switch_port *port = netdev_priv(dev);
+	struct mt5pt_switch *mt5pt = port->mt5pt;
+
+	dev_info(mt5pt->dev, "Switch devices can't send data, use the GMAC\n");
+
+	dev->stats.tx_dropped++;
+	netif_stop_queue(dev);
+
+	return NETDEV_TX_BUSY;
+}
+
+static int mt5pt_switch_port_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct mt5pt_switch_port *port = netdev_priv(dev);
+	struct mt5pt_switch *mt5pt = port->mt5pt;
+
+	mt5pt_switch_port_mtu(mt5pt->regs, port->port_nr, new_mtu);
+	dev->mtu = new_mtu;
+
+	return 0;
+}
+
+static const struct net_device_ops mt5pt_switch_netdev_ops = {
+	/* When using an NFS rootfs, we can only bring up the GMAC behind the
+	 * upstream port. So we need ndo_init to enable the Switch's downstream
+	 * ports and kick the PHY.
+	 */
+	.ndo_init		= mt5pt_switch_port_open,
+	.ndo_open		= mt5pt_switch_port_open,
+	.ndo_stop		= mt5pt_switch_port_stop,
+	.ndo_do_ioctl		= mt5pt_switch_port_ioctl,
+	.ndo_start_xmit		= mt5pt_switch_port_start_xmit,
+	.ndo_change_mtu		= mt5pt_switch_port_change_mtu,
+};
+
+static void netdev_get_drvinfo(struct net_device *dev,
+			struct ethtool_drvinfo *info)
+{
+	strlcpy(info->driver, DRV_NAME, sizeof(info->driver));
+	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
+}
+
+static int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct mt5pt_switch_port *port = netdev_priv(dev);
+
+	return  phy_ethtool_gset(port->phy_dev, cmd);
+}
+
+static int netdev_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct mt5pt_switch_port *port = netdev_priv(dev);
+
+	return phy_ethtool_sset(port->phy_dev, cmd);
+}
+
+static const struct ethtool_ops netdev_ethtool_ops = {
+	.get_drvinfo		= netdev_get_drvinfo,
+	.get_settings		= netdev_get_settings,
+	.set_settings		= netdev_set_settings,
+	.get_link		= ethtool_op_get_link,
+	.get_ts_info		= ethtool_op_get_ts_info,
+};
+
+static int mt5pt_switch_remove(struct platform_device *pdev)
+{
+	struct mt5pt_switch *mt5pt = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < MT5PT_NR_PORTS; i++) {
+		struct mt5pt_switch_port *port = mt5pt->ports[i];
+
+		if (port->ndev) {
+			unregister_netdev(port->ndev);
+			free_netdev(port->ndev);
+		}
+	}
+
+	if (mt5pt->bus)
+		mdiobus_unregister(mt5pt->bus);
+
+	return 0;
+}
+
+static int mt5pt_switch_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mt5pt_switch *mt5pt;
+	struct resource *res;
+	int ret, i;
+
+	mt5pt = devm_kzalloc(dev, sizeof(struct mt5pt_switch), GFP_KERNEL);
+	if (!mt5pt)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mt5pt->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(mt5pt->regs))
+		return PTR_ERR(mt5pt->regs);
+
+	mt5pt->clk = devm_clk_get(dev, "fck");
+	if (IS_ERR(mt5pt->clk)) {
+		dev_err(dev, "failed to get device clock\n");
+		return PTR_ERR(mt5pt->clk);
+	}
+	clk_prepare_enable(mt5pt->clk);
+
+	mt5pt->bus = devm_mdiobus_alloc(dev);
+	if (!mt5pt->bus) {
+		dev_err(dev, "failed to alloc mii bus\n");
+		return -ENOMEM;
+	}
+
+	if (!dev->of_node) {
+		dev_err(dev, "Missing DT node\n");
+		return -EINVAL;
+	}
+
+	mt5pt_switch_reset_phy(pdev);
+
+	mt5pt_switch_probe_dt(mt5pt, dev);
+	snprintf(mt5pt->bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);
+
+	mt5pt->bus->name	= dev_name(dev);
+	mt5pt->bus->read	= mt5pt_switch_read,
+	mt5pt->bus->write	= mt5pt_switch_write,
+	mt5pt->bus->reset	= mt5pt_switch_reset,
+	mt5pt->bus->parent	= dev;
+	mt5pt->bus->priv	= mt5pt;
+
+	dev_set_drvdata(dev, mt5pt);
+	mt5pt->dev = dev;
+	spin_lock_init(&mt5pt->lock);
+
+	/* register the mii bus */
+	ret = of_mdiobus_register(mt5pt->bus, dev->of_node);
+	if (ret)
+		return ret;
+
+	/* attach to the phys */
+	for (i = 0; i < MT5PT_NR_PORTS; i++) {
+		struct mt5pt_switch_port *port = mt5pt->ports[i];
+		struct phy_device *phydev;
+
+		if (!port)
+			continue;
+
+		phydev = mdiobus_get_phy(mt5pt->bus, port->phy_addr);
+		port->phy_dev = phydev;
+		if (!phydev)
+			continue;
+
+		dev_info(dev, "phy@%d: %s\n", phydev->mdio.addr,
+			 phydev->drv ? phydev->drv->name : "unknown");
+
+		/* attach to the phy */
+		ret = phy_connect_direct(port->ndev, phydev,
+					 &mt5pt_switch_handle_link_change,
+					 port->phy_if);
+		if (ret)
+			netdev_err(port->ndev, "Could not attach to PHY\n");
+
+		port->ndev->netdev_ops = &mt5pt_switch_netdev_ops;
+		port->ndev->ethtool_ops = &netdev_ethtool_ops;
+
+		/* libphy will determine the link state */
+		netif_carrier_off(port->ndev);
+
+		if (register_netdev(port->ndev))
+			goto err;
+	}
+
+	return 0;
+
+err:
+	mt5pt_switch_remove(pdev);
+
+	return ret;
+}
+
+static const struct of_device_id mt5pt_switch_of_mtable[] = {
+	{ .compatible = "mtip,5pt_switch", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, mt5pt_switch_of_mtable);
+
+static struct platform_driver mt5pt_switch_driver = {
+	.driver = {
+		.name	 = DRV_NAME,
+		.of_match_table = of_match_ptr(mt5pt_switch_of_mtable),
+	},
+	.probe = mt5pt_switch_probe,
+	.remove = mt5pt_switch_remove,
+};
+
+static int __init mt5pt_switch_init(void)
+{
+	return platform_driver_register(&mt5pt_switch_driver);
+}
+device_initcall(mt5pt_switch_init);
+
+static void __exit mt5pt_switch_exit(void)
+{
+	platform_driver_unregister(&mt5pt_switch_driver);
+}
+module_exit(mt5pt_switch_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MoreThanIP 5-port switch driver");
diff --git a/drivers/net/ethernet/renesas/Kconfig b/drivers/net/ethernet/renesas/Kconfig
index 85ec447..61ddf3f 100644
--- a/drivers/net/ethernet/renesas/Kconfig
+++ b/drivers/net/ethernet/renesas/Kconfig
@@ -42,5 +42,11 @@ config RAVB
 	  Renesas Ethernet AVB device driver.
 	  This driver supports the following SoCs:
 		- R8A779x.
+config RZN1_MIIC
+	tristate "Renesas RZ/N1 RGMII/GMII Convertor"
+	select MII
+	---help---
+	  The Renesas RZ/N1 device uses an RGMII/GMII Convertor (MIIC) on each
+	  ethernet PHY interface.
 
 endif # NET_VENDOR_RENESAS
diff --git a/drivers/net/ethernet/renesas/Makefile b/drivers/net/ethernet/renesas/Makefile
index a05102a..63953fd 100644
--- a/drivers/net/ethernet/renesas/Makefile
+++ b/drivers/net/ethernet/renesas/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_SH_ETH) += sh_eth.o
 ravb-objs := ravb_main.o ravb_ptp.o
 
 obj-$(CONFIG_RAVB) += ravb.o
+obj-$(CONFIG_RZN1_MIIC) += rzn1_miic.o
diff --git a/drivers/net/ethernet/renesas/rzn1_miic.c b/drivers/net/ethernet/renesas/rzn1_miic.c
new file mode 100644
index 0000000..c570457
--- /dev/null
+++ b/drivers/net/ethernet/renesas/rzn1_miic.c
@@ -0,0 +1,355 @@
+/*
+ * Renesas RZ/N1 RGMII/GMII Converter (MIIC) driver.
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd
+ *
+ * Each ethernet PHY interface goes through a RGMII/GMII Converter. This piece
+ * of hardware needs to know about the interface type, speed and duplex.
+ * The hardware documentation for the RGMII/GMII Converters numbers them 1 to 5,
+ * however all RZ/N1 software uses 0 based indexes. Therefore the phy_nr field
+ * is numbered 0 to 4.
+ *
+ * This driver also sets the SwitchCore registers with the correct speed and
+ * duplex since these are also part of the RIN registers.
+ *
+ * Since all of these registers are part of the RIN SwitchCore, this driver
+ * also sets the RIN operation mode, i.e. which IPs are multiplexed to the
+ * PHYs.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+/* RIN Ether Accessory (Switch Control) regs */
+#define PRCMD			0x0		/* Ethernet Protect */
+#define IDCODE			0x4		/* EtherSwitch IDCODE */
+#define MODCTRL			0x8		/* Mode Control */
+#define PTP_MODE_CTRL		0xc		/* PTP Mode Control */
+#define PHY_LINK_MODE		0x14		/* Ethernet PHY Link Mode */
+
+/* RIN RGMII/RMII Converter regs */
+#define CONVCTRL(x)		(0x100 + (x) * 4) /* RGMII/RMII Converter */
+#define  CONVCTRL_10_MBPS		0
+#define  CONVCTRL_100_MBPS		BIT(0)
+#define  CONVCTRL_1000_MBPS		BIT(1)
+#define  CONVCTRL_MII			0
+#define  CONVCTRL_RMII			BIT(2)
+#define  CONVCTRL_RGMII			BIT(3)
+#define  CONVCTRL_REF_CLK_OUT		BIT(4)
+#define  CONVCTRL_HALF_DUPLEX		0
+#define  CONVCTRL_FULL_DUPLEX		BIT(8)
+#define CONVRST			0x114		/* RGMII/RMII Converter RST */
+#define  PHYIF_RST(x)			BIT(x)
+
+/* RIN SwitchCore regs */
+#define RIN_SWCTRL		0x304		/* SwitchCore Control */
+#define  RIN_SWCTRL_MPBS_10(x)		(((0 << 4) | (1 << 0)) << (x))
+#define  RIN_SWCTRL_MPBS_100(x)		(((0 << 4) | (0 << 0)) << (x))
+#define  RIN_SWCTRL_MPBS_1000(x)	(((1 << 4) | (0 << 0)) << (x))
+#define  RIN_SWCTRL_MPBS_MASK(x)	(((1 << 4) | (1 << 0)) << (x))
+#define RIN_SWDUPC		0x308		/* SwitchCore Duplex Mode */
+#define  RIN_SWDUPC_DUPLEX_MASK(x)	BIT(x)
+#define  RIN_SWDUPC_DUPLEX_FULL(x)	BIT(x)
+
+#define MIIC_MAX_NR_PORTS 5
+
+struct rzn1_miic_port {
+	struct rzn1_miic *miic;
+	int phy_nr;
+	phy_interface_t phy_if;
+	struct phy_device *phy_dev;
+	int speed;
+	int duplex;
+};
+
+struct rzn1_miic {
+	struct device *dev;
+	void __iomem *regs;
+	struct clk *clk;
+	struct rzn1_miic_port *ports[MIIC_MAX_NR_PORTS];
+};
+
+static void rin_writel_to_protected(struct rzn1_miic *miic, u32 val, u32 reg)
+{
+	/* RIN: Unprotect register writes */
+	writel(0x00a5, miic->regs + PRCMD);
+	writel(0x0001, miic->regs + PRCMD);
+	writel(0xfffe, miic->regs + PRCMD);
+	writel(0x0001, miic->regs + PRCMD);
+
+	writel(val, miic->regs + reg);
+
+	/* Enable protection */
+	writel(0x0000, miic->regs + PRCMD);
+}
+
+void rzn1_switchcore_adjust(struct rzn1_miic_port *port, int duplex, int speed)
+{
+	struct rzn1_miic *miic = port->miic;
+	/* This reg use switch port numbers, not phy interface numbers! */
+	int port_nr = 4 - port->phy_nr;
+	u32 val;
+
+	/* We only handle speed/duplex changes on the switch ports */
+	if (port_nr > 3)
+		return;
+
+	/* speed */
+	val = readl(miic->regs + RIN_SWCTRL);
+	val &= ~RIN_SWCTRL_MPBS_MASK(port_nr);
+
+	if (speed == SPEED_1000)
+		val |= RIN_SWCTRL_MPBS_1000(port_nr);
+	else if (speed == SPEED_100)
+		val |= RIN_SWCTRL_MPBS_100(port_nr);
+	else
+		val |= RIN_SWCTRL_MPBS_10(port_nr);
+
+	rin_writel_to_protected(miic, val, RIN_SWCTRL);
+
+	/* duplex */
+	val = readl(miic->regs + RIN_SWDUPC);
+	val &= ~RIN_SWDUPC_DUPLEX_MASK(port_nr);
+	if (duplex == DUPLEX_FULL)
+		val |= RIN_SWDUPC_DUPLEX_FULL(port_nr);
+	rin_writel_to_protected(miic, val, RIN_SWDUPC);
+}
+
+static void rzn1_miic_adjust(struct rzn1_miic_port *port, int duplex, int speed)
+{
+	struct rzn1_miic *miic = port->miic;
+	u32 val = 0;
+
+	val = readl(miic->regs + CONVCTRL(port->phy_nr));
+
+	/* Keep the MII interface type bits */
+	val &= CONVCTRL_MII | CONVCTRL_RMII | CONVCTRL_RGMII |
+		CONVCTRL_REF_CLK_OUT;
+
+	/* The interface type and speed bits are somewhat intertwined */
+	if (val != CONVCTRL_MII) {
+		if (speed == SPEED_1000)
+			val |= CONVCTRL_1000_MBPS;
+		else if (speed == SPEED_100)
+			val |= CONVCTRL_100_MBPS;
+		else if (speed == SPEED_10)
+			val |= CONVCTRL_10_MBPS;
+	}
+
+	if (duplex == DUPLEX_FULL)
+		val |= CONVCTRL_FULL_DUPLEX;
+
+	writel(val, miic->regs + CONVCTRL(port->phy_nr));
+
+	port->speed = speed;
+	port->duplex = duplex;
+}
+
+static void rzn1_miic_link_adjust(void *priv)
+{
+	struct rzn1_miic_port *port = priv;
+	struct rzn1_miic *miic = port->miic;
+	struct phy_device *phydev = port->phy_dev;
+
+	if (phydev->link &&
+	    ((port->speed != phydev->speed) ||
+	    (port->duplex != phydev->duplex))) {
+		rzn1_miic_adjust(port, phydev->duplex, phydev->speed);
+		rzn1_switchcore_adjust(port, phydev->duplex, phydev->speed);
+		dev_info(miic->dev, "RGMII/GMII Converter %d link up, %dMbps\n",
+			 port->phy_nr, phydev->speed);
+	}
+}
+
+static void rzn1_miic_setup(struct rzn1_miic_port *port, int duplex, int speed,
+			    int rmii_ref_clk_out)
+{
+	struct rzn1_miic *miic = port->miic;
+	u32 val = 0;
+
+	dev_dbg(miic->dev, "Setup RGMII/GMII Converter\n");
+
+	switch (port->phy_if) {
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		val |= CONVCTRL_RGMII;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		val |= CONVCTRL_RMII;
+		break;
+	case PHY_INTERFACE_MODE_MII:
+		val |= CONVCTRL_MII;
+		break;
+	default:
+		dev_err(miic->dev, "Unsupported PHY %d, type %d\n",
+			port->phy_nr, port->phy_if);
+		return;
+	}
+
+	if (port->phy_if == PHY_INTERFACE_MODE_RMII && rmii_ref_clk_out)
+		val |= CONVCTRL_REF_CLK_OUT;
+
+	writel(val, miic->regs + CONVCTRL(port->phy_nr));
+
+	rzn1_miic_adjust(port, duplex, speed);
+
+	/* reset */
+	val = readl(miic->regs + CONVRST);
+	val &= ~PHYIF_RST(port->phy_nr);
+	rin_writel_to_protected(miic, val, CONVRST);
+	usleep_range(1000, 2000);
+	val |= PHYIF_RST(port->phy_nr);
+	rin_writel_to_protected(miic, val, CONVRST);
+}
+
+static int rzn1_miic_setup_ports(struct rzn1_miic *miic, struct device *dev)
+{
+	struct device_node *node = dev->of_node;
+	struct device_node *port_node;
+	int nr_ports;
+	int phy_nr = 0;
+	u32 prop;
+
+	if (!node)
+		return -EINVAL;
+
+	nr_ports = of_get_child_count(node);
+	if (nr_ports > MIIC_MAX_NR_PORTS) {
+		dev_err(dev, "%s has too many PHY ports\n", node->full_name);
+		return -EINVAL;
+	}
+	dev_info(dev, "nr phy ports %d\n", nr_ports);
+
+	if (of_property_read_u32(node, "mode_control", &prop)) {
+		dev_err(dev, "%s missing mode_control property\n",
+			node->full_name);
+		return -EINVAL;
+	}
+
+	/* RIN: Mode Control */
+	rin_writel_to_protected(miic, prop, MODCTRL);
+
+	/* Each port node in DT directly corresponds to the PHY MIIs, i.e. the
+	 * order of the nodes must match the MIIs and if you are not using one,
+	 * an empty node must still be present.
+	 */
+	for_each_child_of_node(node, port_node) {
+		struct rzn1_miic_port *port;
+		struct device_node *phy_node;
+		struct phy_device *phy_dev;
+		int mode;
+
+		phy_nr++;
+
+		/* If there is a phandle for the phy, go look there */
+		phy_node = of_parse_phandle(port_node, "phy-handle", 0);
+		if (!phy_node)
+			phy_node = port_node;
+
+		/* Do not directly assign to something that is of type
+		 * phy_interface_t as that is unsigned
+		 */
+		mode = of_get_phy_mode(phy_node);
+		if (mode < 0) {
+			dev_err(dev, "%s phy-mode is not in your DT\n",
+				phy_node->full_name);
+			continue;
+		}
+
+		phy_dev = of_phy_find_device(phy_node);
+		if (IS_ERR(phy_dev)) {
+			dev_err(dev, "%s is not a phy device\n",
+				phy_node->full_name);
+			continue;
+		}
+		if (!phy_dev) {
+			dev_info(dev, "%s phy is not physically present\n",
+				 phy_node->full_name);
+			continue;
+		}
+
+		port = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);
+		if (!port)
+			return -ENOMEM;
+
+		port->miic = miic;
+		port->phy_nr = phy_nr - 1;
+		port->phy_if = mode;
+		port->phy_dev = phy_dev;
+		miic->ports[port->phy_nr] = port;
+
+		dev_info(dev, "%s %s\n", port_node->full_name, phy_modes(mode));
+
+		/* Initialise the MIIC, the speed & duplex doesn't really
+		 * matter initially as we'll get a callback when the link is up,
+		 * but setting up the interface type needs to be done now
+		 */
+		if (of_property_read_bool(port_node, "ref-clk-out"))
+			rzn1_miic_setup(port, DUPLEX_FULL, SPEED_1000, 1);
+		else
+			rzn1_miic_setup(port, DUPLEX_FULL, SPEED_1000, 0);
+
+		/* hook into the phy */
+		phy_pre_prepare_link(port->phy_dev, port,
+				     &rzn1_miic_link_adjust);
+	}
+
+	return 0;
+}
+
+static int rzn1_miic_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rzn1_miic *miic;
+	struct resource *res;
+
+	miic = devm_kzalloc(dev, sizeof(struct rzn1_miic), GFP_KERNEL);
+	miic->dev = dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	miic->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(miic->regs))
+		return PTR_ERR(miic->regs);
+
+	miic->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(miic->clk)) {
+		dev_err(dev, "failed to get device clock\n");
+		return PTR_ERR(miic->clk);
+	}
+	clk_prepare_enable(miic->clk);
+
+	return rzn1_miic_setup_ports(miic, dev);
+}
+
+static const struct of_device_id rzn1_miic_match[] = {
+	{ .compatible = "renesas,rzn1-miic" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, rzn1_miic_match);
+
+static struct platform_driver rzn1_miic_driver = {
+	.probe  = rzn1_miic_probe,
+	.driver = {
+		.name           = "rzn1-miic",
+		.of_match_table = rzn1_miic_match,
+	},
+};
+module_platform_driver(rzn1_miic_driver);
+
+MODULE_AUTHOR("Phil Edworthy <phil.edworthy@renesas.com>");
+MODULE_DESCRIPTION("Renesas RZ/N1 RGMII/GMII Converter");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index caf069a..1a15c60 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -838,8 +838,8 @@ static int stmmac_init_phy(struct net_device *dev)
 		phydev = of_phy_connect(dev, priv->plat->phy_node,
 					&stmmac_adjust_link, 0, interface);
 	} else {
-		snprintf(bus_id, MII_BUS_ID_SIZE, "stmmac-%x",
-			 priv->plat->bus_id);
+		snprintf(bus_id, MII_BUS_ID_SIZE, "stmmac-%s-%x",
+			 dev->name, priv->plat->bus_id);
 
 		snprintf(phy_id_fmt, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,
 			 priv->plat->phy_addr);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
index ec29585..c5e6455 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
@@ -314,8 +314,8 @@ int stmmac_mdio_register(struct net_device *ndev)
 	}
 
 	new_bus->reset = &stmmac_mdio_reset;
-	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%s-%x",
-		 new_bus->name, priv->plat->bus_id);
+	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%s-%s-%x",
+		 new_bus->name, ndev->name, priv->plat->bus_id);
 	new_bus->priv = ndev;
 	new_bus->phy_mask = mdio_bus_data->phy_mask;
 	new_bus->parent = priv->device;
diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index c2dcf02..ef392a7 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -617,6 +617,17 @@ static int marvell_config_init(struct phy_device *phydev)
 	return marvell_of_reg_init(phydev);
 }
 
+static int m88e1512_config_aneg(struct phy_device *phydev)
+{
+	int err;
+
+	err = genphy_config_aneg(phydev);
+	if (err < 0)
+		return err;
+
+	return marvell_of_reg_init(phydev);
+}
+
 static int m88e1116r_config_init(struct phy_device *phydev)
 {
 	int temp;
@@ -850,6 +861,55 @@ static int m88e1510_config_init(struct phy_device *phydev)
 	return m88e1121_config_init(phydev);
 }
 
+static int m88e1512_config_init(struct phy_device *phydev)
+{
+	int err;
+	int temp;
+
+	/* EEE initialization */
+	phy_write(phydev, 22, 0x00ff);
+	phy_write(phydev, 17, 0x214B);
+	phy_write(phydev, 16, 0x2144);
+	phy_write(phydev, 17, 0x0C28);
+	phy_write(phydev, 16, 0x2146);
+	phy_write(phydev, 17, 0xB233);
+	phy_write(phydev, 16, 0x214D);
+	phy_write(phydev, 17, 0xCC0C);
+	phy_write(phydev, 16, 0x2159);
+	phy_write(phydev, 22, 0x0000);
+
+	/* RGMII-to-Copper mode initialization */
+	if (phy_interface_is_rgmii(phydev)) {
+		/* Select page 18 */
+		err = phy_write(phydev, MII_MARVELL_PHY_PAGE, 18);
+		if (err < 0)
+			return err;
+
+		/* In reg 20, write MODE[2:0] = 0x0 (RGMII to Copper) */
+		temp = phy_read(phydev, 20);
+		temp &= ~0x7;
+		temp |= 0;
+		err = phy_write(phydev, 20, temp);
+		if (err < 0)
+			return err;
+
+		/* PHY reset is necessary after changing MODE[2:0] */
+		temp |= 0x8000;
+		err = phy_write(phydev, 20, temp);
+		if (err < 0)
+			return err;
+
+		/* Reset page selection */
+		err = phy_write(phydev, MII_MARVELL_PHY_PAGE, 0);
+		if (err < 0)
+			return err;
+
+		udelay(100);
+	}
+
+	return m88e1111_config_init(phydev);
+}
+
 static int m88e1118_config_aneg(struct phy_device *phydev)
 {
 	int err;
@@ -1296,7 +1356,12 @@ static int marvell_resume(struct phy_device *phydev)
 static int marvell_aneg_done(struct phy_device *phydev)
 {
 	int retval = phy_read(phydev, MII_M1011_PHY_STATUS);
-	return (retval < 0) ? retval : (retval & MII_M1011_PHY_STATUS_RESOLVED);
+
+	if (retval < 0)
+		return retval;
+
+	return ((retval & MII_M1011_PHY_STATUS_LINK) &&
+		(retval & MII_M1011_PHY_STATUS_RESOLVED));
 }
 
 static int m88e1121_did_interrupt(struct phy_device *phydev)
@@ -1669,7 +1734,7 @@ static int marvell_probe(struct phy_device *phydev)
 	},
 	{
 		.phy_id = MARVELL_PHY_ID_88E1510,
-		.phy_id_mask = MARVELL_PHY_ID_MASK,
+		.phy_id_mask = 0xffffffff,
 		.name = "Marvell 88E1510",
 		.features = PHY_GBIT_FEATURES | SUPPORTED_FIBRE,
 		.flags = PHY_HAS_INTERRUPT,
@@ -1687,6 +1752,24 @@ static int marvell_probe(struct phy_device *phydev)
 		.get_stats = marvell_get_stats,
 	},
 	{
+		.phy_id = MARVELL_PHY_ID_88E1512,
+		.phy_id_mask = 0xffffffff,
+		.name = "Marvell 88E1512",
+		.features = PHY_GBIT_FEATURES,
+		.flags = PHY_HAS_INTERRUPT,
+		.config_init = &m88e1512_config_init,
+		.config_aneg = &m88e1512_config_aneg,
+		.read_status = &marvell_read_status,
+		.ack_interrupt = &marvell_ack_interrupt,
+		.config_intr = &marvell_config_intr,
+		.did_interrupt = &m88e1121_did_interrupt,
+		.resume = &genphy_resume,
+		.suspend = &genphy_suspend,
+		.get_sset_count = marvell_get_sset_count,
+		.get_strings = marvell_get_strings,
+		.get_stats = marvell_get_stats,
+	},
+	{
 		.phy_id = MARVELL_PHY_ID_88E1540,
 		.phy_id_mask = MARVELL_PHY_ID_MASK,
 		.name = "Marvell 88E1540",
@@ -1740,7 +1823,8 @@ static int marvell_probe(struct phy_device *phydev)
 	{ MARVELL_PHY_ID_88E1240, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E1318S, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E1116R, MARVELL_PHY_ID_MASK },
-	{ MARVELL_PHY_ID_88E1510, MARVELL_PHY_ID_MASK },
+	{ MARVELL_PHY_ID_88E1510, 0xffffffff },
+	{ MARVELL_PHY_ID_88E1512, 0xffffffff },
 	{ MARVELL_PHY_ID_88E1540, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E3016, MARVELL_PHY_ID_MASK },
 	{ }
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index f424b86..e5909a2 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -911,6 +911,14 @@ void phy_start(struct phy_device *phydev)
 }
 EXPORT_SYMBOL(phy_start);
 
+static void phydev_adjust_link(struct phy_device *phydev)
+{
+	if (phydev->pre_adjust_link)
+		phydev->pre_adjust_link(phydev->pre_adjust_link_priv);
+
+	phydev->adjust_link(phydev->attached_dev);
+}
+
 /**
  * phy_state_machine - Handle the state machine
  * @work: work_struct that describes the work to be done
@@ -953,7 +961,7 @@ void phy_state_machine(struct work_struct *work)
 		if (!phydev->link) {
 			phydev->state = PHY_NOLINK;
 			netif_carrier_off(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 			break;
 		}
 
@@ -966,7 +974,7 @@ void phy_state_machine(struct work_struct *work)
 		if (err > 0) {
 			phydev->state = PHY_RUNNING;
 			netif_carrier_on(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 
 		} else if (0 == phydev->link_timeout--)
 			needs_aneg = true;
@@ -993,7 +1001,7 @@ void phy_state_machine(struct work_struct *work)
 			}
 			phydev->state = PHY_RUNNING;
 			netif_carrier_on(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 		}
 		break;
 	case PHY_FORCING:
@@ -1009,7 +1017,7 @@ void phy_state_machine(struct work_struct *work)
 				needs_aneg = true;
 		}
 
-		phydev->adjust_link(phydev->attached_dev);
+		phydev_adjust_link(phydev);
 		break;
 	case PHY_RUNNING:
 		/* Only register a CHANGE if we are polling and link changed
@@ -1038,7 +1046,7 @@ void phy_state_machine(struct work_struct *work)
 			netif_carrier_off(phydev->attached_dev);
 		}
 
-		phydev->adjust_link(phydev->attached_dev);
+		phydev_adjust_link(phydev);
 
 		if (phy_interrupt_is_valid(phydev))
 			err = phy_config_interrupt(phydev,
@@ -1048,7 +1056,7 @@ void phy_state_machine(struct work_struct *work)
 		if (phydev->link) {
 			phydev->link = 0;
 			netif_carrier_off(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 			do_suspend = true;
 		}
 		break;
@@ -1072,7 +1080,7 @@ void phy_state_machine(struct work_struct *work)
 				} else	{
 					phydev->state = PHY_NOLINK;
 				}
-				phydev->adjust_link(phydev->attached_dev);
+				phydev_adjust_link(phydev);
 			} else {
 				phydev->state = PHY_AN;
 				phydev->link_timeout = PHY_AN_TIMEOUT;
@@ -1088,7 +1096,7 @@ void phy_state_machine(struct work_struct *work)
 			} else	{
 				phydev->state = PHY_NOLINK;
 			}
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 		}
 		break;
 	}
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index c4ceb08..f8b6efd 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -663,6 +663,14 @@ static void phy_prepare_link(struct phy_device *phydev,
 	phydev->adjust_link = handler;
 }
 
+void phy_pre_prepare_link(struct phy_device *phydev, void *priv,
+			  void (*handler)(void *))
+{
+	phydev->pre_adjust_link = handler;
+	phydev->pre_adjust_link_priv = priv;
+}
+EXPORT_SYMBOL(phy_pre_prepare_link);
+
 /**
  * phy_connect_direct - connect an ethernet device to a specific phy_device
  * @dev: the network device to connect
diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 262281b..2ec6202 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -227,7 +227,13 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 	/* Loop over the child nodes and register a phy_device for each phy */
 	for_each_available_child_of_node(np, child) {
-		addr = of_mdio_parse_addr(&mdio->dev, child);
+		struct device_node *phy_node;
+
+		phy_node = of_parse_phandle(child, "phy-handle", 0);
+		if (!phy_node)
+			phy_node = child;
+
+		addr = of_mdio_parse_addr(&mdio->dev, phy_node);
 		if (addr < 0) {
 			scanphys = true;
 			continue;
@@ -244,6 +250,12 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 	/* auto scan for PHYs with empty reg property */
 	for_each_available_child_of_node(np, child) {
+		struct device_node *phy_node;
+
+		phy_node = of_parse_phandle(child, "phy-handle", 0);
+		if (!phy_node)
+			phy_node = child;
+
 		/* Skip PHYs with reg property set */
 		if (of_find_property(child, "reg", NULL))
 			continue;
@@ -255,7 +267,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 			/* be noisy to encourage people to set reg property */
 			dev_info(&mdio->dev, "scan phy %s at address %i\n",
-				 child->name, addr);
+				 phy_node->name, addr);
 
 			if (of_mdiobus_child_is_phy(child))
 				of_mdiobus_register_phy(mdio, child, addr);
diff --git a/drivers/pci/host/Kconfig b/drivers/pci/host/Kconfig
index d7e7c0a..051855d 100644
--- a/drivers/pci/host/Kconfig
+++ b/drivers/pci/host/Kconfig
@@ -77,7 +77,7 @@ config PCI_TEGRA
 config PCI_RCAR_GEN2
 	bool "Renesas R-Car Gen2 Internal PCI controller"
 	depends on ARM
-	depends on ARCH_RENESAS || COMPILE_TEST
+	depends on ARCH_RENESAS || ARCH_RZN1  || COMPILE_TEST
 	help
 	  Say Y here if you want internal PCI support on R-Car Gen2 SoC.
 	  There are 3 internal PCI controllers available with a single
diff --git a/drivers/pci/host/pci-rcar-gen2.c b/drivers/pci/host/pci-rcar-gen2.c
index 1eeefa4..8c7805f 100644
--- a/drivers/pci/host/pci-rcar-gen2.c
+++ b/drivers/pci/host/pci-rcar-gen2.c
@@ -11,6 +11,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
@@ -360,6 +361,7 @@ static int rcar_pci_probe(struct platform_device *pdev)
 	void __iomem *reg;
 	struct hw_pci hw;
 	void *hw_private[1];
+	struct clk *clk;
 
 	cfg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	reg = devm_ioremap_resource(dev, cfg_res);
@@ -389,6 +391,10 @@ static int rcar_pci_probe(struct platform_device *pdev)
 		return priv->irq;
 	}
 
+	clk = devm_clk_get(&pdev->dev, "axi");
+	if (IS_ERR(clk) || clk_prepare_enable(clk))
+		dev_info(&pdev->dev, "no clock source\n");
+
 	/* default window addr and size if not specified in DT */
 	priv->window_addr = 0x40000000;
 	priv->window_pci = 0x40000000;
@@ -434,6 +440,7 @@ static int rcar_pci_probe(struct platform_device *pdev)
 	{ .compatible = "renesas,pci-r8a7790", },
 	{ .compatible = "renesas,pci-r8a7791", },
 	{ .compatible = "renesas,pci-r8a7794", },
+	{ .compatible = "renesas,pci-rzn1", },
 	{ },
 };
 
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 0e75d94..a8dea9f 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -147,6 +147,12 @@ config PINCTRL_ROCKCHIP
 	select GENERIC_IRQ_CHIP
 	select MFD_SYSCON
 
+config PINCTRL_RZN1
+	bool "Renesas RZN1 pinctrl driver"
+	depends on ARCH_RZN1
+	select PINMUX
+	select PINCONF
+
 config PINCTRL_SINGLE
 	tristate "One-register-per-pin type device tree based pinctrl driver"
 	depends on OF
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index 11bad37..8dadafa 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_PINCTRL_XWAY)	+= pinctrl-xway.o
 obj-$(CONFIG_PINCTRL_LANTIQ)	+= pinctrl-lantiq.o
 obj-$(CONFIG_PINCTRL_LPC18XX)	+= pinctrl-lpc18xx.o
 obj-$(CONFIG_PINCTRL_TB10X)	+= pinctrl-tb10x.o
+obj-$(CONFIG_PINCTRL_RZN1)	+= pinctrl-rzn1.o
 obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
 obj-$(CONFIG_PINCTRL_ZYNQ)	+= pinctrl-zynq.o
 
diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
index fb38e20..04983e7 100644
--- a/drivers/pinctrl/core.c
+++ b/drivers/pinctrl/core.c
@@ -1021,6 +1021,12 @@ int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)
 
 	p->state = NULL;
 
+	/* It is OK to pass NULL as parameter, if the peripheral just want to
+	 * release the pins, instead of setting another 'state' for them and
+	 * having to hoard others. */
+	if (!state)
+		return 0;
+
 	/* Apply all the settings for the new state */
 	list_for_each_entry(setting, &state->settings, node) {
 		switch (setting->type) {
diff --git a/drivers/pinctrl/pinctrl-rzn1.c b/drivers/pinctrl/pinctrl-rzn1.c
new file mode 100644
index 0000000..f6da464
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-rzn1.c
@@ -0,0 +1,986 @@
+/*
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <dt-bindings/interrupt-controller/rzn1-irq.h>
+#include <linux/pinctrl-rzn1.h>
+#include "core.h"
+
+/*
+ * The pinmux has two levels. The first level functions goes from 0 to 9,
+ * and the level 1 mode '15' (0xf) specifies that the second level of pinmux
+ * should be used instead, that level has a lot more options, and goes from
+ * 0 to ~60.
+ *
+ * For linux, we've compounded both numbers together, so 0 to 9 is level 1,
+ * and anything higher is in fact 10 + level 2 number, so we end up with one
+ * value from 0 to 70 or so.
+ *
+ * since there are 169 configurable pins (called PL_GPIO in the datasheet)
+ * that gives something scary like 169*70 possible mux values.
+ */
+
+struct rzn1_pinctrl_regs {
+	union {
+		u32	conf[170];
+		u8	pad0[0x400];
+	};
+	union {
+		struct {
+			u32	status_protect;	/* 0x400 */
+			/* MDIO mux registers, l2 only */
+			u32	l2_mdio[2];
+		};
+		u8	pad1[0x80];
+	};
+	u32	l2_gpio_int_mux[8];	/* 0x480 + (k*4) */
+};
+
+
+/**
+ * struct rzn1_pmx_func - describes rzn1 pinmux functions
+ * @name: the name of this specific function
+ * @groups: corresponding pin groups
+ * @num_groups: the number of groups
+ */
+struct rzn1_pmx_func {
+	const char *name;
+	const char **groups;
+	unsigned num_groups;
+};
+
+/**
+ * struct rzn1_pin_group - describes an rzn1 pin group
+ * @name: the name of this specific pin group
+ * @npins: the number of pins in this group array, i.e. the number of
+ *	elements in .pins so we can iterate over that array
+ * @pin_ids: array of pin_ids. pinctrl forces us to maintain such an array
+ * @pins: array of pins
+ */
+struct rzn1_pin_group {
+	const char *name;
+	const char *func;
+	unsigned npins;
+	u32 *pin_ids;
+	u32 *pins;
+};
+
+/**
+ * @dev: a pointer back to containing device
+ * @base: the offset to the controller in virtual memory
+ */
+struct rzn1_pinctrl {
+	struct device *dev;
+	struct pinctrl_dev *pctl;
+	struct rzn1_pinctrl_regs __iomem *lev1;
+	struct rzn1_pinctrl_regs __iomem *lev2;
+	u32 lev1_phys;
+	u32 lev2_phys;
+
+	struct rzn1_pin_group *groups;
+	unsigned int ngroups, maxgroups;
+
+	struct rzn1_pmx_func *functions;
+	unsigned int nfunctions;
+};
+
+#define RZN1_PINS_PROP "renesas,rzn1-pinmux-ids"
+
+/*
+ * This table was autogenerated
+ */
+#define RZN1_PIN(pin) PINCTRL_PIN(pin, "pin"#pin)
+
+static const struct pinctrl_pin_desc rzn1_pins[] = {
+	RZN1_PIN(0), RZN1_PIN(1), RZN1_PIN(2), RZN1_PIN(3), RZN1_PIN(4),
+	RZN1_PIN(5), RZN1_PIN(6), RZN1_PIN(7), RZN1_PIN(8), RZN1_PIN(9),
+	RZN1_PIN(10), RZN1_PIN(11), RZN1_PIN(12), RZN1_PIN(13), RZN1_PIN(14),
+	RZN1_PIN(15), RZN1_PIN(16), RZN1_PIN(17), RZN1_PIN(18), RZN1_PIN(19),
+	RZN1_PIN(20), RZN1_PIN(21), RZN1_PIN(22), RZN1_PIN(23), RZN1_PIN(24),
+	RZN1_PIN(25), RZN1_PIN(26), RZN1_PIN(27), RZN1_PIN(28), RZN1_PIN(29),
+	RZN1_PIN(30), RZN1_PIN(31), RZN1_PIN(32), RZN1_PIN(33), RZN1_PIN(34),
+	RZN1_PIN(35), RZN1_PIN(36), RZN1_PIN(37), RZN1_PIN(38), RZN1_PIN(39),
+	RZN1_PIN(40), RZN1_PIN(41), RZN1_PIN(42), RZN1_PIN(43), RZN1_PIN(44),
+	RZN1_PIN(45), RZN1_PIN(46), RZN1_PIN(47), RZN1_PIN(48), RZN1_PIN(49),
+	RZN1_PIN(50), RZN1_PIN(51), RZN1_PIN(52), RZN1_PIN(53), RZN1_PIN(54),
+	RZN1_PIN(55), RZN1_PIN(56), RZN1_PIN(57), RZN1_PIN(58), RZN1_PIN(59),
+	RZN1_PIN(60), RZN1_PIN(61), RZN1_PIN(62), RZN1_PIN(63), RZN1_PIN(64),
+	RZN1_PIN(65), RZN1_PIN(66), RZN1_PIN(67), RZN1_PIN(68), RZN1_PIN(69),
+	RZN1_PIN(70), RZN1_PIN(71), RZN1_PIN(72), RZN1_PIN(73), RZN1_PIN(74),
+	RZN1_PIN(75), RZN1_PIN(76), RZN1_PIN(77), RZN1_PIN(78), RZN1_PIN(79),
+	RZN1_PIN(80), RZN1_PIN(81), RZN1_PIN(82), RZN1_PIN(83), RZN1_PIN(84),
+	RZN1_PIN(85), RZN1_PIN(86), RZN1_PIN(87), RZN1_PIN(88), RZN1_PIN(89),
+	RZN1_PIN(90), RZN1_PIN(91), RZN1_PIN(92), RZN1_PIN(93), RZN1_PIN(94),
+	RZN1_PIN(95), RZN1_PIN(96), RZN1_PIN(97), RZN1_PIN(98), RZN1_PIN(99),
+	RZN1_PIN(100), RZN1_PIN(101), RZN1_PIN(102), RZN1_PIN(103),
+	RZN1_PIN(104), RZN1_PIN(105), RZN1_PIN(106), RZN1_PIN(107),
+	RZN1_PIN(108), RZN1_PIN(109), RZN1_PIN(110), RZN1_PIN(111),
+	RZN1_PIN(112), RZN1_PIN(113), RZN1_PIN(114), RZN1_PIN(115),
+	RZN1_PIN(116), RZN1_PIN(117), RZN1_PIN(118), RZN1_PIN(119),
+	RZN1_PIN(120), RZN1_PIN(121), RZN1_PIN(122), RZN1_PIN(123),
+	RZN1_PIN(124), RZN1_PIN(125), RZN1_PIN(126), RZN1_PIN(127),
+	RZN1_PIN(128), RZN1_PIN(129), RZN1_PIN(130), RZN1_PIN(131),
+	RZN1_PIN(132), RZN1_PIN(133), RZN1_PIN(134), RZN1_PIN(135),
+	RZN1_PIN(136), RZN1_PIN(137), RZN1_PIN(138), RZN1_PIN(139),
+	RZN1_PIN(140), RZN1_PIN(141), RZN1_PIN(142), RZN1_PIN(143),
+	RZN1_PIN(144), RZN1_PIN(145), RZN1_PIN(146), RZN1_PIN(147),
+	RZN1_PIN(148), RZN1_PIN(149), RZN1_PIN(150), RZN1_PIN(151),
+	RZN1_PIN(152), RZN1_PIN(153), RZN1_PIN(154), RZN1_PIN(155),
+	RZN1_PIN(156), RZN1_PIN(157), RZN1_PIN(158), RZN1_PIN(159),
+	RZN1_PIN(160), RZN1_PIN(161), RZN1_PIN(162), RZN1_PIN(163),
+	RZN1_PIN(164), RZN1_PIN(165), RZN1_PIN(166), RZN1_PIN(167),
+	RZN1_PIN(168), RZN1_PIN(169), RZN1_PIN(170), RZN1_PIN(171),
+};
+
+/*
+ * This table was autogenerated
+ */
+
+static const char * const rzn1_func_names[RZN1_FUNC_MAX] = {
+	[RZN1_FUNC_HIGHZ] =			"highz",
+	[RZN1_FUNC_0L] =			"0l",
+	[RZN1_FUNC_CLK_ETH_MII_RGMII_RMII] =	"clk_eth_mii_rgmii_rmii",
+	[RZN1_FUNC_CLK_ETH_NAND] =		"clk_eth_nand",
+	[RZN1_FUNC_QSPI] =			"qspi",
+	[RZN1_FUNC_SDIO] =			"sdio",
+	[RZN1_FUNC_LCD] =			"lcd",
+	[RZN1_FUNC_LCD_E] =			"lcd_e",
+	[RZN1_FUNC_MSEBIM] =			"msebim",
+	[RZN1_FUNC_MSEBIS] =			"msebis",
+	[RZN1_FUNC_HIGHZ1] =			"highz1",
+	[RZN1_FUNC_ETHERCAT] =			"ethercat",
+	[RZN1_FUNC_SERCOS3] =			"sercos3",
+	[RZN1_FUNC_SDIO_E] =			"sdio_e",
+	[RZN1_FUNC_ETH_MDIO] =			"eth_mdio",
+	[RZN1_FUNC_ETH_MDIO_E1] =		"eth_mdio_e1",
+	[RZN1_FUNC_USB] =			"usb",
+	[RZN1_FUNC_MSEBIM_E] =			"msebim_e",
+	[RZN1_FUNC_MSEBIS_E] =			"msebis_e",
+	[RZN1_FUNC_RSV] =			"rsv",
+	[RZN1_FUNC_RSV_E] =			"rsv_e",
+	[RZN1_FUNC_RSV_E1] =			"rsv_e1",
+	[RZN1_FUNC_UART0_I] =			"uart0_i",
+	[RZN1_FUNC_UART0_I_E] =			"uart0_i_e",
+	[RZN1_FUNC_UART1_I] =			"uart1_i",
+	[RZN1_FUNC_UART1_I_E] =			"uart1_i_e",
+	[RZN1_FUNC_UART2_I] =			"uart2_i",
+	[RZN1_FUNC_UART2_I_E] =			"uart2_i_e",
+	[RZN1_FUNC_UART0] =			"uart0",
+	[RZN1_FUNC_UART0_E] =			"uart0_e",
+	[RZN1_FUNC_UART1] =			"uart1",
+	[RZN1_FUNC_UART1_E] =			"uart1_e",
+	[RZN1_FUNC_UART2] =			"uart2",
+	[RZN1_FUNC_UART2_E] =			"uart2_e",
+	[RZN1_FUNC_UART3] =			"uart3",
+	[RZN1_FUNC_UART3_E] =			"uart3_e",
+	[RZN1_FUNC_UART4] =			"uart4",
+	[RZN1_FUNC_UART4_E] =			"uart4_e",
+	[RZN1_FUNC_UART5] =			"uart5",
+	[RZN1_FUNC_UART5_E] =			"uart5_e",
+	[RZN1_FUNC_UART6] =			"uart6",
+	[RZN1_FUNC_UART6_E] =			"uart6_e",
+	[RZN1_FUNC_UART7] =			"uart7",
+	[RZN1_FUNC_UART7_E] =			"uart7_e",
+	[RZN1_FUNC_SPI0_M] =			"spi0_m",
+	[RZN1_FUNC_SPI0_M_E] =			"spi0_m_e",
+	[RZN1_FUNC_SPI1_M] =			"spi1_m",
+	[RZN1_FUNC_SPI1_M_E] =			"spi1_m_e",
+	[RZN1_FUNC_SPI2_M] =			"spi2_m",
+	[RZN1_FUNC_SPI2_M_E] =			"spi2_m_e",
+	[RZN1_FUNC_SPI3_M] =			"spi3_m",
+	[RZN1_FUNC_SPI3_M_E] =			"spi3_m_e",
+	[RZN1_FUNC_SPI4_S] =			"spi4_s",
+	[RZN1_FUNC_SPI4_S_E] =			"spi4_s_e",
+	[RZN1_FUNC_SPI5_S] =			"spi5_s",
+	[RZN1_FUNC_SPI5_S_E] =			"spi5_s_e",
+	[RZN1_FUNC_SGPIO0_M] =			"sgpio0_m",
+	[RZN1_FUNC_SGPIO1_M] =			"sgpio1_m",
+	[RZN1_FUNC_GPIO] =			"gpio",
+	[RZN1_FUNC_CAN] =			"can",
+	[RZN1_FUNC_I2C] =			"i2c",
+	[RZN1_FUNC_SAFE] =			"safe",
+	[RZN1_FUNC_PTO_PWM] =			"pto_pwm",
+	[RZN1_FUNC_PTO_PWM1] =			"pto_pwm1",
+	[RZN1_FUNC_PTO_PWM2] =			"pto_pwm2",
+	[RZN1_FUNC_PTO_PWM3] =			"pto_pwm3",
+	[RZN1_FUNC_PTO_PWM4] =			"pto_pwm4",
+	[RZN1_FUNC_DELTA_SIGMA] =		"delta_sigma",
+	[RZN1_FUNC_SGPIO2_M] =			"sgpio2_m",
+	[RZN1_FUNC_SGPIO3_M] =			"sgpio3_m",
+	[RZN1_FUNC_SGPIO4_S] =			"sgpio4_s",
+	[RZN1_FUNC_MAC_MTIP_SWITCH] =		"mac_mtip_switch",
+	[RZN1_FUNC_MDIO_MUX_HIGHZ] =		"mdio_mux_highz",
+	[RZN1_FUNC_MDIO_MUX_MAC0] =		"mdio_mux_mac0",
+	[RZN1_FUNC_MDIO_MUX_MAC1] =		"mdio_mux_mac1",
+	[RZN1_FUNC_MDIO_MUX_ECAT] =		"mdio_mux_ecat",
+	[RZN1_FUNC_MDIO_MUX_S3_MDIO0] =		"mdio_mux_s3_mdio0",
+	[RZN1_FUNC_MDIO_MUX_S3_MDIO1] =		"mdio_mux_s3_mdio1",
+	[RZN1_FUNC_MDIO_MUX_HWRTOS] =		"mdio_mux_hwrtos",
+	[RZN1_FUNC_MDIO_MUX_SWITCH] =		"mdio_mux_switch",
+};
+
+/* Bit number and bit values in the pinmux registers */
+enum {
+	RZN1_LEV_DRIVE_STRENGTH		= 10,
+		RZN1_LEV_DRIVE_4MA		= 0,
+		RZN1_LEV_DRIVE_6MA		= 1,
+		RZN1_LEV_DRIVE_8MA		= 2,
+		RZN1_LEV_DRIVE_12MA		= 3,
+	RZN1_LEV_DRIVE_PULL		= 8,
+		RZN1_LEV_DRIVE_PULL_NONE	= 0,
+		RZN1_LEV_DRIVE_PULL_UP		= 1,
+		RZN1_LEV_DRIVE_PULL_NONE2	= 2,
+		RZN1_LEV_DRIVE_PULL_DOWN	= 3,
+	RZN1_FUNCTION			= 0,
+		RZN1_LEV_FUNCTION_MASK		= 0xf,
+		RZN1_LEV_FUNCTION_LEV2		= 0xf,
+		RZN1_LEV2_FUNCTION_MASK		= 0x3f,
+	RZN1_WP_STATE			= 0,
+};
+
+/*
+ * These relate to converting our 'composite' pinctrl value into separate
+ * components.
+ * The 32 bits value contains what is needed to set the 2 levels of
+ * hardware mux level
+ */
+
+#define RZN1_MUX_FUNC_BIT	8
+#define RZN1_MUX_HAS_FUNC_BIT	15
+#define RZN1_MUX_HAS_DRIVE_BIT	16
+#define RZN1_MUX_DRIVE_BIT	17
+#define RZN1_MUX_HAS_PULL_BIT	19
+#define RZN1_MUX_PULL_BIT	20
+
+struct rzn1_pin_desc {
+	u32	pin: 8,
+		func: 7,
+		has_func : 1,
+		has_drive: 1,
+		drive : 2,
+		has_pull : 1,
+		pull : 2;
+};
+
+static struct rzn1_pinctrl *pinctrl;
+
+/*
+ * Breaks down the configuration word (as present in the DT) into
+ * a manageable structural description
+ */
+static void rzn1_get_pin_desc_from_config(
+	struct rzn1_pinctrl *ipctl,
+	u32 pin_config,
+	struct rzn1_pin_desc *o)
+{
+	struct rzn1_pin_desc p = {
+		.pin = pin_config,
+		.func = pin_config >> RZN1_MUX_FUNC_BIT,
+		.has_func = pin_config >> RZN1_MUX_HAS_FUNC_BIT,
+		.has_drive = pin_config >> RZN1_MUX_HAS_DRIVE_BIT,
+		.drive = pin_config >> RZN1_MUX_DRIVE_BIT,
+		.has_pull = pin_config >> RZN1_MUX_HAS_PULL_BIT,
+		.pull = pin_config >> RZN1_MUX_PULL_BIT,
+	};
+
+	if (o)
+		*o = p;
+}
+
+enum {
+	LOCK_LEVEL1 = 0x1,
+	LOCK_LEVEL2 = 0x2,
+	LOCK_ALL = LOCK_LEVEL1 | LOCK_LEVEL2,
+};
+
+static void rzn1_hw_set_lock(
+	struct rzn1_pinctrl *ipctl,
+	u8 lock,
+	u8 value)
+{
+	if (lock & LOCK_LEVEL1) {
+		u32 val = (ipctl->lev1_phys + 0x400) | !(value & LOCK_LEVEL1);
+		writel(val, &ipctl->lev1->status_protect);
+	}
+	if (lock & LOCK_LEVEL2) {
+		u32 val = (ipctl->lev2_phys + 0x400) | !(value & LOCK_LEVEL2);
+		writel(val, &ipctl->lev2->status_protect);
+	}
+}
+
+/*
+ * Using a composite pin description, set the hardware pinmux registers
+ * with the corresponding values.
+ * Make sure to unlock write protection and reset it afterward.
+ *
+ * NOTE: There is no protection for potential concurrency, it is assumed these
+ * calls are serialized already.
+ */
+static int rzn1_set_hw_pin_parameters(
+	struct rzn1_pinctrl *ipctl,
+	u32 pin_config,
+	u8 use_locks)
+{
+	struct rzn1_pin_desc p;
+	u32 l1, l2, l1_cache, l2_cache;
+
+	rzn1_get_pin_desc_from_config(ipctl, pin_config, &p);
+#if 0 /* bit noisy, even in debug mode */
+	dev_dbg(ipctl->dev,
+		"SET pin %3d:%08x func:%d/%d(0x%2x) drive:%d/%x pull:%d/%x\n",
+		p.pin, pin_config,
+		p.has_func, p.func, p.func - RZN1_FUNC_LEVEL2_OFFSET,
+		p.has_drive, p.drive,
+		p.has_pull, p.pull);
+#endif
+	if (p.pin >= RZN1_MDIO_BUS0 && p.pin <= RZN1_MDIO_BUS1) {
+		if (p.has_func && p.func >= RZN1_FUNC_MDIO_MUX_HIGHZ &&
+				p.func <= RZN1_FUNC_MDIO_MUX_SWITCH) {
+			p.pin -= RZN1_MDIO_BUS0;
+			p.func -= RZN1_FUNC_MDIO_MUX_HIGHZ;
+			dev_dbg(ipctl->dev, "MDIO MUX[%d] set to %d\n",
+				p.pin, p.func);
+			rzn1_pinctrl_mdio_select(p.pin, p.func);
+		} else {
+			dev_warn(ipctl->dev, "MDIO[%d] Invalid configuration: %d\n",
+				p.pin - RZN1_MDIO_BUS0, p.func);
+			return -EINVAL;
+		}
+		return 0;
+	}
+	/* Note here, we do not allow anything past the MDIO Mux values */
+	if (p.pin >= ARRAY_SIZE(ipctl->lev1->conf) ||
+			p.func >= RZN1_FUNC_MDIO_MUX_HIGHZ)
+		return -EINVAL;
+	l1 = readl(&ipctl->lev1->conf[p.pin]);
+	l1_cache = l1;
+	l2 = readl(&ipctl->lev2->conf[p.pin]);
+	l2_cache = l2;
+
+	if (p.has_drive) {
+		l1 &= ~(0x3 << RZN1_LEV_DRIVE_STRENGTH);
+		l1 |= (p.drive << RZN1_LEV_DRIVE_STRENGTH);
+	}
+	if (p.has_pull) {
+		l1 &= ~(0x3 << RZN1_LEV_DRIVE_PULL);
+		l1 |= (p.pull << RZN1_LEV_DRIVE_PULL);
+	}
+	if (p.has_func) {
+		if (p.func < RZN1_FUNC_LEVEL2_OFFSET) {
+			l1 &= ~(RZN1_LEV_FUNCTION_MASK << RZN1_FUNCTION);
+			l1 |= (p.func << RZN1_FUNCTION);
+		} else {
+			l1 &= ~(RZN1_LEV_FUNCTION_MASK << RZN1_FUNCTION);
+			l1 |= (RZN1_LEV_FUNCTION_LEV2 << RZN1_FUNCTION);
+
+			l2 = p.func - RZN1_FUNC_LEVEL2_OFFSET;
+		}
+	}
+	/* If either of the configuration change, we update both
+	 * anyway.
+	 */
+	if (l1 != l1_cache || l2 != l2_cache) {
+		rzn1_hw_set_lock(ipctl, use_locks, LOCK_ALL);
+		writel(l1, &ipctl->lev1->conf[p.pin]);
+		writel(l2, &ipctl->lev2->conf[p.pin]);
+		rzn1_hw_set_lock(ipctl, use_locks, 0);
+	}
+	return 0;
+}
+
+static const struct rzn1_pin_group *
+rzn1_pinctrl_find_group_by_name(
+	const struct rzn1_pinctrl *ipctl,
+	const char *name)
+{
+	const struct rzn1_pin_group *grp = NULL;
+	int i;
+
+	for (i = 0; i < ipctl->ngroups; i++) {
+		if (!strcmp(ipctl->groups[i].name, name)) {
+			grp = &ipctl->groups[i];
+			break;
+		}
+	}
+
+	return grp;
+}
+
+static int rzn1_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+
+	return ipctl->ngroups;
+}
+
+static const char *rzn1_get_group_name(
+	struct pinctrl_dev *pctldev,
+	unsigned selector)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+
+	return ipctl->groups[selector].name;
+}
+
+static int rzn1_get_group_pins(
+	struct pinctrl_dev *pctldev,
+	unsigned selector,
+	const unsigned **pins,
+	unsigned *npins)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+
+	if (selector >= ipctl->ngroups)
+		return -EINVAL;
+
+	*pins = ipctl->groups[selector].pins;
+	*npins = ipctl->groups[selector].npins;
+
+	return 0;
+}
+
+static void rzn1_pin_dbg_show(
+	struct pinctrl_dev *pctldev,
+	struct seq_file *s,
+	unsigned offset)
+{
+	seq_printf(s, "%s", dev_name(pctldev->dev));
+}
+
+static int rzn1_dt_node_to_map(
+	struct pinctrl_dev *pctldev,
+	struct device_node *np,
+	struct pinctrl_map **map,
+	unsigned *num_maps)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct rzn1_pin_group *grp;
+	struct pinctrl_map *new_map;
+	struct device_node *parent;
+	int map_num = 2;
+
+	/*
+	 * first find the group of this node and check if we need create
+	 * config maps for pins
+	 */
+	grp = rzn1_pinctrl_find_group_by_name(ipctl, np->name);
+	if (!grp) {
+		dev_err(ipctl->dev, "unable to find group for node %s\n",
+			np->name);
+		return -EINVAL;
+	}
+
+	new_map = devm_kmalloc_array(ipctl->dev, map_num,
+			sizeof(struct pinctrl_map), GFP_KERNEL);
+	if (!new_map)
+		return -ENOMEM;
+
+	*map = new_map;
+	*num_maps = map_num;
+
+	/* create mux map */
+	parent = of_get_parent(np);
+	if (!parent)
+		return -EINVAL;
+
+	new_map[0].type = PIN_MAP_TYPE_MUX_GROUP;
+	new_map[0].data.mux.function = grp->func;
+	new_map[0].data.mux.group = grp->name;
+	of_node_put(parent);
+
+	new_map[1].type = PIN_MAP_TYPE_CONFIGS_GROUP;
+	new_map[1].data.configs.group_or_pin = grp->name;
+	new_map[1].data.configs.configs = (unsigned long *)grp->pin_ids;
+	new_map[1].data.configs.num_configs = grp->npins;
+
+	dev_dbg(pctldev->dev, "maps: function %s group %s (%d pins)\n",
+		(*map)->data.mux.function, (*map)->data.mux.group,
+		grp->npins);
+
+	return 0;
+}
+
+static void rzn1_dt_free_map(struct pinctrl_dev *pctldev,
+				struct pinctrl_map *map, unsigned num_maps)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+
+	devm_kfree(ipctl->dev, map);
+}
+
+static const struct pinctrl_ops rzn1_pctrl_ops = {
+	.get_groups_count = rzn1_get_groups_count,
+	.get_group_name = rzn1_get_group_name,
+	.get_group_pins = rzn1_get_group_pins,
+	.pin_dbg_show = rzn1_pin_dbg_show,
+	.dt_node_to_map = rzn1_dt_node_to_map,
+	.dt_free_map = rzn1_dt_free_map,
+};
+
+static int rzn1_pmx_set_mux(
+	struct pinctrl_dev *pctldev,
+	unsigned selector,
+	unsigned group)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	struct rzn1_pin_group *grp;
+
+	/*
+	 * Configure the mux mode for each pin in the group for a specific
+	 * function.
+	 */
+	grp = &ipctl->groups[group];
+
+	dev_dbg(ipctl->dev, "enable function %s(%d) group %s(%d)\n",
+		ipctl->functions[selector].name, selector, grp->name, group);
+	/*
+	 * Well, theres not much to do here anyway, as the individual pin
+	 * callback is going to be called anyway
+	 */
+	return 0;
+}
+
+static int rzn1_pmx_get_funcs_count(struct pinctrl_dev *pctldev)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+
+	return ipctl->nfunctions;
+}
+
+static const char *rzn1_pmx_get_func_name(
+	struct pinctrl_dev *pctldev,
+	unsigned selector)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+
+	return ipctl->functions[selector].name;
+}
+
+static int rzn1_pmx_get_groups(
+	struct pinctrl_dev *pctldev,
+	unsigned selector,
+	const char * const **groups,
+	unsigned * const num_groups)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+
+	*groups = ipctl->functions[selector].groups;
+	*num_groups = ipctl->functions[selector].num_groups;
+
+	return 0;
+}
+
+static const struct pinmux_ops rzn1_pmx_ops = {
+	.get_functions_count = rzn1_pmx_get_funcs_count,
+	.get_function_name = rzn1_pmx_get_func_name,
+	.get_function_groups = rzn1_pmx_get_groups,
+	.set_mux = rzn1_pmx_set_mux,
+};
+
+static int rzn1_pinconf_get(struct pinctrl_dev *pctldev,
+			     unsigned pin_id, unsigned long *config)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+
+	pin_id &= 0xff;
+	if (pin_id >= ARRAY_SIZE(ipctl->lev1->conf))
+		return -EINVAL;
+	*config = readl(&ipctl->lev1->conf[pin_id]) & 0xf;
+	if (*config == 0xf)
+		*config = (readl(&ipctl->lev2->conf[pin_id]) & 0x3f) +
+				RZN1_FUNC_LEVEL2_OFFSET;
+	*config = (*config << RZN1_MUX_FUNC_BIT) | pin_id;
+	return 0;
+}
+
+static int rzn1_pinconf_set(struct pinctrl_dev *pctldev,
+			     unsigned pin_id, unsigned long *configs,
+			     unsigned num_configs)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	int i;
+
+	dev_dbg(ipctl->dev, "pinconf set pin %s (%d configs)\n",
+		rzn1_pins[pin_id].name, num_configs);
+
+	for (i = 0; i < num_configs; i++)
+		rzn1_set_hw_pin_parameters(ipctl, configs[i], LOCK_ALL);
+
+	return 0;
+}
+
+
+static int rzn1_pin_config_group_set(
+	struct pinctrl_dev *pctldev,
+	unsigned selector,
+	unsigned long *configs,
+	unsigned num_configs)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	struct rzn1_pin_group *grp = &ipctl->groups[selector];
+	int i;
+	/*
+	 * Configure the mux mode for each pin in the group for a specific
+	 * function.
+	 */
+	dev_dbg(ipctl->dev, "group set %s selector:%d configs:%p/%d\n",
+		grp->name, selector, configs, num_configs);
+
+	rzn1_hw_set_lock(ipctl, LOCK_ALL, LOCK_ALL);
+	for (i = 0; i < num_configs; i++)
+		rzn1_set_hw_pin_parameters(ipctl, configs[i], 0);
+	rzn1_hw_set_lock(ipctl, LOCK_ALL, 0);
+
+	return 0;
+}
+
+static void rzn1_pinconf_dbg_show(struct pinctrl_dev *pctldev,
+				   struct seq_file *s, unsigned pin_id)
+{
+	unsigned long config = pin_id;
+
+	seq_printf(s, "0x%lx", config);
+}
+
+static void rzn1_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,
+					 struct seq_file *s, unsigned group)
+{
+	struct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	struct rzn1_pin_group *grp;
+	unsigned long config;
+	const char *name;
+	int i, ret;
+
+	if (group > ipctl->ngroups)
+		return;
+
+	seq_puts(s, "\n");
+	grp = &ipctl->groups[group];
+	for (i = 0; i < grp->npins; i++) {
+		name = pin_get_name(pctldev, grp->pin_ids[i] & 0xff);
+		ret = rzn1_pinconf_get(pctldev, grp->pin_ids[i], &config);
+		if (ret)
+			return;
+		seq_printf(s, "%s: 0x%lx", name, config);
+	}
+}
+
+static const struct pinconf_ops rzn1_pinconf_ops = {
+	.pin_config_get = rzn1_pinconf_get,
+	.pin_config_set = rzn1_pinconf_set,
+	.pin_config_group_set = rzn1_pin_config_group_set,
+	.pin_config_dbg_show = rzn1_pinconf_dbg_show,
+	.pin_config_group_dbg_show = rzn1_pinconf_group_dbg_show,
+};
+
+static struct pinctrl_desc rzn1_pinctrl_desc = {
+	.pctlops = &rzn1_pctrl_ops,
+	.pmxops = &rzn1_pmx_ops,
+	.confops = &rzn1_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+
+static int
+rzn1_pinctrl_parse_groups(
+	struct device_node *np,
+	struct rzn1_pin_group *grp,
+	struct rzn1_pinctrl *ipctl)
+{
+	int size;
+	const __be32 *list;
+	int i;
+
+	dev_dbg(ipctl->dev, "%s: %s\n", __func__, np->name);
+
+	/* Initialise group */
+	grp->name = np->name;
+
+	/*
+	 * the binding format is renesas,rzn1-pinmux-ids = <PIN_FUNC_ID CONFIG ...>,
+	 * do sanity check and calculate pins number
+	 */
+	list = of_get_property(np, RZN1_PINS_PROP, &size);
+	if (!list) {
+		dev_err(ipctl->dev,
+			"no " RZN1_PINS_PROP " property in node %s\n",
+			np->full_name);
+		return -EINVAL;
+	}
+
+	/* we do not check return since it's safe node passed down */
+	if (!size) {
+		dev_err(ipctl->dev, "Invalid " RZN1_PINS_PROP " in node %s\n",
+			np->full_name);
+		return -EINVAL;
+	}
+
+	grp->npins = size / sizeof(list[0]);
+	if (!grp->npins)
+		return 0;
+	grp->pin_ids = devm_kmalloc_array(ipctl->dev,
+				grp->npins, sizeof(grp->pin_ids[0]),
+				GFP_KERNEL);
+	grp->pins = devm_kmalloc_array(ipctl->dev,
+				grp->npins, sizeof(grp->pins[0]),
+				GFP_KERNEL);
+	if (!grp->pin_ids || !grp->pins)
+		return -ENOMEM;
+
+	for (i = 0; i < grp->npins; i++) {
+		u32 pin_id = be32_to_cpu(*list++);
+
+		grp->pins[i] = pin_id & 0xff;
+		grp->pin_ids[i] = pin_id;
+	}
+
+	return grp->npins;
+}
+
+
+static int rzn1_pinctrl_count_function_groups(
+	struct device_node *np)
+{
+	struct device_node *child;
+	int count = 0;
+
+	if (of_property_count_u32_elems(np, RZN1_PINS_PROP) > 0)
+		count++;
+	for_each_child_of_node(np, child) {
+		if (of_property_count_u32_elems(child, RZN1_PINS_PROP) > 0)
+			count++;
+	}
+	return count;
+}
+
+static int rzn1_pinctrl_parse_functions(
+	struct device_node *np,
+	struct rzn1_pinctrl *ipctl,
+	u32 index)
+{
+	struct device_node *child;
+	struct rzn1_pmx_func *func;
+	struct rzn1_pin_group *grp;
+	u32 i = 0;
+
+	dev_dbg(ipctl->dev, "parse function(%d): %s\n", index, np->name);
+
+	func = &ipctl->functions[index];
+
+	/* Initialise function */
+	func->name = np->name;
+	func->num_groups = rzn1_pinctrl_count_function_groups(np);
+	dev_dbg(ipctl->dev, "function %s has %d groups\n",
+		np->name, func->num_groups);
+	if (func->num_groups == 0) {
+		dev_err(ipctl->dev, "no groups defined in %s\n", np->full_name);
+		return -EINVAL;
+	}
+	func->groups = devm_kmalloc_array(ipctl->dev,
+			func->num_groups, sizeof(char *), GFP_KERNEL);
+
+	if (of_property_count_u32_elems(np, RZN1_PINS_PROP) > 0) {
+		func->groups[i] = np->name;
+		grp = &ipctl->groups[ipctl->ngroups];
+		grp->func = func->name;
+		if (rzn1_pinctrl_parse_groups(np, grp, ipctl) > 0) {
+			i++;
+			ipctl->ngroups++;
+		}
+	}
+	for_each_child_of_node(np, child) {
+		func->groups[i] = child->name;
+		grp = &ipctl->groups[ipctl->ngroups];
+		grp->func = func->name;
+		if (rzn1_pinctrl_parse_groups(child, grp, ipctl) > 0) {
+			i++;
+			ipctl->ngroups++;
+		}
+	}
+	dev_dbg(ipctl->dev, "function %s parsed %d/%d groups\n",
+		np->name, i, func->num_groups);
+
+	return 0;
+}
+
+static ssize_t _rzn1_pinctrl_sysfs_force_mux(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t len)
+{
+	struct rzn1_pinctrl *ipctl = dev_get_drvdata(dev);
+	long unsigned int val;
+
+	if (kstrtoul(buf, 16, &val)) {
+		printk("Invalid hex value %08x", (u32)val);
+		return len;
+	}
+
+	dev_info(ipctl->dev, "setting pin to %08x\n", (u32)val);
+
+	rzn1_set_hw_pin_parameters(ipctl, val, LOCK_ALL);
+
+	return len;
+}
+
+static DEVICE_ATTR(force_mux, S_IWUSR, NULL, _rzn1_pinctrl_sysfs_force_mux);
+
+static int rzn1_pinctrl_probe_dt(struct platform_device *pdev,
+				struct rzn1_pinctrl *ipctl)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+	u32 nfuncs = 0;
+	u32 i = 0;
+
+	if (!np)
+		return -ENODEV;
+
+	nfuncs = of_get_child_count(np);
+	if (nfuncs <= 0) {
+		dev_err(&pdev->dev, "no functions defined\n");
+		return -EINVAL;
+	}
+
+	ipctl->nfunctions = nfuncs;
+	ipctl->functions = devm_kmalloc_array(
+				&pdev->dev,
+				nfuncs, sizeof(struct rzn1_pmx_func),
+				GFP_KERNEL);
+	if (!ipctl->functions)
+		return -ENOMEM;
+
+	ipctl->ngroups = 0;
+	ipctl->maxgroups = 0;
+	for_each_child_of_node(np, child)
+		ipctl->maxgroups += rzn1_pinctrl_count_function_groups(child);
+	ipctl->groups = devm_kmalloc_array(
+				&pdev->dev,
+				ipctl->maxgroups, sizeof(*ipctl->groups),
+				GFP_KERNEL);
+	if (!ipctl->groups)
+		return -ENOMEM;
+
+	for_each_child_of_node(np, child)
+		rzn1_pinctrl_parse_functions(child, ipctl, i++);
+
+	if (device_create_file(&pdev->dev, &dev_attr_force_mux))
+		dev_warn(&pdev->dev, "cannot create status attribute\n");
+
+	return 0;
+}
+
+static int rzn1_pinctrl_probe(struct platform_device *pdev)
+{
+	struct rzn1_pinctrl *ipctl;
+	struct resource *res;
+	int ret;
+
+	/* Create state holders etc for this driver */
+	ipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);
+	if (!ipctl)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ipctl->lev1_phys = (u32) res->start;
+	ipctl->lev1 = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ipctl->lev1))
+		return PTR_ERR(ipctl->lev1);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	ipctl->lev2_phys = (u32) res->start;
+	ipctl->lev2 = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ipctl->lev2))
+		return PTR_ERR(ipctl->lev2);
+
+	ipctl->dev = &pdev->dev;
+	rzn1_pinctrl_desc.name = dev_name(&pdev->dev);
+	rzn1_pinctrl_desc.pins = rzn1_pins;
+	rzn1_pinctrl_desc.npins = ARRAY_SIZE(rzn1_pins);
+
+	ret = rzn1_pinctrl_probe_dt(pdev, ipctl);
+	if (ret) {
+		dev_err(&pdev->dev, "fail to probe dt properties\n");
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, ipctl);
+	ipctl->pctl = pinctrl_register(&rzn1_pinctrl_desc, &pdev->dev, ipctl);
+	if (!ipctl->pctl) {
+		dev_err(&pdev->dev, "could not register rzn1 pinctrl driver\n");
+		return -EINVAL;
+	}
+	pinctrl = ipctl;
+	dev_info(&pdev->dev, "initialized rzn1 pinctrl driver\n");
+	return 0;
+}
+
+void rzn1_pinctrl_mdio_select(u8 mdio, u32 func)
+{
+	BUG_ON(!pinctrl || mdio > 1 || func > MDIO_MUX_SWITCH);
+	dev_info(pinctrl->dev, "setting mdio %d to 0x%x\n", mdio, func);
+
+	rzn1_hw_set_lock(pinctrl, LOCK_LEVEL2, LOCK_LEVEL2);
+	writel(func, &pinctrl->lev2->l2_mdio[mdio]);
+	rzn1_hw_set_lock(pinctrl, LOCK_LEVEL2, 0);
+}
+EXPORT_SYMBOL_GPL(rzn1_pinctrl_mdio_select);
+
+void rzn1_pinctrl_gpioint_select(u8 gpioint, u8 gpio_source)
+{
+	if (gpioint >= RZN1_IRQ_GPIO_0)
+		gpioint -= RZN1_IRQ_GPIO_0;
+	BUG_ON(!pinctrl);
+	BUG_ON(gpio_source > (3 * 32) || gpioint > 7);
+	dev_info(pinctrl->dev, "setting RZN1_IRQ_GPIO_%d to GPIO%dA[%d]\n",
+		gpioint, gpio_source / 32, gpio_source % 32);
+	writel(gpio_source, &pinctrl->lev2->l2_gpio_int_mux[gpioint]);
+}
+EXPORT_SYMBOL_GPL(rzn1_pinctrl_gpioint_select);
+
+u8 rzn1_pinctrl_gpioint_get(u8 gpioint)
+{
+	if (gpioint >= RZN1_IRQ_GPIO_0)
+		gpioint -= RZN1_IRQ_GPIO_0;
+	BUG_ON(!pinctrl || gpioint > 7);
+	return readl(&pinctrl->lev2->l2_gpio_int_mux[gpioint]);
+}
+EXPORT_SYMBOL_GPL(rzn1_pinctrl_gpioint_get);
+
+static const struct of_device_id rzn1_pinctrl_match[] = {
+	{ .compatible = "renesas,rzn1-pinctrl", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, rzn1_pinctrl_match);
+
+static struct platform_driver rzn1_pinctrl_driver = {
+	.probe	= rzn1_pinctrl_probe,
+	.driver	= {
+		.name		= "rzn1-pinctrl",
+		.owner		= THIS_MODULE,
+		.of_match_table	= rzn1_pinctrl_match,
+	},
+};
+
+static int __init _pinctrl_drv_register(void)
+{
+	return platform_driver_register(&rzn1_pinctrl_driver);
+}
+postcore_initcall(_pinctrl_drv_register);
+
+
+MODULE_AUTHOR("Michel Pollet <Michel.Pollet@bp.renesas.com>");
+MODULE_DESCRIPTION("RZ/N1 pinctrl driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index e859d14..5382541 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1394,6 +1394,12 @@ config RTC_DRV_RS5C313
 	help
 	  If you say yes here you get support for the Ricoh RS5C313 RTC chips.
 
+config RTC_DRV_RZN1
+	tristate "Renesas RZN1"
+	depends on ARCH_RZN1
+	help
+	  If you say yes here you get support for the Renesas RZ/N1 RTC.
+
 config RTC_DRV_GENERIC
 	tristate "Generic RTC support"
 	# Please consider writing a new RTC driver instead of using the generic
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 1ac694a..815733b 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -134,6 +134,7 @@ obj-$(CONFIG_RTC_DRV_RX6110)	+= rtc-rx6110.o
 obj-$(CONFIG_RTC_DRV_RX8010)	+= rtc-rx8010.o
 obj-$(CONFIG_RTC_DRV_RX8025)	+= rtc-rx8025.o
 obj-$(CONFIG_RTC_DRV_RX8581)	+= rtc-rx8581.o
+obj-$(CONFIG_RTC_DRV_RZN1)	+= rtc-rzn1.o
 obj-$(CONFIG_RTC_DRV_S35390A)	+= rtc-s35390a.o
 obj-$(CONFIG_RTC_DRV_S3C)	+= rtc-s3c.o
 obj-$(CONFIG_RTC_DRV_S5M)	+= rtc-s5m.o
diff --git a/drivers/rtc/rtc-rzn1.c b/drivers/rtc/rtc-rzn1.c
new file mode 100644
index 0000000..c589e99
--- /dev/null
+++ b/drivers/rtc/rtc-rzn1.c
@@ -0,0 +1,343 @@
+/*
+ * Renesas RZN1 Real Time Clock interface for Linux
+ *
+ * Copyright (C) 2014 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/sysctrl-rzn1.h>
+
+#define	DRIVER_NAME			"rzn1-rtc"
+
+/*
+ * Auto-generated from RTC_SUB_ipxact.xml
+ */
+#define RZN1_RTC_CTL0				0x00
+#define RZN1_RTC_CTL0_SLSB				4
+#define RZN1_RTC_CTL0_AMPM				5
+#define RZN1_RTC_CTL0_CEST				6
+#define RZN1_RTC_CTL0_CE				7
+#define RZN1_RTC_CTL1				0x04
+#define RZN1_RTC_CTL1_CT0				0
+#define RZN1_RTC_CTL1_CT1				1
+#define RZN1_RTC_CTL1_CT2				2
+#define RZN1_RTC_CTL1_1SE				3
+#define RZN1_RTC_CTL1_ALME				4
+#define RZN1_RTC_CTL1_1HZE				5
+#define RZN1_RTC_CTL2				0x08
+#define RZN1_RTC_CTL2_WAIT				0
+#define RZN1_RTC_CTL2_WST				1
+#define RZN1_RTC_CTL2_RSUB				2
+#define RZN1_RTC_CTL2_RSST				3
+#define RZN1_RTC_CTL2_WSST				4
+#define RZN1_RTC_CTL2_WUST				5
+#define RZN1_RTC_SUBC				0x0c
+#define RZN1_RTC_SRBU				0x10
+#define RZN1_RTC_SEC				0x14
+#define RZN1_RTC_MIN				0x18
+#define RZN1_RTC_HOUR				0x1c
+#define RZN1_RTC_WEEK				0x20
+#define RZN1_RTC_DAY				0x24
+#define RZN1_RTC_MONTH				0x28
+#define RZN1_RTC_YEAR				0x2c
+#define RZN1_RTC_TIME				0x30
+#define RZN1_RTC_TIME_SEC				0
+#define RZN1_RTC_TIME_SEC_MASK				0xff
+#define RZN1_RTC_TIME_MIN				8
+#define RZN1_RTC_TIME_MIN_MASK				0xff00
+#define RZN1_RTC_TIME_HOUR				16
+#define RZN1_RTC_TIME_HOUR_MASK				0xff0000
+#define RZN1_RTC_CAL				0x34
+#define RZN1_RTC_CAL_WEEK				0
+#define RZN1_RTC_CAL_WEEK_MASK				0xff
+#define RZN1_RTC_CAL_DAY				8
+#define RZN1_RTC_CAL_DAY_MASK				0xff00
+#define RZN1_RTC_CAL_MONTH				16
+#define RZN1_RTC_CAL_MONTH_MASK				0xff0000
+#define RZN1_RTC_CAL_YEAR				24
+#define RZN1_RTC_CAL_YEAR_MASK				0xff000000
+#define RZN1_RTC_SUBU				0x38
+#define RZN1_RTC_SUBU_F0				0
+#define RZN1_RTC_SUBU_F1				1
+#define RZN1_RTC_SUBU_F2				2
+#define RZN1_RTC_SUBU_F3				3
+#define RZN1_RTC_SUBU_F4				4
+#define RZN1_RTC_SUBU_F5				5
+#define RZN1_RTC_SUBU_F6				6
+#define RZN1_RTC_SUBU_DEV				7
+#define RZN1_RTC_SCMP				0x3c
+#define RZN1_RTC_ALM				0x40
+#define RZN1_RTC_ALH				0x44
+#define RZN1_RTC_ALW				0x48
+#define RZN1_RTC_ALW_ALW0				0
+#define RZN1_RTC_ALW_ALW1				1
+#define RZN1_RTC_ALW_ALW2				2
+#define RZN1_RTC_ALW_ALW3				3
+#define RZN1_RTC_ALW_ALW4				4
+#define RZN1_RTC_ALW_ALW5				5
+#define RZN1_RTC_ALW_ALW6				6
+#define RZN1_RTC_SECC				0x4c
+#define RZN1_RTC_MINC				0x50
+#define RZN1_RTC_HOURC				0x54
+#define RZN1_RTC_WEEKC				0x58
+#define RZN1_RTC_DAYC				0x5c
+#define RZN1_RTC_MONTHC				0x60
+#define RZN1_RTC_YEARC				0x64
+#define RZN1_RTC_TIMEC				0x68
+#define RZN1_RTC_TIMEC_SECC				0
+#define RZN1_RTC_TIMEC_SECC_MASK			0xff
+#define RZN1_RTC_TIMEC_MINC				8
+#define RZN1_RTC_TIMEC_MINC_MASK			0xff00
+#define RZN1_RTC_TIMEC_HOURC				16
+#define RZN1_RTC_TIMEC_HOURC_MASK			0xff0000
+#define RZN1_RTC_CALC				0x6c
+#define RZN1_RTC_CALC_WEEKC				0
+#define RZN1_RTC_CALC_WEEKC_MASK			0xff
+#define RZN1_RTC_CALC_DAYC				8
+#define RZN1_RTC_CALC_DAYC_MASK				0xff00
+#define RZN1_RTC_CALC_MONC				16
+#define RZN1_RTC_CALC_MONC_MASK				0xff0000
+#define RZN1_RTC_CALC_YEARC				24
+#define RZN1_RTC_CALC_YEARC_MASK			0xff000000
+#define RZN1_RTC_TCR				0x70
+#define RZN1_RTC_TCR_OS0				0
+#define RZN1_RTC_TCR_OS1				1
+#define RZN1_RTC_TCR_OS2				2
+#define RZN1_RTC_TCR_OS3				3
+#define RZN1_RTC_TCR_OSE				15
+#define RZN1_RTC_EMU				0x74
+#define RZN1_RTC_EMU_SVSDIS				7
+
+static void __iomem	*rtc_base;
+
+#define rtc_read(addr)		readl(rtc_base + (addr))
+#define rtc_write(val, addr)	writel(val, rtc_base + (addr))
+
+static irqreturn_t rtc_irq(int irq, void *_rtc)
+{
+	struct rtc_device *rtc = _rtc;
+
+	rtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);
+
+	return IRQ_HANDLED;
+}
+
+/* this hardware doesn't support "don't care" alarm fields */
+static int tm2bcd(struct rtc_time *tm)
+{
+	if (rtc_valid_tm(tm) != 0)
+		return -EINVAL;
+
+	tm->tm_sec = bin2bcd(tm->tm_sec);
+	tm->tm_min = bin2bcd(tm->tm_min);
+	tm->tm_hour = bin2bcd(tm->tm_hour);
+	tm->tm_mday = bin2bcd(tm->tm_mday);
+	tm->tm_mon = bin2bcd(tm->tm_mon + 1);
+	/* epoch == 1900 */
+	tm->tm_year = bin2bcd(tm->tm_year - 100);
+
+	return 0;
+}
+
+static void bcd2tm(struct rtc_time *tm)
+{
+	tm->tm_sec = bcd2bin(tm->tm_sec);
+	tm->tm_min = bcd2bin(tm->tm_min);
+	tm->tm_hour = bcd2bin(tm->tm_hour);
+	tm->tm_mday = bcd2bin(tm->tm_mday);
+	tm->tm_mon = bcd2bin(tm->tm_mon) - 1;
+	/* epoch == 1900 */
+	tm->tm_year = bcd2bin(tm->tm_year) + 100;
+}
+
+static int rzn1_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	int i, last = -1;
+
+	/* read all registers, we have to, as the timer stops when we read the
+	 * RTC_SEC and restarts after RTC_YEAR.
+	 * So we loop 3 times, and as soon as the seconds are the same as they
+	 * were in the previous pass, we stop as we can guarantee that the
+	 * stamp we have is correct */
+	for (i = 0; i < 3; i++) {
+		tm->tm_sec = rtc_read(RZN1_RTC_SECC);
+		tm->tm_min = rtc_read(RZN1_RTC_MINC);
+		tm->tm_hour = rtc_read(RZN1_RTC_HOURC);
+		tm->tm_mday = rtc_read(RZN1_RTC_DAYC);
+		tm->tm_mon = rtc_read(RZN1_RTC_MONTHC);
+		tm->tm_year = rtc_read(RZN1_RTC_YEARC);
+#ifdef DEBUG
+		printk("%s:%d:%d %d %d %d %d %d %d\n", __func__, __LINE__, i,
+			tm->tm_sec,tm->tm_min,tm->tm_hour,tm->tm_mday,
+			tm->tm_mon,tm->tm_year);
+#endif
+		if (tm->tm_sec == last)
+			break;
+		last = tm->tm_sec;
+	};
+
+	bcd2tm(tm);
+	return 0;
+}
+
+static int rzn1_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	u32 val;
+	u32 timeout = 100000;
+
+#ifdef DEBUG
+	printk("%s:%d %d %d %d %d %d %d\n", __func__, __LINE__,
+		tm->tm_sec,tm->tm_min,tm->tm_hour,tm->tm_mday,
+		tm->tm_mon,tm->tm_year);
+#endif
+	if (tm2bcd(tm) < 0)
+		return -EINVAL;
+
+	local_irq_disable();
+
+	/* Disable the counter */
+	val = rtc_read(RZN1_RTC_CTL2);
+	val |= (1 << RZN1_RTC_CTL2_WAIT);
+	rtc_write(val, RZN1_RTC_CTL2);
+
+	/* Wait for the counter to stop */
+	while (((rtc_read(RZN1_RTC_CTL2) & (1 << RZN1_RTC_CTL2_WST)) == 0) && timeout)
+		timeout--;
+#ifdef DEBUG
+	printk("%s:%d %d %d %d %d %d %d (timout=%d)\n", __func__, __LINE__,
+		tm->tm_sec,tm->tm_min,tm->tm_hour,tm->tm_mday,
+		tm->tm_mon,tm->tm_year, timeout);
+#endif
+
+	rtc_write(tm->tm_year, RZN1_RTC_YEAR);
+	rtc_write(tm->tm_mon, RZN1_RTC_MONTH);
+	rtc_write(tm->tm_mday, RZN1_RTC_DAY);
+	rtc_write(tm->tm_hour, RZN1_RTC_HOUR);
+	rtc_write(tm->tm_min, RZN1_RTC_MIN);
+	rtc_write(tm->tm_sec, RZN1_RTC_SEC);
+
+	/* Enable the counter */
+	val &= ~(1 << RZN1_RTC_CTL2_WAIT);
+	rtc_write(val, RZN1_RTC_CTL2);
+
+	local_irq_enable();
+
+	return 0;
+}
+
+static struct rtc_class_ops rzn1_rtc_ops = {
+	.read_time	= rzn1_rtc_read_time,
+	.set_time	= rzn1_rtc_set_time,
+};
+
+static int rzn1_rtc_alarm;
+static int rzn1_rtc_timer;
+
+
+static const struct of_device_id rzn1_rtc_of_match[] = {
+	{ .compatible	= "renesas,rzn1-rtc",	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, rzn1_rtc_of_match);
+
+static int rzn1_rtc_probe(struct platform_device *pdev)
+{
+	struct resource		*res;
+	struct rtc_device	*rtc;
+	struct clk 		*clk;
+	u32			val;
+
+	clk = devm_clk_get(&pdev->dev, "axi");
+	if (IS_ERR(clk) || clk_prepare_enable(clk))
+		dev_info(&pdev->dev, "no clock source\n");
+
+	/* Turn on RTC clock */
+	/* It has special (i.e. different to everything else) SYSCTRL bits */
+	val = rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_PWRCTRL_RTC);
+	val |= (1 << RZN1_SYSCTRL_REG_PWRCTRL_RTC_CLKEN_RTC);
+	rzn1_sysctrl_writel(val, RZN1_SYSCTRL_REG_PWRCTRL_RTC);
+	val |= (1 << RZN1_SYSCTRL_REG_PWRCTRL_RTC_RSTN_FW_RTC);
+	rzn1_sysctrl_writel(val, RZN1_SYSCTRL_REG_PWRCTRL_RTC);
+	val &= ~(1 << RZN1_SYSCTRL_REG_PWRCTRL_RTC_IDLE_REQ);
+	rzn1_sysctrl_writel(val, RZN1_SYSCTRL_REG_PWRCTRL_RTC);
+
+	rzn1_rtc_timer = platform_get_irq(pdev, 0);
+	if (rzn1_rtc_timer <= 0) {
+		dev_dbg(&pdev->dev, "no update irq?\n");
+		return -ENOENT;
+	}
+
+	rzn1_rtc_alarm = platform_get_irq(pdev, 1);
+	if (rzn1_rtc_alarm <= 0) {
+		dev_dbg(&pdev->dev, "no alarm irq?\n");
+		return -ENOENT;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	rtc_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(rtc_base))
+		return PTR_ERR(rtc_base);
+
+	/* force to 24 hour mode and enable clock counter */
+	rtc_write((1 << RZN1_RTC_CTL0_CE) |
+			(1 << RZN1_RTC_CTL0_AMPM), RZN1_RTC_CTL0);
+
+	/* Enable the counter */
+	rtc_write(0, RZN1_RTC_CTL2);
+
+	rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
+			&rzn1_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		dev_dbg(&pdev->dev, "can't register RTC device, err %ld\n",
+			PTR_ERR(rtc));
+		return PTR_ERR(rtc);
+	}
+	platform_set_drvdata(pdev, rtc);
+
+	/* clear pending irqs */
+	rtc_write(0, RZN1_RTC_CTL1);
+
+	/* handle periodic and alarm irqs */
+	if (devm_request_irq(&pdev->dev, rzn1_rtc_timer, rtc_irq, 0,
+			dev_name(&rtc->dev), rtc)) {
+		dev_dbg(&pdev->dev, "RTC timer interrupt IRQ%d already claimed\n",
+			rzn1_rtc_timer);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static struct platform_driver rzn1_rtc_driver = {
+	.probe		= rzn1_rtc_probe,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = rzn1_rtc_of_match,
+	},
+};
+
+module_platform_driver(rzn1_rtc_driver);
+
+MODULE_AUTHOR("Michel Pollet <Michel.Pollet@bp.renesas.com");
+MODULE_DESCRIPTION("RZN1 RTC driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index b799547..6034ae6 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -230,6 +230,28 @@ config SPI_DW_MMIO
 	tristate "Memory-mapped io interface driver for DW SPI core"
 	depends on SPI_DESIGNWARE
 
+config SPI_DW_MMIO_MUXED
+	bool "Allow the driver to activate a pin state per transaction"
+	depends on SPI_DW_MMIO
+
+config SPI_DW_RZN1
+	bool "Implement Renesas RZ/N1 extra mode for Chip Select"
+	depends on SPI_DW_MMIO
+	depends on ARCH_RZN1
+	default y
+	help
+	  Renesas RZ/N1 has a 'software' mode for chip select.
+
+	  DW SPI normal implementation has 'hardware' chip select that
+	  automatically enables and resets the CS line between transactions,
+	  or when the FIFO is empty.
+	  This prevents using the IP for making full duplex transactions, like
+	  the ones used to talk to flash/eeproms and so on.
+	  RZ/N1 IP implementation has a 'software' mode that allows the driver
+	  to have more finely grained control on the CS lines, by saying 'Y'
+	  here the driver will default to the software mode, but can still
+	  be overridden by the device tree block.
+
 config SPI_DLN2
        tristate "Diolan DLN-2 USB SPI adapter"
        depends on MFD_DLN2
diff --git a/drivers/spi/spi-dw-mmio.c b/drivers/spi/spi-dw-mmio.c
index 447497e..6159376 100644
--- a/drivers/spi/spi-dw-mmio.c
+++ b/drivers/spi/spi-dw-mmio.c
@@ -3,12 +3,17 @@
  *
  * Copyright (c) 2010, Octasic semiconductor.
  *
+ * DMA parts copied from spi-dw-mid.c:
+ * Copyright (c) 2009, 2014 Intel Corporation.
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
  */
 
 #include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
 #include <linux/err.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
@@ -20,6 +25,7 @@
 #include <linux/of_gpio.h>
 #include <linux/of_platform.h>
 #include <linux/property.h>
+#include <linux/platform_data/dma-dw.h>
 
 #include "spi-dw.h"
 
@@ -28,6 +34,350 @@
 struct dw_spi_mmio {
 	struct dw_spi  dws;
 	struct clk     *clk;
+	struct device  *dw_spi_dev;
+	struct delayed_work	work;
+	struct workqueue_struct *work_queue;
+};
+
+#define RX_BUSY		0
+#define TX_BUSY		1
+
+static int mmio_spi_dma_init(struct dw_spi *dws)
+{
+	struct dw_spi_mmio *dwsmmio = dws->priv;
+	struct device *dev = dwsmmio->dw_spi_dev;
+	int ret;
+
+	/* RX */
+	dws->rxchan = dma_request_slave_channel_reason(dev, "rx");
+	if (IS_ERR(dws->rxchan))
+		return PTR_ERR(dws->rxchan);
+
+	dev_info(dev, "DMA channel RX %s\n", dma_chan_name(dws->rxchan));
+	dws->master->dma_rx = dws->rxchan;
+
+	/* TX */
+	dws->txchan = dma_request_slave_channel_reason(dev, "tx");
+	if (IS_ERR(dws->txchan)) {
+		ret = PTR_ERR(dws->txchan);
+		goto err_rx;
+	}
+
+	dev_info(dev, "DMA channel TX %s\n", dma_chan_name(dws->txchan));
+	dws->master->dma_tx = dws->txchan;
+
+	dws->dma_inited = 1;
+	return 0;
+
+err_rx:
+	dma_release_channel(dws->rxchan);
+	return ret;
+}
+
+static void mmio_spi_dma_exit(struct dw_spi *dws)
+{
+	if (!dws->dma_inited)
+		return;
+
+	dmaengine_terminate_all(dws->txchan);
+	dma_release_channel(dws->txchan);
+
+	dmaengine_terminate_all(dws->rxchan);
+	dma_release_channel(dws->rxchan);
+}
+
+static irqreturn_t dma_transfer(struct dw_spi *dws)
+{
+	u16 irq_status = dw_readl(dws, DW_SPI_ISR);
+
+	if (!irq_status)
+		return IRQ_NONE;
+
+	dw_readl(dws, DW_SPI_ICR);
+	spi_reset_chip(dws);
+
+	dev_err(&dws->master->dev, "%s: FIFO overrun/underrun\n", __func__);
+	if (irq_status & SPI_INT_TXEI)
+		dev_err(&dws->master->dev, "%s: Tx FIFO underrun\n", __func__);
+	if (irq_status & SPI_INT_TXOI)
+		dev_err(&dws->master->dev, "%s: Tx FIFO overrun\n", __func__);
+	if (irq_status & SPI_INT_RXUI)
+		dev_err(&dws->master->dev, "%s: Rx FIFO underrun\n", __func__);
+	if (irq_status & SPI_INT_RXOI)
+		dev_err(&dws->master->dev, "%s: Rx FIFO overrun\n", __func__);
+	if (irq_status & SPI_INT_RXFI)
+		dev_err(&dws->master->dev, "%s: Rx FIFO full\n", __func__);
+	dws->master->cur_msg->status = -EIO;
+	spi_finalize_current_transfer(dws->master);
+	return IRQ_HANDLED;
+}
+
+static bool mmio_spi_can_dma(struct spi_master *master, struct spi_device *spi,
+		struct spi_transfer *xfer)
+{
+	struct dw_spi *dws = spi_master_get_devdata(master);
+
+	if (!dws->dma_inited)
+		return false;
+
+	return xfer->len > dws->fifo_len;
+}
+
+static enum dma_slave_buswidth convert_dma_width(u32 dma_width)
+{
+	if (dma_width == 1)
+		return DMA_SLAVE_BUSWIDTH_1_BYTE;
+	else if (dma_width == 2)
+		return DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	return DMA_SLAVE_BUSWIDTH_UNDEFINED;
+}
+
+static void dma_tx_complete_work(struct work_struct *work)
+{
+	struct dw_spi_mmio *dwsmmio =
+		container_of(work, struct dw_spi_mmio, work.work);
+	struct dw_spi *dws = &dwsmmio->dws;
+
+	spi_finalize_current_transfer(dws->master);
+}
+
+/*
+ * dws->dma_chan_busy is set before the dma transfer starts, callback for tx
+ * channel will clear a corresponding bit.
+ */
+static void dw_spi_dma_tx_done(void *arg)
+{
+	struct dw_spi *dws = arg;
+	struct dw_spi_mmio *dwsmmio = dws->priv;
+	u32 delay;
+	u32 words_to_tx;
+
+	clear_bit(TX_BUSY, &dws->dma_chan_busy);
+	if (test_bit(RX_BUSY, &dws->dma_chan_busy))
+		return;
+
+	/*
+	 * Although the DMA is complete, the SPI transaction on the wire is not!
+	 * DMA writes to the SPI FIFO and so we need to wait until the FIFO has
+	 * been drained and shifted out.
+	 */
+	words_to_tx = dw_readl(dws, DW_SPI_TXFLR);
+
+	/* Calc time until the data has been put on the wire (in us) */
+	delay = 1000000 / (dws->max_freq / dw_readl(dws, DW_SPI_BAUDR));
+	delay *= words_to_tx;
+	delay *= (8 * dws->dma_width) + 2; /* 8 bits per byte + 2 for framing */
+
+	/*
+	 * At 500KHz SPI clock, this delay is 320us and we are in atomic
+	 * context. Therefore, we defer this to a workqueue.
+	 * Arbitary threshold where it is better to just delay.
+	 */
+	if (delay <= 20) {
+		udelay(delay);
+		spi_finalize_current_transfer(dws->master);
+	} else {
+		queue_delayed_work(dwsmmio->work_queue,
+				&dwsmmio->work, usecs_to_jiffies(delay) + 1);
+	}
+}
+
+static struct dma_async_tx_descriptor *dw_spi_dma_prepare_tx(struct dw_spi *dws,
+		struct spi_transfer *xfer)
+{
+	struct dma_slave_config txconf;
+	struct dma_async_tx_descriptor *txdesc;
+	u32 val = 0;
+
+	if (!xfer->tx_buf)
+		return NULL;
+
+	txconf.direction = DMA_MEM_TO_DEV;
+	txconf.dst_addr = dws->dma_addr;
+	txconf.dst_maxburst = dws->fifo_len / 2;
+	txconf.src_maxburst = 4;
+	txconf.dst_addr_width = convert_dma_width(dws->dma_width);
+	txconf.device_fc = false;
+
+#ifdef CONFIG_SPI_DW_RZN1
+	txconf.device_fc = true;
+
+	/* The DMAC uses the maxburst size if the transfer is bigger than it */
+	if (txconf.dst_maxburst == 1)
+		val |= SPI_xDMACR_1_WORD_BURST;
+	else if (txconf.dst_maxburst == 4)
+		val |= SPI_xDMACR_4_WORD_BURST;
+	else if (txconf.dst_maxburst == 8)
+		val |= SPI_xDMACR_8_WORD_BURST;
+	dw_writel(dws, DW_SPI_TDMACR, val);
+
+	/* Block size */
+	val |= (xfer->len / dws->dma_width) << SPI_xDMACR_BLK_SIZE_OFFSET;
+
+	val |= SPI_xDMACR_DMA_EN;
+	dw_writel(dws, DW_SPI_TDMACR, val);
+#endif
+
+	dmaengine_slave_config(dws->txchan, &txconf);
+
+	txdesc = dmaengine_prep_slave_sg(dws->txchan,
+				xfer->tx_sg.sgl,
+				xfer->tx_sg.nents,
+				DMA_MEM_TO_DEV,
+				DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!txdesc)
+		return NULL;
+
+	txdesc->callback = dw_spi_dma_tx_done;
+	txdesc->callback_param = dws;
+
+	return txdesc;
+}
+
+/*
+ * dws->dma_chan_busy is set before the dma transfer starts, callback for rx
+ * channel will clear a corresponding bit.
+ */
+static void dw_spi_dma_rx_done(void *arg)
+{
+	struct dw_spi *dws = arg;
+
+	clear_bit(RX_BUSY, &dws->dma_chan_busy);
+	if (test_bit(TX_BUSY, &dws->dma_chan_busy))
+		return;
+	spi_finalize_current_transfer(dws->master);
+}
+
+static struct dma_async_tx_descriptor *dw_spi_dma_prepare_rx(struct dw_spi *dws,
+		struct spi_transfer *xfer)
+{
+	struct dma_slave_config rxconf;
+	struct dma_async_tx_descriptor *rxdesc;
+	u32 val = 0;
+
+	if (!xfer->rx_buf)
+		return NULL;
+
+	rxconf.direction = DMA_DEV_TO_MEM;
+	rxconf.src_addr = dws->dma_addr;
+	rxconf.src_maxburst = dws->fifo_len / 2;
+	rxconf.dst_maxburst = 4;
+	rxconf.src_addr_width = convert_dma_width(dws->dma_width);
+	rxconf.device_fc = false;
+
+#ifdef CONFIG_SPI_DW_RZN1
+	rxconf.device_fc = true;
+
+	/* The DMAC uses the maxburst size if the transfer is bigger than it */
+	if (rxconf.src_maxburst == 1)
+		val |= SPI_xDMACR_1_WORD_BURST;
+	else if (rxconf.src_maxburst == 4)
+		val |= SPI_xDMACR_4_WORD_BURST;
+	else if (rxconf.src_maxburst == 8)
+		val |= SPI_xDMACR_8_WORD_BURST;
+	dw_writel(dws, DW_SPI_RDMACR, val);
+
+	/* Block size */
+	val |= (xfer->len / dws->dma_width) << SPI_xDMACR_BLK_SIZE_OFFSET;
+
+	val |= SPI_xDMACR_DMA_EN;
+	dw_writel(dws, DW_SPI_RDMACR, val);
+#endif
+
+	dmaengine_slave_config(dws->rxchan, &rxconf);
+
+	rxdesc = dmaengine_prep_slave_sg(dws->rxchan,
+				xfer->rx_sg.sgl,
+				xfer->rx_sg.nents,
+				DMA_DEV_TO_MEM,
+				DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!rxdesc)
+		return NULL;
+
+	rxdesc->callback = dw_spi_dma_rx_done;
+	rxdesc->callback_param = dws;
+
+	return rxdesc;
+}
+
+static int mmio_spi_dma_setup(struct dw_spi *dws, struct spi_transfer *xfer)
+{
+	u16 dma_ctrl = 0;
+	u32 cr0;
+
+	/* watermarks for initiating DMA requests, both set to half the FIFO */
+	dw_writel(dws, DW_SPI_DMARDLR, (dws->fifo_len / 2) - 1);
+	dw_writel(dws, DW_SPI_DMATDLR, dws->fifo_len / 2);
+
+	/* Always enable tx */
+	dma_ctrl |= SPI_DMA_TDMAE;
+	if (xfer->rx_buf)
+		dma_ctrl |= SPI_DMA_RDMAE;
+	dw_writel(dws, DW_SPI_DMACR, dma_ctrl);
+
+	/* If tx only, set transfer mode to avoid data in the rx fifo */
+	cr0 = dw_readl(dws, DW_SPI_CTRL0);
+	cr0 &= ~SPI_TMOD_MASK;
+	if (!xfer->rx_buf)
+		cr0 |= (SPI_TMOD_TO << SPI_TMOD_OFFSET);
+	else
+		cr0 |= (SPI_TMOD_TR << SPI_TMOD_OFFSET);
+	dw_writel(dws, DW_SPI_CTRL0, cr0);
+
+	/* Set the interrupt mask */
+	spi_umask_intr(dws, SPI_INT_TXOI | SPI_INT_RXUI | SPI_INT_RXOI);
+
+	dws->transfer_handler = dma_transfer;
+
+	return 0;
+}
+
+static int mmio_spi_dma_transfer(struct dw_spi *dws, struct spi_transfer *xfer)
+{
+	struct dma_async_tx_descriptor *txdesc, *rxdesc;
+
+	/* Prepare the TX dma transfer */
+	txdesc = dw_spi_dma_prepare_tx(dws, xfer);
+
+	/* Prepare the RX dma transfer */
+	rxdesc = dw_spi_dma_prepare_rx(dws, xfer);
+
+	/* rx must be started before tx due to spi instinct */
+	if (rxdesc) {
+		set_bit(RX_BUSY, &dws->dma_chan_busy);
+		dmaengine_submit(rxdesc);
+		dma_async_issue_pending(dws->rxchan);
+	}
+
+	if (txdesc) {
+		set_bit(TX_BUSY, &dws->dma_chan_busy);
+		dmaengine_submit(txdesc);
+		dma_async_issue_pending(dws->txchan);
+	}
+
+	return 0;
+}
+
+static void mmio_spi_dma_stop(struct dw_spi *dws)
+{
+	if (test_bit(TX_BUSY, &dws->dma_chan_busy)) {
+		dmaengine_terminate_all(dws->txchan);
+		clear_bit(TX_BUSY, &dws->dma_chan_busy);
+	}
+	if (test_bit(RX_BUSY, &dws->dma_chan_busy)) {
+		dmaengine_terminate_all(dws->rxchan);
+		clear_bit(RX_BUSY, &dws->dma_chan_busy);
+	}
+}
+
+static struct dw_spi_dma_ops mmio_dma_ops = {
+	.dma_init	= mmio_spi_dma_init,
+	.dma_exit	= mmio_spi_dma_exit,
+	.dma_setup	= mmio_spi_dma_setup,
+	.can_dma	= mmio_spi_can_dma,
+	.dma_transfer	= mmio_spi_dma_transfer,
+	.dma_stop	= mmio_spi_dma_stop,
 };
 
 static int dw_spi_mmio_probe(struct platform_device *pdev)
@@ -78,6 +428,33 @@ static int dw_spi_mmio_probe(struct platform_device *pdev)
 
 	dws->num_cs = num_cs;
 
+#ifdef CONFIG_SPI_DW_RZN1
+	/* default to sw mode on that platform, the HW mode is next to useless
+	 * for most purposes */
+	dws->mode = (1 << dws->num_cs) -1;
+	if (pdev->dev.of_node) {
+		struct device_node *child = NULL;
+
+		of_property_read_u32(pdev->dev.of_node,
+			"renesas,rzn1-cs-mode", &dws->mode);
+		/* Also check the mode in each of the separate child nodes */
+		for_each_available_child_of_node(pdev->dev.of_node, child) {
+			u32 addr;
+			int ret = of_property_read_u32(child, "reg", &addr);
+
+			if (ret || addr >= dws->num_cs) {
+				dev_warn(&pdev->dev, "invalid slave %s",
+					child->name);
+				continue;
+			}
+			if (of_property_read_bool(child, "renesas,rzn1-cs-sw"))
+				dws->mode |= (1 << addr);
+			if (of_property_read_bool(child, "renesas,rzn1-cs-hw"))
+				dws->mode &= ~(1 << addr);
+		}
+	}
+#endif
+
 	if (pdev->dev.of_node) {
 		int i;
 
@@ -99,10 +476,26 @@ static int dw_spi_mmio_probe(struct platform_device *pdev)
 		}
 	}
 
+	dwsmmio->dw_spi_dev = &pdev->dev;
+	dws->priv = dwsmmio;
+	dws->paddr = (unsigned long)(mem->start);
+	dws->dma_ops = &mmio_dma_ops;
+
+	INIT_DELAYED_WORK(&dwsmmio->work, dma_tx_complete_work);
+	dwsmmio->work_queue = create_singlethread_workqueue(dev_name(&pdev->dev));
+	if (!dwsmmio->work_queue) {
+		dev_err(&pdev->dev, "failed to create workqueue\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
 	ret = dw_spi_add_host(&pdev->dev, dws);
 	if (ret)
 		goto out;
 
+	/* DMA requires tx whilst doing an rx */
+	dws->master->flags = SPI_MASTER_MUST_TX;
+
 	platform_set_drvdata(pdev, dwsmmio);
 	return 0;
 
diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c
index 27960e4..4f7db89 100644
--- a/drivers/spi/spi-dw.c
+++ b/drivers/spi/spi-dw.c
@@ -136,13 +136,33 @@ static void dw_spi_set_cs(struct spi_device *spi, bool enable)
 {
 	struct dw_spi *dws = spi_master_get_devdata(spi->master);
 	struct chip_data *chip = spi_get_ctldata(spi);
-
+#ifdef CONFIG_SPI_DW_RZN1
+	int cs;
+	u32 reg;
+#endif
 	/* Chip select logic is inverted from spi_set_cs() */
+#ifdef CONFIG_SPI_DW_MMIO_MUXED
+	if (dws->pinon)
+		pinctrl_select_state(dws->pinctrl,
+			enable ? NULL : dws->pinon);
+#endif
 	if (chip && chip->cs_control)
 		chip->cs_control(!enable);
 
+#ifdef CONFIG_SPI_DW_RZN1
+	/* RZN1 version of the IP can be configured to use a 'software mode'
+	 * in which case the CS bit is just shifted 4 bits up, and the lower
+	 * 4 bits are ignored */
+	cs = spi->chip_select + ((dws->mode & (1 << spi->chip_select)) ?
+			DW_SPI_SER_SW_OFFSET : DW_SPI_SER_HW_OFFSET);
+	reg = (dw_readl(dws, DW_SPI_SER) &
+		~((1 << cs) | (1 << spi->chip_select)));
+	reg |= (!enable << cs) | (!enable << spi->chip_select);
+	dw_writel(dws, DW_SPI_SER, reg);
+#else
 	if (!enable)
 		dw_writel(dws, DW_SPI_SER, BIT(spi->chip_select));
+#endif
 }
 
 /* Return the max entries we can fill into tx fifo */
@@ -466,6 +486,12 @@ static void spi_hw_init(struct device *dev, struct dw_spi *dws)
 		dws->fifo_len = (fifo == 1) ? 0 : fifo;
 		dev_dbg(dev, "Detected FIFO size: %u bytes\n", dws->fifo_len);
 	}
+#ifdef CONFIG_SPI_DW_RZN1
+	dev_dbg(dev, "RZ/N1 CS Config: 0x%x (%04x)\n", dws->mode,
+		dw_readl(dws, DW_SPI_SER));
+	/* Mark the software ones */
+	dw_writel(dws, DW_SPI_SER, dws->mode << DW_SPI_SER_CS_CONF_OFFSET);
+#endif
 }
 
 int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
@@ -485,6 +511,16 @@ int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
 	dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);
 	snprintf(dws->name, sizeof(dws->name), "dw_spi%d", dws->bus_num);
 
+#ifdef CONFIG_SPI_DW_MMIO_MUXED
+	dws->pinctrl = devm_pinctrl_get(dev);
+	if (!IS_ERR(dws->pinctrl)) {
+		dws->pinon = pinctrl_lookup_state(dws->pinctrl, "active");
+		if (IS_ERR(dws->pinon)) {
+			dev_warn(dev, "Invalid 'active' pinmux configuration\n");
+			dws->pinon = NULL;
+		}
+	}
+#endif
 	ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dws->name, master);
 	if (ret < 0) {
 		dev_err(dev, "can not get IRQ\n");
diff --git a/drivers/spi/spi-dw.h b/drivers/spi/spi-dw.h
index c21ca02..0542c0d 100644
--- a/drivers/spi/spi-dw.h
+++ b/drivers/spi/spi-dw.h
@@ -4,6 +4,9 @@
 #include <linux/io.h>
 #include <linux/scatterlist.h>
 #include <linux/gpio.h>
+#ifdef CONFIG_SPI_DW_MMIO_MUXED
+#include <linux/pinctrl/consumer.h>
+#endif
 
 /* Register offsets */
 #define DW_SPI_CTRL0			0x00
@@ -32,6 +35,10 @@
 #define DW_SPI_VERSION			0x5c
 #define DW_SPI_DR			0x60
 
+/* RZ/N1 special registers */
+#define DW_SPI_TDMACR			0x100
+#define DW_SPI_RDMACR			0x104
+
 /* Bit fields in CTRLR0 */
 #define SPI_DFS_OFFSET			0
 
@@ -78,6 +85,13 @@
 #define SPI_DMA_RDMAE			(1 << 0)
 #define SPI_DMA_TDMAE			(1 << 1)
 
+/* RZ/N1 special registers */
+#define SPI_xDMACR_BLK_SIZE_OFFSET	3
+#define SPI_xDMACR_DMA_EN		(1 << 0)
+#define SPI_xDMACR_1_WORD_BURST		(0 << 1)
+#define SPI_xDMACR_4_WORD_BURST		(1 << 1)
+#define SPI_xDMACR_8_WORD_BURST		(2 << 1)
+
 /* TX RX interrupt level threshold, max can be 256 */
 #define SPI_INT_THRESHOLD		32
 
@@ -115,10 +129,10 @@ struct dw_spi {
 
 	/* Current message transfer state info */
 	size_t			len;
-	void			*tx;
-	void			*tx_end;
-	void			*rx;
-	void			*rx_end;
+	u8			*tx;
+	u8			*tx_end;
+	u8			*rx;
+	u8			*rx_end;
 	int			dma_mapped;
 	u8			n_bytes;	/* current is a 1/2 bytes op */
 	u32			dma_width;
@@ -140,7 +154,23 @@ struct dw_spi {
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *debugfs;
 #endif
+#ifdef CONFIG_SPI_DW_MMIO_MUXED
+	struct pinctrl 		*pinctrl;
+	struct pinctrl_state 	*pinon;
+#endif
+#ifdef CONFIG_SPI_DW_RZN1
+	/* bitfield, bit is 1 for software mode, 0 for hardware mode */
+	u32			mode;
+#endif
+};
+
+#ifdef CONFIG_SPI_DW_RZN1
+enum {
+	DW_SPI_SER_HW_OFFSET 	= 0,
+	DW_SPI_SER_SW_OFFSET 	= 4,
+	DW_SPI_SER_CS_CONF_OFFSET 	= 8,
 };
+#endif
 
 static inline u32 dw_readl(struct dw_spi *dws, u32 offset)
 {
diff --git a/drivers/usb/gadget/function/rndis.c b/drivers/usb/gadget/function/rndis.c
index ab6ac1b..20885af 100644
--- a/drivers/usb/gadget/function/rndis.c
+++ b/drivers/usb/gadget/function/rndis.c
@@ -856,6 +856,10 @@ int rndis_msg_parser(struct rndis_params *params, u8 *buf)
 		 */
 		pr_warning("%s: unknown RNDIS message 0x%08X len %d\n",
 			__func__, MsgType, MsgLength);
+		/* In case of garbled message, MsgLenght can be 'negative'
+		 * or stupidly large, lets try not to kill the board */
+		if (MsgLength > 16)
+			MsgLength = 16;
 		print_hex_dump_bytes(__func__, DUMP_PREFIX_OFFSET,
 				     buf, MsgLength);
 		break;
diff --git a/drivers/usb/gadget/function/u_ether.c b/drivers/usb/gadget/function/u_ether.c
index 5d1bd13..3e0cb4b 100644
--- a/drivers/usb/gadget/function/u_ether.c
+++ b/drivers/usb/gadget/function/u_ether.c
@@ -24,6 +24,13 @@
 
 #include "u_ether.h"
 
+#ifdef CONFIG_USBF_RENESAS
+/* Renesas device only supports aligned DMA -- if we use NET_IP_ALIGN here
+ * we'll never be able to use DMA with the ethernet gadget */
+#define UETH_SKB_ALIGN	0
+#else
+#define UETH_SKB_ALIGN	NET_IP_ALIGN
+#endif
 
 /*
  * This component encapsulates the Ethernet link glue needed to provide
@@ -224,7 +231,7 @@ static void defer_kevent(struct eth_dev *dev, int flag)
 	if (dev->port_usb->is_fixed)
 		size = max_t(size_t, size, dev->port_usb->fixed_out_len);
 
-	skb = alloc_skb(size + NET_IP_ALIGN, gfp_flags);
+	skb = alloc_skb(size + UETH_SKB_ALIGN, gfp_flags);
 	if (skb == NULL) {
 		DBG(dev, "no rx skb\n");
 		goto enomem;
@@ -235,7 +242,7 @@ static void defer_kevent(struct eth_dev *dev, int flag)
 	 * RNDIS headers involve variable numbers of LE32 values.
 	 */
 	if (likely(!dev->no_skb_reserve))
-		skb_reserve(skb, NET_IP_ALIGN);
+		skb_reserve(skb, UETH_SKB_ALIGN);
 
 	req->buf = skb->data;
 	req->length = size;
diff --git a/drivers/usb/gadget/udc/Kconfig b/drivers/usb/gadget/udc/Kconfig
index 658b8da..2465d6d9 100644
--- a/drivers/usb/gadget/udc/Kconfig
+++ b/drivers/usb/gadget/udc/Kconfig
@@ -140,6 +140,17 @@ config USB_PXA25X
 	   dynamically linked module called "pxa25x_udc" and force all
 	   gadget drivers to also be dynamically linked.
 
+config USBF_RENESAS
+	tristate "Renesas USB Function Peripheral Block (RZ/N1)"
+	depends on ARCH_RZN1
+	help
+	   Renesas RZ/N1 USB function block. Has integrated DMA, 16
+	   endpoints. The pretty name for this IP is
+	   "NPPFAHBUSB2HOSTFUNCV31,41". Yes, it is.
+
+	   Say "y" to link the driver statically, or "m" to build a
+	   dynamically linked module called "usbf_renesas".
+
 # if there's only one gadget driver, using only two bulk endpoints,
 # don't waste memory for the other endpoints
 config USB_PXA25X_SMALL
diff --git a/drivers/usb/gadget/udc/Makefile b/drivers/usb/gadget/udc/Makefile
index 98e74ed..ce084b1 100644
--- a/drivers/usb/gadget/udc/Makefile
+++ b/drivers/usb/gadget/udc/Makefile
@@ -37,3 +37,5 @@ obj-$(CONFIG_USB_MV_U3D)	+= mv_u3d_core.o
 obj-$(CONFIG_USB_GR_UDC)	+= gr_udc.o
 obj-$(CONFIG_USB_GADGET_XILINX)	+= udc-xilinx.o
 obj-$(CONFIG_USB_BDC_UDC)	+= bdc/
+obj-$(CONFIG_USBF_RENESAS)	+= usbf-renesas.o
+obj-$(CONFIG_USBF_RENESAS)	+= usbf-renesas-ep0.o usbf-renesas-epn.o
diff --git a/drivers/usb/gadget/udc/usbf-renesas-ep0.c b/drivers/usb/gadget/udc/usbf-renesas-ep0.c
new file mode 100644
index 0000000..06e0b49
--- /dev/null
+++ b/drivers/usb/gadget/udc/usbf-renesas-ep0.c
@@ -0,0 +1,441 @@
+/*
+ * Renesas RZ/N1 USB Device usb gadget driver
+ *
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ * Author: Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include "usbf-renesas.h"
+
+/*
+ * Endpoint 0 callbacks
+ */
+
+static int usbf_ep0_flush_buffer(
+	struct f_regs_ep0 *ep_reg,
+	uint32_t bits)
+{
+	int res = 100000;
+
+	if ((readl(&ep_reg->status) & bits) == bits)
+		return res;
+
+	writel(readl(&ep_reg->control) | D_EP0_BCLR, &ep_reg->control);
+
+	while (res-- && ((readl(&ep_reg->status) & bits) != bits))
+		;
+
+	if (!res)
+		printk("%s timeout on buffer clear!\n", __func__);
+
+	return res;
+}
+
+static void usbf_ep0_clear_inak(
+	struct f_regs_ep0 *ep_reg)
+{
+	writel((readl(&ep_reg->control)|D_EP0_INAK_EN) & ~D_EP0_INAK,
+	       &ep_reg->control);
+}
+
+static void usbf_ep0_clear_onak(
+	struct f_regs_ep0 *ep_reg)
+{
+	writel((readl(&ep_reg->control)) & ~D_EP0_ONAK, &ep_reg->control);
+}
+
+static void usbf_ep0_stall(
+	struct f_regs_ep0 *ep_reg)
+{
+	writel(readl(&ep_reg->control) | D_EP0_STL, &ep_reg->control);
+}
+
+static int usbf_ep0_enable(
+	struct f_endpoint *ep)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+
+	writel(D_EP0_INAK_EN | D_EP0_BCLR, &ep_reg->control);
+	writel(D_EP0_SETUP_EN | D_EP0_STG_START_EN |
+	       D_EP0_OUT_EN,
+	       &ep_reg->int_enable);
+	return 0;
+}
+
+static void usbf_ep0_reset(
+	struct f_endpoint *ep)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+
+	writel(readl(&ep_reg->control) | D_EP0_BCLR, &ep_reg->control);
+}
+
+static int usbf_ep0_send1(
+	struct f_endpoint *ep,
+	uint32_t *src,
+	int reqlen)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+	uint32_t control;
+	int w, len, err;
+	uint32_t val;
+	int pkt_words = reqlen / sizeof(*src);
+
+	/* Wait until there is space to write the pkt */
+	err = readl_poll_timeout(&ep_reg->status, val, (val & D_EP0_IN_EMPTY),
+			0, 10000);
+	if (err)
+		return -ETIMEDOUT;
+
+	/* Note, we don't care about endianness here, as the IP
+	 * and the core will have the same layout anyway, so we
+	 * can happily ignore it */
+	for (w = 0; w < pkt_words; w++)
+		writel(*src++, &ep_reg->write);
+
+	control = readl(&ep_reg->control);
+
+	/* if we have stray bytes, write them off too, and mark the
+	 * control registers so it knows only 1,2,3 bytes are valid in
+	 * the last write we made */
+	len = reqlen & (sizeof(*src) - 1);
+	if (len) {
+		writel(*src, &ep_reg->write);
+		control |= (len << 5);
+	}
+
+	writel(control | D_EP0_DEND, &ep_reg->control);
+
+	return 0;
+}
+
+static int usbf_ep0_send(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+
+	/* Special handling for internally generated NULL packets */
+	if (!req) {
+		writel(readl(&ep_reg->control) | D_EP0_DEND, &ep_reg->control);
+		return 0;
+	}
+
+	if (req->req.length) {
+		void *src = req->req.buf;
+		int bytes = req->req.length;
+		int maxpkt_bytes = ep->ep.maxpacket;
+		int ret;
+
+		while (bytes > 0) {
+			int pkt_bytes = min(bytes, maxpkt_bytes);
+
+			ret = usbf_ep0_send1(ep, src, pkt_bytes);
+			if (ret < 0) {
+				req->req.status = ret;
+				return ret;
+			}
+
+			bytes -= pkt_bytes;
+			src += pkt_bytes;
+		}
+		req->req.actual = req->req.length;
+		req->req.status = 0;
+	}
+
+	/* UDC asking for a ZLP to follow? */
+	if (req->req.length == 0 || req->req.zero)
+		req->req.status = usbf_ep0_send1(ep, NULL, 0);
+
+	TRACERQ(req, "%s[%d][%3d] sent %d\n", __func__,
+		ep->id, req->seq, req->req.length);
+
+	return req->req.status;
+}
+
+/*
+ * This can be called repeatedly until the request is done
+ */
+static int usbf_ep0_recv(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	return req->req.status;
+}
+
+static void usbf_ep0_out_isr(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_regs_ep0 *ep_reg = &ep->chip->regs->ep0;
+	uint32_t reqlen = readl(&ep_reg->length);
+	int len = reqlen;
+	uint32_t *buf  = req->req.buf + req->req.actual;
+
+	TRACEEP(ep, "%s[%3d] size %d (%d/%d)\n", __func__, req->seq, len,
+	      req->req.actual, req->req.length);
+	while (len > 0) {
+		*buf++ = readl(&ep_reg->read);
+		len -= 4;
+	}
+	req->req.actual += reqlen;
+
+	if (reqlen != usb_endpoint_maxp(ep->desc))
+		req->req.status = 0;
+}
+
+
+/*
+ * result of setup packet
+ */
+#define CX_IDLE		0
+#define CX_FINISH	1
+#define CX_STALL	2
+
+static void usbf_ep0_setup(
+	struct f_endpoint *ep,
+	struct usb_ctrlrequest *ctrl)
+{
+	int ret = CX_IDLE;
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep0 *ep_reg = &chip->regs->ep0;
+	uint16_t value = ctrl->wValue & 0xff;
+
+	if (ctrl->bRequestType & USB_DIR_IN)
+		ep->desc->bEndpointAddress = USB_DIR_IN;
+	else
+		ep->desc->bEndpointAddress = USB_DIR_OUT;
+
+	/* TODO:
+	 * This is mandatory, as for the moment at least, we never get an
+	 * interrupt/status flag indicating the speed has changed. And without
+	 * a speed change flag, the gadget upper layer is incapable of finding
+	 * a valid configuration */
+	if (readl(&chip->regs->status) & D_USB_SPEED_MODE)
+		chip->gadget.speed = USB_SPEED_HIGH;
+	else
+		chip->gadget.speed = USB_SPEED_FULL;
+
+	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
+		switch (ctrl->bRequest) {
+		case USB_REQ_SET_CONFIGURATION:
+			TRACEEP(ep, "usbf: set_cfg(%d)\n", value);
+			if (!value) {
+				/* Disable all endpoints other than EP0 */
+				writel(readl(&chip->regs->control) & ~D_USB_CONF,
+				       &chip->regs->control);
+
+				usb_gadget_set_state(&chip->gadget, USB_STATE_ADDRESS);
+			} else {
+				/* Enable all endpoints */
+				writel(readl(&chip->regs->control) | D_USB_CONF,
+				       &chip->regs->control);
+
+				usb_gadget_set_state(&chip->gadget, USB_STATE_CONFIGURED);
+			}
+			ret = CX_IDLE;
+			break;
+
+		case USB_REQ_SET_ADDRESS:
+			TRACEEP(ep, "usbf: set_addr(0x%04X)\n", ctrl->wValue);
+			writel(value << 16, &chip->regs->address);
+			usb_gadget_set_state(&chip->gadget, USB_STATE_ADDRESS);
+			ret = CX_FINISH;
+			break;
+
+		case USB_REQ_CLEAR_FEATURE:
+			TRACEEP(ep, "usbf: clr_feature(%d, %d)\n",
+			      ctrl->bRequestType & 0x03, ctrl->wValue);
+			switch (ctrl->wValue) {
+			case 0:    /* [Endpoint] halt */
+				/* TODO ? */
+			/*	ep_reset(chip, ctrl->wIndex); */
+				TRACEEP(ep, "endpoint reset ?!?\n");
+				ret = CX_FINISH;
+				break;
+			case 1:    /* [Device] remote wake-up */
+			case 2:    /* [Device] test mode */
+			default:
+				ret = CX_STALL;
+				break;
+			}
+			break;
+
+		case USB_REQ_SET_FEATURE:
+			TRACEEP(ep, "usbf: set_feature(%d, %d)\n",
+			      ctrl->wValue, ctrl->wIndex & 0xf);
+			switch (ctrl->wValue) {
+			case 0:    /* Endpoint Halt */
+				ret = CX_FINISH;
+				/* TODO */
+			/*	id = ctrl->wIndex & 0xf; */
+				break;
+			case 1:    /* Remote Wakeup */
+			case 2:    /* Test Mode */
+			default:
+				ret = CX_STALL;
+				break;
+			}
+			break;
+		case USB_REQ_GET_STATUS:
+			TRACEEP(ep, "usbf: get_status(%d, %d, type %d)\n",
+			      ctrl->wValue, ctrl->wIndex,
+			      ctrl->bRequestType & USB_RECIP_MASK);
+			chip->setup[0] = 0;
+			switch (ctrl->bRequestType & USB_RECIP_MASK) {
+			case USB_RECIP_DEVICE:
+				chip->setup[0] = 1 << USB_DEVICE_SELF_POWERED;
+				break;
+			}
+			/* mark it as static, don't 'free' it */
+			chip->setup_reply.req.complete = NULL;
+			chip->setup_reply.req.buf = &chip->setup;
+			chip->setup_reply.req.length = 2;
+			usb_ep_queue(&ep->ep, &chip->setup_reply.req, 0);
+			ret = CX_FINISH;
+			break;
+		case USB_REQ_SET_DESCRIPTOR:
+			TRACEEP(ep, "usbf: set_descriptor\n");
+			break;
+		}
+	} /* if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) */
+
+	if (!chip->driver) {
+		dev_warn(chip->dev, "Spurious SETUP");
+		ret = CX_STALL;
+	} else if (ret == CX_IDLE && chip->driver->setup) {
+		if (chip->driver->setup(&chip->gadget, ctrl) < 0)
+			ret = CX_STALL;
+		else
+			ret = CX_FINISH;
+	}
+
+	switch (ret) {
+	case CX_FINISH:
+		break;
+	case CX_STALL:
+		usbf_ep0_stall(ep_reg);
+		TRACEEP(ep, "usbf: cx_stall!\n");
+		break;
+	case CX_IDLE:
+		TRACEEP(ep, "usbf: cx_idle?\n");
+	default:
+		break;
+	}
+}
+
+static int usbf_req_is_control_no_data(struct usb_ctrlrequest *ctrl)
+{
+	return (ctrl->wLength == 0);
+}
+
+static int usbf_req_is_control_read(struct usb_ctrlrequest *ctrl)
+{
+	if (ctrl->wLength && (ctrl->bRequestType & USB_DIR_IN))
+		return 1;
+	return 0;
+}
+
+static int usbf_req_is_control_write(struct usb_ctrlrequest *ctrl)
+{
+	if (ctrl->wLength && !(ctrl->bRequestType & USB_DIR_IN))
+		return 1;
+	return 0;
+}
+
+static void usbf_ep0_interrupt(
+	struct f_endpoint *ep)
+{
+	struct f_regs_ep0 *ep_reg = &ep->chip->regs->ep0;
+	struct f_drv *chip = ep->chip;
+	struct usb_ctrlrequest *ctrl = (struct usb_ctrlrequest *)chip->setup;
+
+/*	TRACE("%s status %08x control %08x\n", __func__, ep->status,
+		readl(&ep_reg->control)); */
+
+	if (ep->status & D_EP0_OUT_INT) {
+		struct f_req *req;
+
+		spin_lock_irq(&ep->lock);
+		req = list_first_entry_or_null(&ep->queue, struct f_req, queue);
+		spin_unlock_irq(&ep->lock);
+
+		if (req)
+			usbf_ep0_out_isr(ep, req);
+	}
+
+	if (ep->status & D_EP0_SETUP_INT) {
+		chip->setup[0] = readl(&chip->regs->setup_data0);
+		chip->setup[1] = readl(&chip->regs->setup_data1);
+
+		TRACEEP(ep, "%s SETUP %08x %08x dir %s len:%d\n", __func__,
+		      chip->setup[0], chip->setup[1],
+		      (ctrl->bRequestType & USB_DIR_IN) ? "input" : "output",
+		      readl(&ep->chip->regs->ep0.length));
+
+		if (usbf_req_is_control_write(ctrl)) {
+			usbf_ep0_clear_onak(ep_reg);
+		}
+		if (usbf_req_is_control_read(ctrl)) {
+			usbf_ep0_flush_buffer(ep_reg, D_EP0_IN_EMPTY);
+			usbf_ep0_clear_inak(ep_reg);
+		}
+
+		usbf_ep0_setup(ep, ctrl);
+	}
+	if (ep->status & D_EP0_STG_START_INT) {
+		TRACEEP(ep, "%s START %08x %08x (empty: %s)\n", __func__,
+		      chip->setup[0], chip->setup[1],
+		      (ep->status & D_EP0_IN_EMPTY) ?
+				"IN empty" : "IN NOT empty");
+
+		if (usbf_req_is_control_read(ctrl)) {
+			usbf_ep0_clear_onak(ep_reg);
+		}
+		if (usbf_req_is_control_write(ctrl)) {
+			usbf_ep0_flush_buffer(ep_reg, D_EP0_OUT_EMPTY);
+			usbf_ep0_clear_inak(ep_reg);
+		}
+		if (usbf_req_is_control_no_data(ctrl)) {
+			usbf_ep0_flush_buffer(ep_reg, D_EP0_IN_EMPTY);
+			usbf_ep0_clear_inak(ep_reg);
+		}
+
+		/* TODO, we should send a NULL packet for Control-No-Data, but read a NULL packet for Control-Read */
+		usbf_ep0_send(ep, NULL);
+	}
+
+	ep->status = 0;
+}
+
+static const struct f_endpoint_drv usbf_ep0_callbacks = {
+	.enable = usbf_ep0_enable,
+	/* No DMA callbacks for endpoint 0 */
+	.recv[USBF_PROCESS_PIO] = usbf_ep0_recv,
+	.send[USBF_PROCESS_PIO] = usbf_ep0_send,
+	.interrupt = usbf_ep0_interrupt,
+	.reset = usbf_ep0_reset,
+};
+
+int usbf_ep0_init(struct f_endpoint *ep)
+{
+	struct f_regs_ep0 *ep_reg = &ep->chip->regs->ep0;
+
+	ep->drv = &usbf_ep0_callbacks;
+	ep->ep.maxpacket = CFG_EP0_MAX_PACKET_SIZE;
+	strcat(ep->name, "-control");
+
+	usbf_ep0_flush_buffer(ep_reg, D_EP0_OUT_EMPTY | D_EP0_IN_EMPTY);
+
+	return 0;
+}
diff --git a/drivers/usb/gadget/udc/usbf-renesas-epn.c b/drivers/usb/gadget/udc/usbf-renesas-epn.c
new file mode 100644
index 0000000..e5c6bc5
--- /dev/null
+++ b/drivers/usb/gadget/udc/usbf-renesas-epn.c
@@ -0,0 +1,449 @@
+/*
+ * Renesas RZ/N1 USB Device usb gadget driver
+ *
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ * Author: Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include "usbf-renesas.h"
+
+/*
+ * TODO TODO TODO
+ *
+ * Currently, if the 'packet size' of the descriptor is used to configure
+ * the dma/sram for the endpoints, it works well for when the device starts at
+ * full speed. However, if the gadget starts at high speed, the memory allocated
+ * won't be enough if the link is then renegotiated  to full speed.
+ * We need a bit of heuristics at enable time to know if we ought to allocate
+ * more, or if we can use the descriptor values.
+ */
+/* Example of memory configuration with 5024 * 32 bits words
+ * 5024 * 32 bits = 20096 bytes of device memory
+	ep1-bulk	2 * 512		1024
+	ep2-bulk	2 * 512		1024
+	ep3-bulk	2 * 512		1024
+	ep4-bulk	2 * 512		1024
+	ep5-bulk	2 * 512		1024	   5120
+	ep6-int		2 * 64		128	- No DMA
+	ep7-int		2 * 64		128
+	ep8-int		2 * 64		128
+	ep9-int		2 * 64		128	+   512
+	ep10-iso	2 * 1024	2048
+	ep11-iso	2 * 1024	2048
+	ep12-iso	2 * 1024	2048
+	ep13-iso	2 * 1024	2048
+	ep14-iso	2 * 1024	2048
+	ep15-iso	2 * 1024	2048	+ 12288
+						= 17920
+ */
+static int usbf_epn_enable(
+	struct f_endpoint *ep)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep *ep_reg = ep->reg;
+	int in = usb_endpoint_dir_in(ep->desc);
+
+	/* Get the number of packets from EP config, CHIP config, or default */
+	if (!ep->max_nr_pkts)
+		ep->max_nr_pkts = chip->dma_pkt_count[ep->type];
+	if (!ep->max_nr_pkts)
+		ep->max_nr_pkts = 2;
+
+	TRACEEP(ep, "%s[%d] %s maxpackets %d/%d\n", __func__, ep->id,
+		in ? "IN" : "OUT", ep->ep.maxpacket, ep->ep.maxpacket_limit);
+
+	/* Set the internal IP base address, and increment the pointer with
+	 * the number of packets we plan to keep for that endpoint
+	 * Note: We do this even if this endpoint is 'no dma' as it will still
+	 * need some memory to function; this is the case for the interrupt
+	 * endpoints
+	 */
+	writel((ep->chip->dma_ram_used << 16) | usb_endpoint_maxp(ep->desc),
+		&ep_reg->pckt_adrs);
+	ep->chip->dma_ram_used +=
+		(ep->max_nr_pkts * usb_endpoint_maxp(ep->desc)) / 4;
+	/* Warn if we go overboard */
+	if (chip->dma_ram_size &&
+			ep->chip->dma_ram_used > chip->dma_ram_size) {
+		dev_warn(chip->dev, "EP[%d] SRAM overflow (%d/%d)!\n",
+			ep->id, chip->dma_ram_used, chip->dma_ram_size);
+	}
+	TRACE("%s[%d] packets %d*%d pckt_adrs %08x\n",
+		__func__, ep->id,
+		ep->max_nr_pkts, usb_endpoint_maxp(ep->desc),
+		readl(&ep_reg->pckt_adrs));
+
+	writel(in ?	0 :
+			D_EPN_OUT_EN | D_EPN_OUT_END_EN,
+		&ep_reg->int_enable);
+	/* Clear, set endpoint direction, and enable */
+	writel(D_EPN_EN | D_EPN_BCLR | (in ? 0 : D_EPN_DIR0), &ep_reg->control);
+	return 0;
+}
+
+static void usbf_epn_disable(
+	struct f_endpoint *ep)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+
+	TRACEEP(ep, "%s[%d]\n", __func__, ep->id);
+
+	/* Disable endpoint */
+	writel(readl(&ep_reg->control) & ~D_EPN_EN, &ep_reg->control);
+}
+
+static void usbf_epn_reset(
+	struct f_endpoint *ep)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+
+	writel(readl(&ep_reg->control) | D_EPN_BCLR, &ep_reg->control);
+}
+
+static int usbf_epn_send1(
+	struct f_endpoint *ep,
+	uint32_t *src,
+	int reqlen)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+	uint32_t control;
+	int w, len, err;
+	uint32_t val;
+	int pkt_words = reqlen / sizeof(*src);
+
+	/* Wait until there is space to write the pkt */
+	err = readl_poll_timeout(&ep_reg->status, val, (val & D_EPN_IN_EMPTY),
+			0, 10000);
+	if (err)
+		return -ETIMEDOUT;
+
+	/* Note, we don't care about endianness here, as the IP
+	 * and the core will have the same layout anyway, so we
+	 * can happily ignore it */
+	for (w = 0; w < pkt_words; w++)
+		writel(*src++, &ep_reg->write);
+
+	control = readl(&ep_reg->control);
+
+	/* if we have stray bytes, write them off too, and mark the
+	 * control registers so it knows only 1,2,3 bytes are valid in
+	 * the last write we made */
+	len = reqlen & (sizeof(*src) - 1);
+	if (len) {
+		writel(*src, &ep_reg->write);
+		control |= (len << 5);
+	}
+
+	writel(control | D_EPN_DEND, &ep_reg->control);
+
+	return 0;
+}
+
+static int usbf_epn_send(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+
+	/* Special handling for internally generated NULL packets */
+	if (!req) {
+		writel(readl(&ep_reg->control) | D_EPN_DEND, &ep_reg->control);
+		return 0;
+	}
+
+	if (req->req.length) {
+		void *src = req->req.buf;
+		int bytes = req->req.length;
+		int maxpkt_bytes = ep->ep.maxpacket;
+		int ret;
+
+		while (bytes > 0) {
+			int pkt_bytes = min(bytes, maxpkt_bytes);
+
+			ret = usbf_epn_send1(ep, src, pkt_bytes);
+			if (ret < 0) {
+				req->req.status = ret;
+				return ret;
+			}
+
+			bytes -= pkt_bytes;
+			src += pkt_bytes;
+		}
+		req->req.actual = req->req.length;
+		req->req.status = 0;
+	}
+
+	/* UDC asking for a ZLP to follow? */
+	if (req->req.length == 0 || req->req.zero)
+		req->req.status = usbf_epn_send1(ep, NULL, 0);
+
+	TRACERQ(req, "%s[%d][%3d] sent %d\n", __func__,
+		ep->id, req->seq, req->req.length);
+
+	return req->req.status;
+}
+
+static int usbf_epn_pio_recv(
+	struct f_endpoint *ep,
+	struct f_req *req,
+	uint32_t reqlen)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+
+	uint32_t *buf = req->req.buf + req->req.actual;
+	int len = (reqlen + sizeof(*buf) - 1) /  sizeof(*buf);
+
+	TRACERQ(req, "%s[%d][%3d] size %d (%d/%d)\n", __func__,
+		ep->id, req->seq, len,
+	      req->req.actual, req->req.length);
+
+	while (len-- > 0)
+		*buf++ = readl(&ep_reg->read);
+
+	req->req.actual += reqlen;
+
+	/* If we get a whole packet, we don't know if its the end of the
+	 * request yet. If it was everything, then we will get a null packet
+	 * as well.
+	 */
+	if (reqlen != usb_endpoint_maxp(ep->desc))
+		req->req.status = 0;
+
+	return req->req.status;
+}
+
+/* This is called from the tasklet to determine if we have received data.
+ * All of the processing is interrupt driven, so this function simply returns
+ * the status of the request.
+ */
+static int usbf_epn_recv(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	return req->req.status;
+}
+
+/*
+ * This setups a DMA transfer for both directions, to and from the device.
+ */
+static int usbf_epn_dma(
+	struct f_endpoint *ep,
+	struct f_req *req,
+	uint32_t size)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+	struct f_regs_epdma *dma = &ep->chip->regs->epdma[ep->id];
+	uint32_t max_size = usb_endpoint_maxp(ep->desc);
+	uint32_t pkt_count;
+	uint32_t last_size;
+	uint32_t control = 0;
+
+	/* Should not be necessary here, but lets be paranoid */
+	writel(D_EPN_STOP_MODE | D_EPN_STOP_SET | D_EPN_DMAMODE0, &ep_reg->dma_ctrl);
+
+	/* Ensure DMA is not trying to handle any odd bytes */
+	size &= ~3;
+
+	/* trim the size to max packets worth of stuff */
+	if (size > CFG_EPX_MAX_PACKET_CNT * max_size)
+		size = CFG_EPX_MAX_PACKET_CNT * max_size;
+
+	pkt_count = (size + max_size - 1) / max_size;
+	last_size = size % max_size;
+
+	/* keep it around for the usbf_epn_dma_complete() function sake */
+	req->dma_pkt_count = pkt_count - 1;
+
+	TRACERQ(req, "%s[%d][%3d] %d/%d size %d - pkt %d size %d last_size %d = %d\n",
+		__func__, ep->id, req->seq,
+		req->req.actual, req->req.length, size,
+		(pkt_count - 1), max_size, last_size,
+		((pkt_count - 1) * max_size) + last_size);
+
+	writel(pkt_count << 16, &ep_reg->len_dcnt);
+	/* set address, offset by what was already transferred */
+	writel(req->req.dma + req->req.actual, &dma->epntadr);
+	/* Packet size + last packet size */
+	writel((last_size << 16) | max_size, &dma->epndcr2);
+	/* Number of packet again, enable + direction flag */
+	/* Always needs to be > 0 here, if not in burst mode */
+	writel((((pkt_count ? pkt_count : 1) & 0xff) << 16) |
+		D_SYS_EPN_REQEN |
+		(req->to_host ? 0 : D_SYS_EPN_DIR0),
+		&dma->epndcr1);
+
+	/* Mark it so we don't try to restart a transfer */
+	req->req.status = -EBUSY;
+	control = D_EPN_DMA_EN | D_EPN_STOP_MODE | D_EPN_STOP_SET | D_EPN_DMAMODE0;
+	if (pkt_count > 1 && last_size == 0)
+		control |= D_EPN_BURST_SET;
+	/* If we are sending, and are either sending a full packet or sending
+	 * the exact remaining of the request using the DMA (no unaligned
+	 * length) then we set the DEND flag so the DMA end will also send the
+	 * packet.
+	 */
+	if (req->to_host) {
+		if (last_size == max_size ||
+			req->req.actual + size == req->req.length)
+				control |= D_EPN_DEND_SET;
+	}
+	/* Start it... */
+	writel(control, &ep_reg->dma_ctrl);
+
+	return -EBUSY;
+}
+
+/* Handle DMA rx complete (OUT_END) interrupt */
+static void usbf_epn_out_end_isr(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_regs_ep *ep_reg = ep->reg;
+	struct f_regs_epdma *dma = &ep->chip->regs->epdma[ep->id];
+
+	uint32_t reqlen = readl(&ep_reg->len_dcnt) & D_EPN_LDATA;
+	/* number of packets has been decremented from the dma_pkt_count */
+	uint32_t pkts_left = (readl(&dma->epndcr1) >> 16) & 0xff;
+	uint32_t pkts_got = 0;
+
+	/* Clear REQEN, i.e. disable DMA */
+	writel((req->to_host ? 0 : D_SYS_EPN_DIR0), &dma->epndcr1);
+
+	/* The number of packets received is the difference between what we
+	 * asked for and the uncompleted packets. */
+	if (req->dma_pkt_count)
+		pkts_got = req->dma_pkt_count - pkts_left + 1;
+
+	/* Update amount transferred */
+	/* The burst and non-burst method have the same behaviour
+	 * regarding the calculation of what has been transferred */
+	req->req.actual += pkts_got * usb_endpoint_maxp(ep->desc);
+	req->req.actual += req->dma_non_burst_bytes;
+
+	TRACERQ(req, "%s[%d][%3d] reqlen %d pkts_sent %d actual %d/%d\n",
+		__func__, ep->id, req->seq,
+		reqlen, pkts_got,
+		req->req.actual, req->req.length);
+
+	/* DMA it! */
+	if (reqlen >= 4) {
+		usbf_epn_dma(ep, req, reqlen);
+		req->dma_non_burst_bytes = reqlen & ~3;
+		return;
+	}
+
+	usbf_epn_pio_recv(ep, req, reqlen);
+}
+
+/* Handle rx data received (OUT) interrupt */
+/* The hardware has captured a USB packet in it's internal RAM and we need to
+ * use PIO or start DMA to move it out. The OUT_END interrupt tells us when the
+ * DMA of one USB packet has finished, and so is used to start subsequent DMA
+ * transfers for this request. */
+static void usbf_epn_out_isr(
+	struct f_endpoint *ep,
+	struct f_req *req)
+{
+	struct f_drv *chip = ep->chip;
+	struct f_regs_ep *ep_reg = ep->reg;
+	struct f_regs_epdma *dma = &ep->chip->regs->epdma[ep->id];
+
+	uint32_t reqlen = readl(&ep_reg->len_dcnt) & D_EPN_LDATA;
+
+	/* if a DMA is in progress, ignore this interrupt */
+	if (readl(&dma->epndcr1) & D_SYS_EPN_REQEN)
+		return;
+
+	/* If it's not a short packet, we want to do a burst DMA so
+	 * increase the request length to the max we want.
+	 * Otherwise, a short packet tells us the total we will get */
+	if (reqlen == usb_endpoint_maxp(ep->desc)) {
+		reqlen = req->req.length - req->req.actual;
+		req->dma_non_burst_bytes = 0;
+	} else
+		req->dma_non_burst_bytes = reqlen & ~3;
+
+	TRACERQ(req, "%s[%d][%3d] reqlen %d actual %d/%d\n",
+		__func__, ep->id, req->seq,
+		reqlen, req->req.actual, req->req.length);
+
+	/* DMA it! */
+	if (req->use_dma && reqlen >= chip->dma_threshold) {
+		usbf_epn_dma(ep, req, reqlen);
+		return;
+	}
+
+	/* If using PIO, we only recieve one USB packet at a time */
+	if (reqlen > usb_endpoint_maxp(ep->desc))
+		reqlen = usb_endpoint_maxp(ep->desc);
+
+	usbf_epn_pio_recv(ep, req, reqlen);
+}
+
+static void usbf_epn_interrupt(struct f_endpoint *ep)
+{
+	struct f_req *req;
+
+	spin_lock_irq(&ep->lock);
+	req = list_first_entry_or_null(&ep->queue, struct f_req, queue);
+	spin_unlock_irq(&ep->lock);
+
+	/* Ensure we have a request, and that we have work to do on it */
+	if (!req || req->req.status == 0)
+		return;
+
+	/* Note: D_EPN_OUT_INT must be before D_EPN_OUT_END_INT.
+	 * Since we get OUT interrupts during DMA, we can pick up both OUT and
+	 * OUT_END interrupt at the same time. If we handle the OUT_END first
+	 * (and disable DMA), the OUT will look like a spurious interrupt.
+	 * By calling usbf_ep_process_queue() here, we make this EP return data
+	 * to other parts of the kernel quicker. This seems to be important...
+	 */
+	if (ep->status & D_EPN_OUT_END_INT) {
+		ep->status &= ~D_EPN_OUT_END_INT;
+		usbf_epn_out_end_isr(ep, req);
+	} else if (ep->status & D_EPN_OUT_INT) {
+		ep->status &= ~D_EPN_OUT_INT;
+		usbf_epn_out_isr(ep, req);
+	} else if (ep->status & D_EPN_IN_INT) {
+		/* EPN_IN_INT means we have finished tx so we just want to poke the
+		 * queue to ensure any pending requests are processed */
+		ep->status &= ~D_EPN_IN_INT;
+	}
+
+	usbf_ep_process_queue(ep);
+}
+
+static const struct f_endpoint_drv usbf_epn_callbacks = {
+	.enable = usbf_epn_enable,
+	.disable = usbf_epn_disable,
+	/* .set_maxpacket = usbf_epn_set_maxpacket, */
+	.recv[USBF_PROCESS_PIO] = usbf_epn_recv,
+	.send[USBF_PROCESS_PIO] = usbf_epn_send,
+	.recv[USBF_PROCESS_DMA] = usbf_epn_recv,
+	.interrupt = usbf_epn_interrupt,
+	.reset = usbf_epn_reset,
+};
+
+int usbf_epn_init(struct f_endpoint *ep)
+{
+	struct f_regs_ep *ep_reg = &ep->chip->regs->ep[ep->id - 1];
+	static const char * const et[] = {
+		[USBF_EP_BULK] = "-bulk",
+		[USBF_EP_INT] = "-int",
+		[USBF_EP_ISO] = "-iso"
+	};
+
+	ep->reg = ep_reg;
+	ep->type = (readl(&ep_reg->control) >> 24) & 3;
+	ep->drv = &usbf_epn_callbacks;
+	strcat(ep->name, et[ep->type]);
+
+	return 0;
+}
diff --git a/drivers/usb/gadget/udc/usbf-renesas.c b/drivers/usb/gadget/udc/usbf-renesas.c
new file mode 100644
index 0000000..c1b76cc
--- /dev/null
+++ b/drivers/usb/gadget/udc/usbf-renesas.c
@@ -0,0 +1,1114 @@
+/*
+ * Renesas RZ/N1 USB Device usb gadget driver
+ *
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ * Author: Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/sysctrl-rzn1.h>
+
+#include "usbf-renesas.h"
+
+#ifdef	CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif
+
+#define DRIVER_DESC     "Renesas USB Function driver"
+#define DRIVER_AUTHOR   "Michel Pollet"
+#define DRIVER_VERSION  "0.2"
+
+#define DMA_ADDR_INVALID        (~(dma_addr_t)0)
+
+static const char driver_name[] = "usbf_renesas";
+static const char driver_desc[] = DRIVER_DESC;
+
+#ifdef	CONFIG_DEBUG_FS
+struct f_drv *usbf;
+#endif
+
+static struct usb_endpoint_descriptor ep0_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_CONTROL,
+	.wMaxPacketSize = CFG_EP0_MAX_PACKET_SIZE,
+};
+
+/*
+ * activate/deactivate link with host.
+ */
+static void pullup(struct f_drv *chip, int is_on)
+{
+	struct f_regs *regs = chip->regs;
+
+	if (is_on) {
+		if (!chip->pullup) {
+			chip->pullup = 1;
+			writel((readl(&regs->control) & ~D_USB_CONNECTB) |
+				D_USB_PUE2, &regs->control);
+			usb_gadget_set_state(&chip->gadget, USB_STATE_POWERED);
+		}
+	} else {
+		chip->pullup = 0;
+		writel((readl(&regs->control) & ~D_USB_PUE2) |
+			D_USB_CONNECTB, &regs->control);
+		usb_gadget_set_state(&chip->gadget, USB_STATE_NOTATTACHED);
+	}
+}
+
+/*
+ * USB Gadget Layer
+ */
+static int usbf_ep_enable(
+	struct usb_ep *_ep,
+	const struct usb_endpoint_descriptor *desc)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_drv *chip = ep->chip;
+	struct f_regs *regs = chip->regs;
+	unsigned long flags;
+
+	TRACE("%s[%d] desctype %d max pktsize %d\n", __func__, ep->id,
+	      desc->bDescriptorType,
+	      usb_endpoint_maxp(desc));
+	if (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {
+		TRACE("%s: bad ep or descriptor\n", __func__);
+		return -EINVAL;
+	}
+
+	/* it might appear as we nuke the const here, but in this case,
+	 * we just need the ep0 to be able to change the endpoint direction,
+	 * and we know it does that on a non-const copy of its descriptor,
+	 * while the other endpoints don't touch it anyway */
+	ep->desc = (struct usb_endpoint_descriptor *)desc;
+	ep->ep.maxpacket = usb_endpoint_maxp(desc);
+
+	if (ep->drv->enable)
+		ep->drv->enable(ep);
+	if (ep->drv->set_maxpacket)
+		ep->drv->set_maxpacket(ep);
+	ep->disabled = 0;
+
+	/* enable interrupts for this endpoint */
+	spin_lock_irqsave(&chip->lock, flags);
+	writel(readl(&regs->int_enable) | (D_USB_EP0_EN << ep->id),
+	       &regs->int_enable);
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int usbf_ep_disable(struct usb_ep *_ep)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_drv *chip = ep->chip;
+	struct f_regs *regs = chip->regs;
+	unsigned long flags;
+
+	TRACE("%s(%d)\n", __func__, ep->id);
+
+	/* disable interrupts for this endpoint */
+	spin_lock_irqsave(&chip->lock, flags);
+	writel(readl(&regs->int_enable) & ~(D_USB_EP0_EN << ep->id),
+	       &regs->int_enable);
+	spin_unlock_irqrestore(&chip->lock, flags);
+	if (ep->drv->disable)
+		ep->drv->disable(ep);
+	ep->desc = NULL;
+	ep->disabled = 1;
+	return 0;
+}
+
+static struct usb_request *usbf_ep_alloc_request(
+	struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct f_req *req = kzalloc(sizeof(*req), gfp_flags);
+
+	if (!req)
+		return NULL;
+
+	req->req.dma = DMA_ADDR_INVALID;
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void usbf_ep_free_request(
+	struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct f_req *req = container_of(_req, struct f_req, req);
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+
+	spin_lock_irq(&ep->lock);
+	list_del_init(&req->queue);
+	spin_unlock_irq(&ep->lock);
+	kfree(req);
+}
+
+static int usbf_ep_queue(
+	struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_drv *chip = ep->chip;
+	struct f_req *req = container_of(_req, struct f_req, req);
+	int was_empty = list_empty(&ep->queue);
+
+	if (!_req || !_req->buf) {
+		TRACE("%s: invalid request to ep%d\n", __func__, ep->id);
+		return -EINVAL;
+	}
+
+	if (!chip || chip->state == USB_STATE_SUSPENDED) {
+		TRACE("%s: request while chip suspended\n", __func__);
+		return -EINVAL;
+	}
+	req->trace = 0;
+	req->req.actual = 0;
+	req->req.status = -EINPROGRESS;
+	req->seq = ep->seq++; /* debug */
+	req->to_host = usb_endpoint_dir_in(ep->desc);
+	/* Basic criteria for using DMA on this request */
+	req->use_dma = ep->has_dma && ep->id != 0 &&
+			req->req.length > chip->dma_threshold;
+
+	/* DISABLE DMA */
+	req->use_dma = 0;
+
+	/* This technically is a kludge, we test the pointer /before/ we
+	 * bother to DMA map it and 'discover' it's also been mapped to an
+	 * unaligned address. In testing, the lower part of the pointers
+	 * stay the same anyway, so testing before we map is valid. */
+	if (req->use_dma && ((u32)req->req.buf & 3)) {
+		req->use_dma = 0;
+		TRACEEP(ep, "%s[%d][%3d] WARNING unaligned buffer at %p -- DMA Disabled\n",
+			__func__, ep->id, req->seq, req->req.buf);
+	}
+
+	/* The endpoint driver has 2 types of transfer callbacks, one for
+	 * receiving and one for sending; we know at 'queue' time the direction
+	 * the endpoint is, so we can install the correct one with the request
+	 * and let it do the job until completion */
+
+	/* if DMA callback is not present, fallback to PIO */
+	if (req->to_host) {
+		if (req->use_dma && !ep->drv->send[USBF_PROCESS_DMA])
+			req->use_dma = 0;
+		req->process = ep->drv->send[req->use_dma];
+	} else {
+		if (req->use_dma && !ep->drv->recv[USBF_PROCESS_DMA])
+			req->use_dma = 0;
+		req->process = ep->drv->recv[req->use_dma];
+	}
+	/* Prepare the buffer for DMA, if necessary */
+	if (req->use_dma) {
+		if (req->req.dma == DMA_ADDR_INVALID) {
+			if (usb_gadget_map_request(&chip->gadget, &req->req,
+						req->to_host)) {
+				pr_err("dma_mapping_error\n");
+				req->req.dma = DMA_ADDR_INVALID;
+				req->use_dma = 0;
+			} else
+				req->mapped = 1;
+		}
+	}
+
+	TRACEEP(ep, "%s[%d][%3d], dma:%d mapped:%d len %3d %s %s\n", __func__,
+		ep->id, req->seq, req->use_dma, req->mapped,
+		req->req.length,
+		req->to_host ? "input" : "output",
+		req->req.zero ? "ZERO" : "(no zero)");
+	if (req->use_dma) /* DMA is still possible */
+		dma_sync_single_for_device(
+			chip->dev,
+			req->req.dma, req->req.length,
+			req->to_host ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	/* This is /required/ -- you cannot queue these requests, because
+	 * the upper layer doesn't assume they will be queued and will call
+	 * queue() again with the same request, polluting the list; so we
+	 * need to complete() it now, even tho it might actually be out of
+	 * sequence (if a packet is already in the queue */
+	if (req->req.length == 0) {
+		req->req.status = 0;
+		usb_gadget_giveback_request(&ep->ep, &req->req);
+		return 0;
+	}
+
+	spin_lock_irq(&ep->lock);
+	list_add_tail(&req->queue, &ep->queue);
+	spin_unlock_irq(&ep->lock);
+
+	/* kick a soft interrupt, in case we are not called from the tasklet */
+	if (req->to_host || was_empty)
+		tasklet_schedule(&chip->tasklet);
+
+	return 0;
+}
+
+static int usbf_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	struct f_req *req = container_of(_req, struct f_req, req);
+	struct f_drv *chip = ep->chip;
+
+	/* dequeue the request */
+	spin_lock_irq(&ep->lock);
+	list_del_init(&req->queue);
+	spin_unlock_irq(&ep->lock);
+
+	if (req->use_dma) {
+		req->use_dma = 0;
+		dma_sync_single_for_cpu(
+			chip->dev,
+			req->req.dma, req->req.length,
+			req->to_host ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	}
+	TRACEEP(ep, "%s[%d][%3d] size %d\n", __func__,
+			ep->id, req->seq, req->req.actual);
+
+	if (req->trace ||
+		(ep->trace_min && req->req.actual >= ep->trace_min &&
+		(ep->trace_max == 0 || req->req.actual <= ep->trace_max))) {
+		req->trace = 1;
+		TRACERQ(req, "%s[%d][%3d] DUMP %d buf:%p dma %08x:\n",
+			__func__, ep->id, req->seq, req->req.actual,
+			req->req.buf, req->req.dma);
+	//	print_hex_dump_bytes("pkt", DUMP_PREFIX_OFFSET,
+	//		req->req.buf, req->req.actual);
+	}
+	if (req->mapped) {
+		usb_gadget_unmap_request(&chip->gadget, &req->req,
+				req->to_host);
+		/* ^^ doesn't do this:  */
+		req->req.dma = DMA_ADDR_INVALID;
+		req->mapped = 0;
+	}
+
+	/* don't modify queue heads during completion callback */
+	if (chip->gadget.speed == USB_SPEED_UNKNOWN)
+		req->req.status = -ESHUTDOWN;
+
+	if (req->req.complete)
+		usb_gadget_giveback_request(&ep->ep, &req->req);
+
+	return 0;
+}
+
+/*
+ * This function is called repeatedly on each endpoint. Its job is to
+ * 'process' the current queued request (top of the queue) and 'complete'
+ * it when it's finished.
+ */
+int usbf_ep_process_queue(struct f_endpoint *ep)
+{
+	struct f_req *req;
+
+	spin_lock_irq(&ep->lock);
+	req = list_first_entry_or_null(&ep->queue, struct f_req, queue);
+	spin_unlock_irq(&ep->lock);
+
+	if (req && req->process(ep, req) == 0) {
+		/* 'complete' this request */
+		usbf_ep_dequeue(&ep->ep, &req->req);
+
+		/* If there are further requests, reschedule the tasklet */
+		spin_lock_irq(&ep->lock);
+		req = list_first_entry_or_null(&ep->queue, struct f_req, queue);
+		spin_unlock_irq(&ep->lock);
+		if (req)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int usbf_ep_halt(struct usb_ep *_ep, int halt)
+{
+	struct f_endpoint *ep = container_of(_ep, struct f_endpoint, ep);
+	int ret = 0;
+
+	TRACEEP(ep, "%s[%d] halt=%d\n", __func__, ep->id, halt);
+	if (ep->drv->halt)
+		ret = ep->drv->halt(ep, halt);
+	return ret;
+}
+
+static void usbf_ep_reset(
+	struct f_endpoint *ep)
+{
+	TRACEEP(ep, "%s[%d] reset\n", __func__, ep->id);
+	if (ep->drv->reset)
+		ep->drv->reset(ep);
+	ep->status = 0;
+	/* flush anything that was pending */
+	while (!list_empty(&ep->queue)) {
+		struct f_req *req = list_first_entry(&ep->queue,
+					struct f_req, queue);
+		TRACEEP(ep, "%s[%d][%3d] dequeueing\n", __func__,
+			ep->id, req->seq);
+		req->req.status = -ECONNRESET;
+		usbf_ep_dequeue(&ep->ep, &req->req);
+	}
+}
+
+static struct usb_ep_ops usbf_ep_ops = {
+	.enable         = usbf_ep_enable,
+	.disable        = usbf_ep_disable,
+	.queue          = usbf_ep_queue,
+	.dequeue        = usbf_ep_dequeue,
+	.set_halt       = usbf_ep_halt,
+	.alloc_request  = usbf_ep_alloc_request,
+	.free_request   = usbf_ep_free_request,
+};
+
+/* If there's stuff in the fifo, collect it */
+static uint32_t usbf_tasklet_flush_fifo(
+	struct f_drv *chip)
+{
+	struct f_status s;
+	int i;
+	uint32_t int_status = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	/* If multiple sets of interrupt status bits have been pushed onto the
+	 * FIFO, or them together to get a complete set.
+	 */
+	if (kfifo_get(&chip->fifo, &s)) {
+		/* Mask out the global EP interrupt bits */
+		int_status = s.int_status & 0xf;
+		for (i = 0; i < CFG_NUM_ENDPOINTS; i++) {
+			chip->ep[i].status = s.ep[i];
+			/* Fake the global EP interrupt bits based on what we read */
+			if (s.ep[i])
+				int_status |= (D_USB_EP0_INT << i);
+		}
+	}
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return int_status;
+}
+
+static void usbf_tasklet_process_irq(struct f_drv *chip, uint32_t int_status)
+{
+	int i;
+
+	if (int_status & D_USB_USB_RST_INT) {
+		if (chip->gadget.speed != USB_SPEED_UNKNOWN) {
+			TRACE("%s disconnecting\n", __func__);
+			chip->gadget.speed = USB_SPEED_UNKNOWN;
+			/* We assume all endpoints will be closed,
+			 * so reset the DMA memory pointer for later use */
+			chip->dma_ram_used = EP0_RAM_USED;
+			if (chip->driver)
+				chip->driver->disconnect(&chip->gadget);
+			else
+				dev_warn(chip->dev, "Spurious RST\n");
+		}
+	}
+	if (int_status & D_USB_SPEED_MODE_INT) {
+		if (readl(&chip->regs->status) & D_USB_SPEED_MODE)
+			chip->gadget.speed = USB_SPEED_HIGH;
+		else
+			chip->gadget.speed = USB_SPEED_FULL;
+		TRACE("**** %s speed change: %s\n", __func__,
+			chip->gadget.speed == USB_SPEED_HIGH ? "High" : "Full");
+	}
+#if 0
+	if (int_status & D_USB_SPND_INT)
+		TRACE("%s suspend clear\n", __func__);
+	if (int_status & D_USB_RSUM_INT)
+		TRACE("%s resume\n", __func__);
+#endif
+	for (i = 0; i < CFG_NUM_ENDPOINTS; i++) {
+		struct f_endpoint *ep = &chip->ep[i];
+
+		if (ep->disabled)
+			continue;
+
+		if (int_status & D_USB_USB_RST_INT)
+			usbf_ep_reset(ep);
+		/* speed change notification for endpoints */
+		if ((int_status & D_USB_SPEED_MODE_INT) &&
+				ep->drv->set_maxpacket)
+			ep->drv->set_maxpacket(ep);
+
+		/* Interrupt notification */
+		if ((int_status & (D_USB_EP0_INT << i)) && ep->drv->interrupt)
+			ep->drv->interrupt(ep);
+	}
+}
+
+static void usbf_tasklet(unsigned long data)
+{
+	struct f_drv *chip = (struct f_drv *)data;
+	uint32_t int_status;
+	int i, busy = 1;
+
+	while ((int_status = usbf_tasklet_flush_fifo(chip)) != 0)
+		usbf_tasklet_process_irq(chip, int_status);
+
+	while (busy) {
+		busy = 0;
+
+		for (i = 0; i < CFG_NUM_ENDPOINTS; i++) {
+			struct f_endpoint *ep = &chip->ep[i];
+
+			if (!ep->disabled)
+				busy |= usbf_ep_process_queue(ep);
+		}
+	}
+}
+
+static void usbf_attach(struct f_drv *chip)
+{
+	struct f_regs *regs = chip->regs;
+	uint32_t ctrl = readl(&regs->control);
+
+	/* Enable USB signal to Function PHY */
+	ctrl &= ~D_USB_CONNECTB;
+	/* D+ signal Pull-up */
+	ctrl |=  D_USB_PUE2;
+	/* Enable endpoint 0 */
+	ctrl |=  D_USB_DEFAULT;
+
+	writel(ctrl, &regs->control);
+}
+
+static void usbf_detach(struct f_drv *chip)
+{
+	struct f_regs *regs = chip->regs;
+	uint32_t ctrl = readl(&regs->control);
+
+	/* Disable USB signal to Function PHY */
+	ctrl |=  D_USB_CONNECTB;
+	/* Do not Pull-up D+ signal */
+	ctrl &= ~D_USB_PUE2;
+	/* Disable endpoint 0 */
+	ctrl &= ~D_USB_DEFAULT;
+	/* Disable the other endpoints */
+	ctrl &= ~D_USB_CONF;
+
+	writel(ctrl, &regs->control);
+
+	writel(0, &regs->ep0.status);
+}
+
+static irqreturn_t usbf_irq(int irq, void *_chip)
+{
+	struct f_drv *chip = (struct f_drv *)_chip;
+	struct f_regs *regs = chip->regs;
+	uint32_t sysbint = readl(&regs->sysbint);
+
+	/* clear interrupts */
+	writel(sysbint, &regs->sysbint);
+	if ((sysbint & D_SYS_VBUS_INT) == D_SYS_VBUS_INT) {
+		/* Interrupt factor clear */
+		if (readl(&regs->epctr) & D_SYS_VBUS_LEVEL) {
+			TRACE("%s plugged in\n", __func__);
+			usbf_attach(chip);
+			usb_gadget_set_state(&chip->gadget, USB_STATE_POWERED);
+		} else {
+			TRACE("%s plugged out\n", __func__);
+			usbf_detach(chip);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Offload the IRQ flags into the FIFO ASAP, then return.
+ *
+ * The status flags are passed down to tasklet via a FIFO
+ */
+static irqreturn_t usbf_epc_irq(int irq, void *_chip)
+{
+	struct f_drv *chip = (struct f_drv *)_chip;
+	struct f_regs *regs = chip->regs;
+	struct f_status s;
+	int i;
+	u32 int_en;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	/* Disable interrupts */
+	int_en = readl(&regs->int_enable);
+	writel(0, &regs->int_enable);
+
+	/*
+	 * WARNING: Don't use the EP interrupt bits from this status reg as they
+	 * won't be coherent with the EP status registers.
+	 */
+	s.int_status = readl(&regs->int_status) & int_en;
+	writel(~s.int_status, &regs->int_status);
+
+	s.ep[0] = readl(&regs->ep0.status) & readl(&regs->ep0.int_enable);
+	writel(~s.ep[0], &regs->ep0.status);
+
+	for (i = 1; i < CFG_NUM_ENDPOINTS; i++) {
+		s.ep[i] = readl(&regs->ep[i - 1].status) & readl(&regs->ep[i - 1].int_enable);
+		writel(~s.ep[i], &regs->ep[i - 1].status);
+	}
+
+	if (!kfifo_put(&chip->fifo, s))
+		dev_err(chip->dev, "intstatus fifo full!\n");
+
+	/* Enable interrupts */
+	writel(int_en, &regs->int_enable);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	tasklet_schedule(&chip->tasklet);
+
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------
+	Gadget driver probe and unregister.
+ --------------------------------------------------------------------------*/
+static int usbf_gadget_start(struct usb_gadget *gadget,
+		struct usb_gadget_driver *driver)
+{
+	struct f_drv *chip = container_of(gadget, struct f_drv, gadget);
+	struct device_node *np = chip->dev->of_node;
+
+	driver->driver.bus = NULL;
+	/* hook up the driver */
+	chip->driver = driver;
+	chip->gadget.speed = driver->max_speed;
+
+	dev_info(chip->dev, "%s bind to driver %s\n", chip->gadget.name,
+			driver->driver.name);
+	/* Finish initialization by getting possible overrides from DT */
+	if (np) {
+		int rm_len, i, pi;
+		const char * const names[] = {
+			[0] = kasprintf(GFP_KERNEL, "renesas,sram-conf,%s",
+				driver->driver.name),
+			[1] = "renesas,sram-conf",
+		};
+
+		/* reset all packet counts to default (2) */
+		for (pi = 0; pi < ARRAY_SIZE(names); pi++)
+			chip->ep[pi].max_nr_pkts = 0;
+		for (pi = 0; pi < ARRAY_SIZE(chip->dma_pkt_count); pi++)
+			chip->dma_pkt_count[pi] = 0;
+
+		for (pi = 0; pi < ARRAY_SIZE(names); pi++) {
+			const __be32 *conf = of_get_property(np,
+							names[pi], &rm_len);
+			TRACE("%s %s: %s : %p\n", __func__, driver->function,
+				names[pi], conf);
+			if (!conf)
+				continue;
+			rm_len /= sizeof(conf[0]);
+			if (rm_len > 3) { /* per-endpoint config */
+				for (i = 0; i < rm_len &&
+						i < ARRAY_SIZE(chip->ep); i++)
+					if (!chip->ep[i].max_nr_pkts)
+						chip->ep[i].max_nr_pkts =
+							be32_to_cpu(conf[i]);
+			} else { /* per endpoint type config */
+				for (i = 0; i < rm_len; i++)
+					if (!chip->dma_pkt_count[i])
+						chip->dma_pkt_count[i] =
+							be32_to_cpu(conf[i]);
+			}
+		}
+		kfree(names[0]);
+	}
+
+	return 0;
+}
+
+static int usbf_gadget_stop(struct usb_gadget *gadget)
+{
+	struct f_drv *chip = container_of(gadget, struct f_drv, gadget);
+
+	chip->gadget.speed = USB_SPEED_UNKNOWN;
+
+	dev_info(chip->dev, "unregistered gadget driver '%s'\n",
+			chip->driver->driver.name);
+	chip->driver = NULL;
+	return 0;
+}
+
+static int usbf_gadget_pullup(struct usb_gadget *_gadget, int is_on)
+{
+	struct f_drv *chip = container_of(_gadget, struct f_drv, gadget);
+
+	TRACE("%s: pullup=%d\n", __func__, is_on);
+
+	pullup(chip, is_on);
+
+	return 0;
+}
+
+static struct usb_gadget_ops usbf_gadget_ops = {
+	.pullup = usbf_gadget_pullup,
+	.udc_start = usbf_gadget_start,
+	.udc_stop = usbf_gadget_stop,
+};
+
+/*-----------------------------------------------------------------------
+ *	UDC device Driver operation functions				*
+ *----------------------------------------------------------------------*/
+static void usbf_release(struct device *dev)
+{
+	struct f_drv *chip = container_of(dev, struct f_drv, gadget.dev);
+
+	TRACE("%s\n", __func__);
+	complete(chip->done);
+
+	kfree(chip);
+}
+
+static int usbf_probe(struct platform_device *ofdev)
+{
+	int ret = -ENOMEM, i;
+	struct f_drv *chip;
+	struct device_node *np = ofdev->dev.of_node;
+
+	if (rzn1_sysctrl_readl(RZN1_SYSCTRL_REG_CFG_USB) &
+			(1 << RZN1_SYSCTRL_REG_CFG_USB_H2MODE)) {
+		dev_warn(&ofdev->dev, "disabled in H2 (host) mode\n");
+		return -1;
+	}
+
+	chip = devm_kzalloc(&ofdev->dev, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+	chip->dev = &ofdev->dev;
+
+	chip->clk_fw = devm_clk_get(chip->dev, "axi");
+	if (IS_ERR(chip->clk_fw)) {
+		ret = PTR_ERR(chip->clk_fw);
+		goto clk_failed;
+	}
+	ret = clk_prepare_enable(chip->clk_fw);
+	if (ret) {
+		dev_err(chip->dev, "can not enable the clock\n");
+		goto clk_failed;
+	}
+
+	chip->regs = of_iomap(np, 0);
+	if (!chip->regs) {
+		dev_err(chip->dev, "unable to get register bank\n");
+		goto invalid_mapping;
+	}
+	if (!(readl(&chip->regs->usbssconf) & (1 << 16))) {
+		dev_err(chip->dev, "Invalid USBF configuration, bailing\n");
+		goto invalid_config;
+	}
+	chip->dma_threshold = 64;
+	chip->dma_ram_size = 5024;
+
+	chip->dma_ram_used = EP0_RAM_USED; /* after endpoint zero memory */
+
+	TRACE("%s USB Conf: %08x\n", __func__, readl(&chip->regs->usbssconf));
+
+	/* Resetting the PLL is handled via the clock driver as it has common
+	 * registers with USB Host */
+
+	spin_lock_init(&chip->lock);
+
+	/* modify in register gadget process */
+	chip->gadget.speed = USB_SPEED_FULL;
+	chip->gadget.max_speed = USB_SPEED_HIGH;
+	chip->gadget.ops = &usbf_gadget_ops;
+
+	/* name: Identifies the controller hardware type. */
+	chip->gadget.name = driver_name;
+	chip->gadget.dev.parent = &ofdev->dev;
+	/* gadget.ep0 is a pointer */
+	chip->gadget.ep0 = &chip->ep[0].ep;
+
+	INIT_LIST_HEAD(&chip->gadget.ep_list);
+	/* we have a canned request structure to allow sending packets
+	 * as reply to get_status requests */
+	INIT_LIST_HEAD(&chip->setup_reply.queue);
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint init = {
+			.ep = {
+				.ops = &usbf_ep_ops,
+				.maxpacket = CFG_EPX_MAX_PACKET_SIZE,
+			},
+			.id = i,
+			.disabled = 1,
+			.chip = chip,
+		};
+		struct f_endpoint *ep = chip->ep + i;
+
+		if (!(readl(&chip->regs->usbssconf) & (1 << (16 + i)))) {
+			TRACE("%s endpoint %d is not available\n", __func__, i);
+			continue;
+		}
+		*ep = init;
+		sprintf(ep->name, "ep%d", i);
+		ep->ep.name = ep->name;
+		if (i == 0)
+			ep->ep.caps.type_control = true;
+		else if (i < 6)
+			ep->ep.caps.type_bulk = true;
+		else if (i < 10)
+			ep->ep.caps.type_int = true;
+		else
+			ep->ep.caps.type_iso = true;
+
+		ep->ep.caps.dir_in = true;
+		ep->ep.caps.dir_out = true;
+
+		ep->has_dma = !!(readl(&chip->regs->usbssconf) & (1 << i));
+		usb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);
+
+		INIT_LIST_HEAD(&ep->queue);
+		spin_lock_init(&ep->lock);
+
+		if (ep->id == 0) {
+			usbf_ep0_init(ep);
+		} else {
+			usbf_epn_init(ep);
+			list_add_tail(&ep->ep.ep_list,
+				      &chip->gadget.ep_list);
+		}
+	}
+
+	/* Finish initialization by getting possible overrides from DT */
+	if (np) {
+		of_property_read_u32(np,
+				"renesas,dma-threshold", &chip->dma_threshold);
+		of_property_read_u32(np,
+				"renesas,sram-size", &chip->dma_ram_size);
+	}
+
+	/* Not specifying the sram size of the IP is not a problem per se,
+	 * however if you run out your configuration of endpoint over allocates
+	 * there will be no way to know, and you will have silent failure */
+	if (!chip->dma_ram_size)
+		dev_warn(chip->dev,
+			"unknown SRAM size, any overflow will be silent\n");
+
+	/* Tasklet and associated FIFO */
+	tasklet_init(&chip->tasklet, usbf_tasklet,
+			(unsigned long)chip);
+	INIT_KFIFO(chip->fifo);
+
+	/* request irqs */
+	chip->usb_epc_irq = irq_of_parse_and_map(np, 0);
+	if (!chip->usb_epc_irq) {
+		ret = -EINVAL;
+		goto err_noirq;
+	}
+	ret = devm_request_irq(chip->dev, chip->usb_epc_irq, usbf_epc_irq, 0,
+				driver_name, chip);
+	if (ret) {
+		dev_err(chip->dev, "cannot request irq %d err %d\n",
+				chip->usb_epc_irq, ret);
+		goto err_noirq;
+	}
+
+	chip->usb_irq = irq_of_parse_and_map(np, 1);
+	if (!chip->usb_irq) {
+		ret = -EINVAL;
+		goto err_noirq;
+	}
+	ret = devm_request_irq(chip->dev, chip->usb_irq, usbf_irq, 0,
+				driver_name, chip);
+	if (ret) {
+		dev_err(chip->dev, "cannot request irq %d err %d\n",
+				chip->usb_irq, ret);
+		goto err_noirq;
+	}
+
+	writel(readl(&chip->regs->sysmctr) | D_SYS_WBURST_TYPE, &chip->regs->sysmctr);
+
+	writel(D_USB_INT_SEL | D_USB_SOF_RCV | D_USB_SOF_CLK_MODE, &chip->regs->control);
+
+	/* Enable reset and mode change interrupts */
+	writel(D_USB_USB_RST_EN | D_USB_SPEED_MODE_EN, &chip->regs->int_enable);
+	/* Endpoint zero is always enabled anyway */
+	usbf_ep_enable(&chip->ep[0].ep, &ep0_desc);
+
+	ret = usb_add_gadget_udc_release(&ofdev->dev, &chip->gadget,
+			usbf_release);
+	if (ret)
+		goto err5;
+
+	platform_set_drvdata(ofdev, chip);
+
+	writel(D_SYS_VBUS_INTEN, &chip->regs->sysbinten);
+#ifdef DEBUG
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint *ep = chip->ep + i;
+		struct f_regs_ep *ep_reg = &chip->regs->ep[ep->id - 1];
+
+		TRACE("%s %s %08x\n", ep->name,
+			(readl(&chip->regs->usbssconf) & (1 << i)) ?
+					"DMA" : "(no DMA)",
+			readl(&ep_reg->pckt_adrs));
+	}
+#endif
+	pr_info("%s completed (gadget %s)\n", __func__, chip->gadget.name);
+
+#ifdef	CONFIG_DEBUG_FS
+	usbf = chip;
+#endif
+
+	return 0;
+err5:
+err_noirq:
+	clk_disable_unprepare(chip->clk_fw);
+invalid_config:
+clk_failed:
+invalid_mapping:
+	return ret;
+}
+
+static int usbf_remove(struct platform_device *ofdev)
+{
+	struct f_drv *chip = platform_get_drvdata(ofdev);
+	DECLARE_COMPLETION(done);
+
+	TRACE("%s\n", __func__);
+
+	usb_del_gadget_udc(&chip->gadget);
+
+	chip->done = &done;
+	tasklet_disable(&chip->tasklet);
+
+	/* remove the pullup, apparently putting the controller
+	 * in reset doesn't do it! */
+	pullup(chip, 0);
+	/* get back into reset */
+	writel(readl(&chip->regs->epctr) | D_SYS_EPC_RST | D_SYS_PLL_RST,
+			&chip->regs->epctr);
+
+	devm_free_irq(chip->dev, chip->usb_irq, chip);
+	irq_dispose_mapping(chip->usb_irq);
+	devm_free_irq(chip->dev, chip->usb_epc_irq, chip);
+	irq_dispose_mapping(chip->usb_epc_irq);
+
+	tasklet_kill(&chip->tasklet);
+
+	iounmap(chip->regs);
+
+	/* wait for release() of gadget.dev to free udc */
+	wait_for_completion(&done);
+	clk_unprepare(chip->clk_fw);
+
+	return 0;
+}
+
+#ifdef	CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+static const char *ep_status[2][32] = { {
+	"SETUP_INT",
+	"STG_START_INT",
+	"STG_END_INT",
+	"STALL_INT",
+	"IN_INT",
+	"OUT_INT",
+	"OUT_OR_INT",
+	"OUT_NULL_INT",
+	"IN_EMPTY",
+	"IN_FULL",
+	"IN_DATA",
+	"IN_NAK_INT",
+	"OUT_EMPTY",
+	"OUT_FULL",
+	"OUT_NULL",
+	"OUT_NAK_INT",
+	"PERR_NAK_INT",
+	"PERR_NAK",
+	"PID",
+},
+{
+	"IN_EMPTY",
+	"IN_FULL",
+	"IN_DATA",
+	"IN_INT",
+	"IN_STALL_INT",
+	"IN_NAK_ERR_INT",
+	"(6)",
+	"IN_END_INT",
+	"(8)", "(9)",
+	"IPID",
+	"(11)", "(12)", "(13)", "(14)", "(15)",
+	"OUT_EMPTY",
+	"OUT_FULL",
+	"OUT_NULL_INT",
+	"OUT_INT",
+	"OUT_STALL_INT",
+	"OUT_NAK_ERR_INT",
+	"OUT_OR_INT",
+	"OUT_END_INT",
+	"(24)", "(25)", "(26)", "(27)",
+	"OPID",
+} };
+
+static ssize_t _usbf_dbg_show(struct seq_file *s, void *unused)
+{
+	struct f_drv *chip = usbf;
+	int i;
+
+	seq_puts(s, "USBF Driver Configuration\n");
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint *ep = chip->ep + i;
+		struct f_regs_ep *regs =
+			i ? ep->reg :
+			(struct f_regs_ep *)&chip->regs->ep0;
+		uint32_t reg[2] = {
+			readl(&regs->status),
+			ep->status };
+		int ri;
+
+		if (ep->disabled)
+			continue;
+		seq_printf(s, "%s: dir:%s status %08x/%08x seq:%02x %s%s: ",
+			ep->name,
+			usb_endpoint_dir_in(ep->desc) ? "input" : "output",
+			reg[0], reg[1], ep->seq,
+			ep->trace ? "TRACE " : "",
+			list_empty(&ep->queue) ? "(empty)" : "(queued)"
+			);
+		if (!list_empty(&ep->queue)) {
+			struct f_req *req = list_first_entry(&ep->queue,
+							struct f_req, queue);
+
+			seq_printf(s, "[%02x%s]:%d/%d bytes",
+				req->seq,
+				req->req.status == -EBUSY ? " DMA" :
+					req->req.status == 0 ? " DONE?!" : "",
+				req->req.actual, req->req.length);
+		}
+		seq_puts(s, "\n   >");
+
+		for (ri = 0; ri < 2; ri++) {
+			uint32_t r = reg[ri];
+			int ci = 0;
+
+			seq_puts(s, "\n   >");
+			while (r) {
+				int b = ffs(r) - 1;
+
+				r &= ~(1 << b);
+				if (ep_status[!!i][b])
+					seq_printf(s, "%s ", ep_status[!!i][b]);
+				else
+					seq_printf(s, "[%d] ", b);
+				ci = (ci + 1) % 6;
+				if (!ci && r)
+					seq_printf(s, "\n        ");
+			}
+		}
+		seq_puts(s, "\n");
+	}
+
+	return 0;
+}
+
+static int _usbf_dbg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, _usbf_dbg_show, &inode->i_private);
+}
+
+static const struct file_operations _fops = {
+	.open		= _usbf_dbg_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int usbf_debugfs_ops_ep_trace_show(void *data, uint64_t *value)
+{
+	struct f_drv *chip = usbf;
+	int i;
+
+	*value = 0;
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint *ep = chip->ep + i;
+
+		*value |= ep->trace << i;
+	}
+
+	return 0;
+}
+
+static int usbf_debugfs_ops_ep_trace_set(void *data, uint64_t value)
+{
+	struct f_drv *chip = usbf;
+	int i;
+
+	for (i = 0; i < CFG_NUM_ENDPOINTS; ++i) {
+		struct f_endpoint *ep = chip->ep + i;
+
+		ep->trace = !!(value & (1 << i));
+	}
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(usbf_debugfs_ops_ep_trace,
+	usbf_debugfs_ops_ep_trace_show,
+	usbf_debugfs_ops_ep_trace_set,
+	"%llu\n");
+
+static int __init usbf_debug_init(void)
+{
+	struct dentry *dir = debugfs_create_dir("usbf", NULL);
+
+	debugfs_create_file("regs", S_IRUGO, dir, NULL, &_fops);
+
+	debugfs_create_file("ep_trace", S_IWUGO | S_IRUGO, dir, NULL,
+				&usbf_debugfs_ops_ep_trace);
+
+	return 0;
+}
+
+late_initcall(usbf_debug_init);
+#endif /* CONFIG_DEBUG_FS */
+
+/*-------------------------------------------------------------------------*/
+static const struct of_device_id usbf_match[] = {
+	{ .compatible = "renesas,rzn1-usbf", },
+	{ .compatible = "renesas,usbf", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, usbf_match);
+
+static struct platform_driver udc_driver = {
+	.driver = {
+		.name = driver_name,
+		.owner = THIS_MODULE,
+		.of_match_table = usbf_match,
+	},
+	.probe          = usbf_probe,
+	.remove         = usbf_remove,
+};
+
+module_platform_driver(udc_driver);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/udc/usbf-renesas.h b/drivers/usb/gadget/udc/usbf-renesas.h
new file mode 100644
index 0000000..d9fe77e
--- /dev/null
+++ b/drivers/usb/gadget/udc/usbf-renesas.h
@@ -0,0 +1,614 @@
+/*
+ * Renesas RZ/N1 USB Device usb gadget driver
+ *
+ * Copyright 2015 Renesas Electronics Europe Ltd.
+ * Author: Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __USBF_RENESAS_H__
+#define __USBF_RENESAS_H__
+
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/types.h>
+#include <linux/usb/gadget.h>
+
+#ifdef DEBUG
+#define TRACE(...) printk(__VA_ARGS__)
+#define TRACERQ(_rq, ...) if ((_rq) && (_rq)->trace) printk(__VA_ARGS__)
+#define TRACEEP(_ep, ...) if ((_ep) && (_ep)->trace) printk(__VA_ARGS__)
+#else
+#define TRACE(...)
+#define TRACERQ(_rq, ...)
+#define TRACEEP(_rq, ...)
+#endif
+
+#define CFG_NUM_ENDPOINTS		16
+#define CFG_EP0_MAX_PACKET_SIZE		64
+#define CFG_EPX_MAX_PACKET_SIZE		512
+#define CFG_EPX_MAX_PACKET_CNT		256
+#define EP0_RAM_USED			0x20	/* 32 bits words */
+
+/*
+ * io block register for endpoint zero. Annoyingly enough, it differs
+ * from all the other endpoints.
+ */
+struct f_regs_ep0 {
+	/* these 3 are common with every other endpoint */
+	uint32_t control;		/* EP0 control register */
+	uint32_t status;		/* EP0 status register */
+	uint32_t int_enable;		/* EP0 interrupt enable register */
+
+	uint32_t length;		/* EP0 length register */
+	uint32_t read;			/* EP0 read register */
+	uint32_t write;			/* EP0 write register */
+};
+
+/*
+ * io block register for endpoint 1-15
+ */
+struct f_regs_ep {
+	/* these 3 are common with every other endpoint */
+	uint32_t control;		/* EPn control register */
+	uint32_t status;		/* EPn status register */
+	uint32_t int_enable;		/* EPn interrupt enable register */
+
+	uint32_t dma_ctrl;		/* EPn DMA control register */
+	uint32_t pckt_adrs;		/* EPn max packet & base address register */
+	uint32_t len_dcnt;		/* EPn length & DMA count register */
+	uint32_t read;			/* EPn read register */
+	uint32_t write;			/* EPn write register */
+};
+
+struct f_regs_epdma {
+	uint32_t epndcr1;		/* EPnDCR1 register */
+	uint32_t epndcr2;		/* EPnDCR2 register */
+	uint32_t epntadr;		/* EPnTADR register */
+	uint32_t padding;
+};
+
+/* IO registers for the USB device Ip block */
+struct f_regs {
+	/* The first block of register is 0x1000 long, so we make sure
+	 * it is padded to that size. Use of anonymous union makes it
+	 * painless here
+	 */
+	union {
+		struct {
+			uint32_t control;		/* USB Control register */
+			uint32_t status;		/* USB Status register */
+			uint32_t address;		/* Frame number & USB address register */
+			uint32_t reserved;
+			uint32_t test_control;		/* TEST control register */
+			uint32_t reserved1;
+			uint32_t setup_data0;		/* Setup Data 0 register */
+			uint32_t setup_data1;		/* Setup Data 1 register */
+			uint32_t int_status;		/* USB interrupt status register */
+			uint32_t int_enable;		/* USB interrupt enable register */
+			struct f_regs_ep0 ep0;
+			/* Index zero in this table is for EP1's register, not EP0 */
+			struct f_regs_ep ep[15];
+		};
+		uint8_t pad[0x1000];
+	};
+	/* Follows are the system registers at offset 0x1000 */
+	union {
+		struct {
+			union {	/* Offset 0x1000 */
+				struct {
+					uint32_t syssctr;		/* AHBSCTR register */
+					uint32_t sysmctr;		/* AHBMCTR register */
+					uint32_t sysbint;		/* AHBBINT register */
+					uint32_t sysbinten;		/* AHBBINTEN register */
+					uint32_t epctr;			/* EPCTR register */
+				};
+				uint8_t pada[0x20];
+			};
+			/* Offset 0x1020 */
+			uint32_t usbssver;
+			uint32_t usbssconf;
+		};
+		uint8_t	padb[0x100];
+	};
+	/* Index zero in this table is for EP0's (unused) registers */
+	struct f_regs_epdma epdma[16];	/* Offset 0x1100 */
+};
+
+
+struct f_req;
+struct f_endpoint;
+struct f_drv;
+
+enum {
+	USBF_PROCESS_PIO = 0,
+	USBF_PROCESS_DMA,
+	USBF_PROCESS_METHOD_COUNT
+};
+
+/* packet processor callback for the requests, return 0 when request is done */
+typedef int (*f_req_process_p)(struct f_endpoint *ep, struct f_req *);
+
+/* Endpoint 'driver', allows top level code to be endpoint agnostic */
+struct f_endpoint_drv {
+	int (*enable)(struct f_endpoint *ep);
+	void (*disable)(struct f_endpoint *ep);
+
+	void (*set_maxpacket)(struct f_endpoint *ep);
+
+	/* receive and send callbacks for this kind of endpoint
+	 * PIO is mandatory */
+	f_req_process_p recv[USBF_PROCESS_METHOD_COUNT];
+	f_req_process_p send[USBF_PROCESS_METHOD_COUNT];
+
+	void (*dma_complete)(struct f_endpoint *ep);
+
+	/* handle interrupt status changes */
+	void (*interrupt)(struct f_endpoint *ep);
+
+	int (*halt)(struct f_endpoint *ep, int halt);
+
+	void (*reset)(struct f_endpoint *ep);
+};
+
+/*
+ * USB Queued request, can be read/write, and will definitely be
+ * bigger than the max packet in an endpoint. the 'process' callback
+ * is called repeatedly to fulfill the request (ie, req->actual ==
+ * req->length) and will return 0 when it is, it is then ready to
+ * be 'completed' by the upper layer
+ */
+struct f_req {
+	struct usb_request		req;
+	struct list_head		queue;
+	/* callback used to receive or send this request */
+	f_req_process_p			process;
+	unsigned			use_dma: 1, mapped:1, to_host : 1;
+	unsigned			seq: 8, trace : 1; /* debug */
+	uint8_t				dma_pkt_count;
+	uint32_t			dma_non_burst_bytes;
+};
+
+/*
+ * Type of hardware endpoints
+ */
+enum {
+	USBF_EP_BULK = 0,
+	USBF_EP_INT,
+	USBF_EP_ISO,
+	USBF_EP_KIND_COUNT
+};
+
+/* USB Endpoint structure, with callbacks for send/receive etc */
+struct f_endpoint {
+	struct usb_ep			ep;
+	spinlock_t			lock; /* protect the struct */
+	/* endpoint specific callbacks */
+	const struct f_endpoint_drv	*drv;
+	char				name[32]; /* full endpoint name */
+	struct list_head		queue;
+	struct usb_endpoint_descriptor *desc;
+	struct f_drv			*chip;
+	struct f_regs_ep		*reg;
+	unsigned			id : 8;
+	unsigned			type : 2;	/* EP type */
+	unsigned			max_nr_pkts: 4;	/* default to 2 */
+	unsigned			has_dma: 1;	/* Is DMA capable */
+	unsigned			disabled : 1;
+	unsigned			seq : 8;	/* debug */
+	unsigned			trace : 1;	/* debug */
+	unsigned			trace_min: 10, trace_max: 10;
+	/* cumulative status, populated by the irq handler */
+	uint32_t			status;
+};
+
+/*
+ * We need to copy, and clear the status registers for everyone
+ * before the real interrupt line is cleared, this is a bit
+ * cumbersome but, there is no way around it otherwise the IRQ
+ * keeps firing
+ */
+struct f_status {
+	uint32_t			int_status;	/* global */
+	uint32_t			ep[16];	/* of the endpoints */
+};
+
+struct f_drv {
+	struct usb_gadget		gadget;
+	struct usb_gadget_driver	*driver;
+	struct device			*dev;
+	struct clk			*clk_fw;
+	spinlock_t			lock; /* protect the struct */
+	struct f_regs __iomem		*regs;
+	uint16_t			dma_ram_used;	/* in 32 bits words */
+	u32				dma_ram_size;	/* in 32 bits words */
+	u32				dma_threshold;
+	/* default number of packets, for each endpoints types */
+	uint8_t				dma_pkt_count[USBF_EP_KIND_COUNT];
+
+	struct f_endpoint		ep[CFG_NUM_ENDPOINTS];
+	int				pullup;
+	enum usb_device_state		state;
+
+	/* to make sure release() is done */
+	struct completion 		*done;
+	unsigned int			usb_irq;
+	unsigned int			usb_epc_irq;
+
+	/* for control messages caching */
+	uint32_t			setup[2];
+	struct f_req			setup_reply;
+
+	struct tasklet_struct		tasklet;
+
+	DECLARE_KFIFO(fifo, struct f_status, 16);
+};
+
+int usbf_ep0_init(
+	struct f_endpoint *ep);
+int usbf_epn_init(
+	struct f_endpoint *ep);
+
+int usbf_ep_process_queue(
+	struct f_endpoint *ep);
+
+/*=========================================================================*/
+/* USB_CONTROL [0x000] */
+/*=========================================================================*/
+enum {
+	D_USB_F_RST				= (1 << 0),
+	D_USB_PHY_RST				= (1 << 1),
+	D_USB_PUE2				= (1 << 2),
+	D_USB_CONNECTB				= (1 << 3),
+	D_USB_DEFAULT				= (1 << 4),
+	D_USB_CONF				= (1 << 5),
+	D_USB_SUSPEND				= (1 << 6),
+	D_USB_RSUM_IN				= (1 << 7),
+	D_USB_SOF_RCV				= (1 << 8),
+	D_USB_CONSTFS				= (1 << 9),
+	D_USB_INT_SEL				= (1 << 10),
+	D_USB_SOF_CLK_MODE			= (1 << 11),
+	D_USB_USBTESTMODE			= (1 << 16) | (1 << 17) |
+							(1 << 18),
+};
+
+/*=========================================================================*/
+/* USB_STATUS [0x004] */
+/*=========================================================================*/
+enum {
+	D_USB_VBUS_LEVEL			= (1 << 0),
+	D_USB_RSUM_OUT				= (1 << 1),
+	D_USB_SPND_OUT				= (1 << 2),
+	D_USB_USB_RST				= (1 << 3),
+/*	D_USB_DEFAULT				= (1 << 4),*/
+	D_USB_CONF_ST				= (1 << 5),
+	D_USB_SPEED_MODE			= (1 << 6),
+};
+
+/*=========================================================================*/
+/* USB_ADDRESS [0x008] */
+/*=========================================================================*/
+enum {
+	D_USB_SOF_STATUS			= (1 << 15),
+	D_USB_USB_ADDR				= 0x007F0000,
+};
+
+/*=========================================================================*/
+/* USB_INT_STA [0x020] */
+/*=========================================================================*/
+enum {
+/*	D_USB_VBUS_LEVEL			= (1 << 0), */
+	D_USB_RSUM_INT				= (1 << 1),
+	D_USB_SPND_INT				= (1 << 2),
+	D_USB_USB_RST_INT			= (1 << 3),
+	D_USB_SOF_INT				= (1 << 4),
+	D_USB_SOF_ERROR_INT			= (1 << 5),
+	D_USB_SPEED_MODE_INT			= (1 << 6),
+	D_USB_VBUS_INT				= (1 << 7),
+	D_USB_EP0_INT				= (1 << 8),
+	D_USB_EP1_INT				= (1 << 9),
+	D_USB_EP2_INT				= (1 << 10),
+	D_USB_EP3_INT				= (1 << 11),
+	D_USB_EP4_INT				= (1 << 12),
+	D_USB_EP5_INT				= (1 << 13),
+	D_USB_EP6_INT				= (1 << 14),
+	D_USB_EP7_INT				= (1 << 15),
+	D_USB_EP8_INT				= (1 << 16),
+	D_USB_EP9_INT				= (1 << 17),
+	D_USB_EPN_INT				= 0x00FFFF00,
+};
+
+/*=========================================================================*/
+/* USB_INT_ENA [0x024] */
+/*=========================================================================*/
+enum {
+	D_USB_RSUM_EN				= (1 << 1),
+	D_USB_SPND_EN				= (1 << 2),
+	D_USB_USB_RST_EN			= (1 << 3),
+	D_USB_SOF_EN				= (1 << 4),
+	D_USB_SOF_ERROR_EN			= (1 << 5),
+	D_USB_SPEED_MODE_EN			= (1 << 6),
+	D_USB_VBUS_EN				= (1 << 7),
+	D_USB_EP0_EN				= (1 << 8),
+	D_USB_EP1_EN				= (1 << 9),
+	D_USB_EP2_EN				= (1 << 10),
+	D_USB_EP3_EN				= (1 << 11),
+	D_USB_EP4_EN				= (1 << 12),
+	D_USB_EP5_EN				= (1 << 13),
+	D_USB_EP6_EN				= (1 << 14),
+	D_USB_EP7_EN				= (1 << 15),
+	D_USB_EP8_EN				= (1 << 16),
+	D_USB_EP9_EN				= (1 << 17),
+	D_USB_EPN_EN				= 0x00FFFF00,
+};
+
+/*=========================================================================*/
+/* EP0_CONTROL [0x028] */
+/*=========================================================================*/
+enum {
+	D_EP0_ONAK				= (1 << 0),
+	D_EP0_INAK				= (1 << 1),
+	D_EP0_STL				= (1 << 2),
+	D_EP0_PERR_NAK_CLR			= (1 << 3),
+	D_EP0_INAK_EN				= (1 << 4),
+	D_EP0_DW				= (1 << 5) | (1 << 6),
+	D_EP0_DEND				= (1 << 7),
+	D_EP0_BCLR				= (1 << 8),
+	D_EP0_PIDCLR				= (1 << 9),
+	D_EP0_AUTO				= (1 << 16),
+	D_EP0_OVERSEL				= (1 << 17),
+	D_EP0_STGSEL				= (1 << 18),
+};
+
+/*=========================================================================*/
+/* EP0_STATUS [0x02C] */
+/*=========================================================================*/
+enum {
+	D_EP0_SETUP_INT				= (1 << 0),
+	D_EP0_STG_START_INT			= (1 << 1),
+	D_EP0_STG_END_INT			= (1 << 2),
+	D_EP0_STALL_INT				= (1 << 3),
+	D_EP0_IN_INT				= (1 << 4),
+	D_EP0_OUT_INT				= (1 << 5),
+	D_EP0_OUT_OR_INT			= (1 << 6),
+	D_EP0_OUT_NULL_INT			= (1 << 7),
+	D_EP0_IN_EMPTY				= (1 << 8),
+	D_EP0_IN_FULL				= (1 << 9),
+	D_EP0_IN_DATA				= (1 << 10),
+	D_EP0_IN_NAK_INT			= (1 << 11),
+	D_EP0_OUT_EMPTY				= (1 << 12),
+	D_EP0_OUT_FULL				= (1 << 13),
+	D_EP0_OUT_NULL				= (1 << 14),
+	D_EP0_OUT_NAK_INT			= (1 << 15),
+	D_EP0_PERR_NAK_INT			= (1 << 16),
+	D_EP0_PERR_NAK				= (1 << 17),
+	D_EP0_PID				= (1 << 18),
+};
+
+/*=========================================================================*/
+/* EP0_INT_ENA [0x030] */
+/*=========================================================================*/
+enum {
+	D_EP0_SETUP_EN				= (1 << 0),
+	D_EP0_STG_START_EN			= (1 << 1),
+	D_EP0_STG_END_EN			= (1 << 2),
+	D_EP0_STALL_EN				= (1 << 3),
+	D_EP0_IN_EN				= (1 << 4),
+	D_EP0_OUT_EN				= (1 << 5),
+	D_EP0_OUT_OR_EN				= (1 << 6),
+	D_EP0_OUT_NULL_EN			= (1 << 7),
+	D_EP0_IN_NAK_EN				= (1 << 11),
+	D_EP0_OUT_NAK_EN			= (1 << 15),
+	D_EP0_PERR_NAK_EN			= (1 << 16),
+};
+
+/*=========================================================================*/
+/* EP0_LENGTH [0x034] */
+/*=========================================================================*/
+enum {
+	D_EP0_LDATA				= 0x0000007F,
+};
+
+/*=========================================================================*/
+/* EPN_CONTROL_BIT */
+/*=========================================================================*/
+enum {
+	D_EPN_ONAK				= (1 << 0),
+	D_EPN_OSTL				= (1 << 2),
+	D_EPN_ISTL				= (1 << 3),
+	D_EPN_OSTL_EN				= (1 << 4),
+	D_EPN_DW				= (1 << 5) | (1 << 6),
+	D_EPN_DEND				= (1 << 7),
+	D_EPN_CBCLR				= (1 << 8),
+	D_EPN_BCLR				= (1 << 9),
+	D_EPN_OPIDCLR				= (1 << 10),
+	D_EPN_IPIDCLR				= (1 << 11),
+	D_EPN_AUTO				= (1 << 16),
+	D_EPN_OVERSEL				= (1 << 17),
+	D_EPN_MODE				= (1 << 24) | (1 << 25),
+	D_EPN_DIR0				= (1 << 26),
+	D_EPN_BUF_TYPE				= (1 << 30),
+	D_EPN_EN				= (1 << 31),
+};
+
+/*=========================================================================*/
+/* EPN_STATUS_BIT */
+/*=========================================================================*/
+enum {
+	D_EPN_IN_EMPTY				= (1 << 0),
+	D_EPN_IN_FULL				= (1 << 1),
+	D_EPN_IN_DATA				= (1 << 2),
+	D_EPN_IN_INT				= (1 << 3),
+	D_EPN_IN_STALL_INT			= (1 << 4),
+	D_EPN_IN_NAK_ERR_INT			= (1 << 5),
+	D_EPN_IN_END_INT			= (1 << 7),
+	D_EPN_IPID				= (1 << 10),
+	D_EPN_OUT_EMPTY				= (1 << 16),
+	D_EPN_OUT_FULL				= (1 << 17),
+	D_EPN_OUT_NULL_INT			= (1 << 18),
+	D_EPN_OUT_INT				= (1 << 19),
+	D_EPN_OUT_STALL_INT			= (1 << 20),
+	D_EPN_OUT_NAK_ERR_INT			= (1 << 21),
+	D_EPN_OUT_OR_INT			= (1 << 22),
+	D_EPN_OUT_END_INT			= (1 << 23),
+	D_EPN_OPID				= (1 << 28),
+};
+
+/*=========================================================================*/
+/* EPN_INT_ENA */
+/*=========================================================================*/
+enum {
+	D_EPN_IN_EN				= (1 << 3),
+	D_EPN_IN_STALL_EN			= (1 << 4),
+	D_EPN_IN_NAK_ERR_EN			= (1 << 5),
+	D_EPN_IN_END_EN				= (1 << 7),
+	D_EPN_OUT_NULL_EN			= (1 << 18),
+	D_EPN_OUT_EN				= (1 << 19),
+	D_EPN_OUT_STALL_EN			= (1 << 20),
+	D_EPN_OUT_NAK_ERR_EN			= (1 << 21),
+	D_EPN_OUT_OR_EN				= (1 << 22),
+	D_EPN_OUT_END_EN			= (1 << 23),
+};
+
+/*=========================================================================*/
+/* EPN_DMA_CTRL */
+/*=========================================================================*/
+enum {
+	D_EPN_DMAMODE0				= (1 << 0),
+	D_EPN_DMAMODE2				= (1 << 2),
+	D_EPN_DMA_EN				= (1 << 4),
+	D_EPN_STOP_SET				= (1 << 8),
+	D_EPN_BURST_SET				= (1 << 9),
+	D_EPN_DEND_SET				= (1 << 10),
+	D_EPN_STOP_MODE				= (1 << 11),
+	D_EPN_BUS_SEL				= (1 << 12) | (1 << 13),
+};
+
+/*=========================================================================*/
+/* EPN_PCKT_ADRS */
+/*=========================================================================*/
+enum {
+	D_EPN_MPKT				= 0x000007FF,
+	D_EPN_BASEAD				= 0x1FFF0000,
+};
+
+/*=========================================================================*/
+/* EPN_LEN_DCNT */
+/*=========================================================================*/
+enum {
+	D_EPN_LDATA				= 0x000007FF,
+	D_EPN_DMACNT				= 0x01FF0000,
+};
+
+
+/*=========================================================================*/
+/* SYSSCTR [0x1000] */
+/*=========================================================================*/
+enum {
+	D_SYS_WAIT_MODE				= (1 << 0),
+	D_SYS_NOT_RETRY_MASTER			= 0xFFFF0000,
+};
+
+/*=========================================================================*/
+/* SYSMCTR [0x1004] */
+/*=========================================================================*/
+enum {
+	D_SYS_ARBITER_CTR			= (1 << 31),
+	D_SYS_WBURST_TYPE			= (1 << 2),
+};
+
+/*=========================================================================*/
+/* SYSBINT [0x1008] */
+/*=========================================================================*/
+enum {
+	D_SYS_ERR_MASTER			= 0x0000000F,
+	D_SYS_SBUS_ERRINT0			= (1 << 4),
+	D_SYS_SBUS_ERRINT1			= (1 << 5),
+	D_SYS_MBUS_ERRINT			= (1 << 6),
+	D_SYS_VBUS_INT				= (1 << 13),
+	D_SYS_DMA_ENDINT_EP1			= (1 << 17),
+	D_SYS_DMA_ENDINT_EP2			= (1 << 18),
+	D_SYS_DMA_ENDINT_EP3			= (1 << 19),
+	D_SYS_DMA_ENDINT_EP4			= (1 << 20),
+	D_SYS_DMA_ENDINT_EP5			= (1 << 21),
+	D_SYS_DMA_ENDINT_EP6			= (1 << 22),
+	D_SYS_DMA_ENDINT_EP7			= (1 << 23),
+	D_SYS_DMA_ENDINT_EP8			= (1 << 24),
+	D_SYS_DMA_ENDINT_EP9			= (1 << 25),
+	D_SYS_DMA_ENDINT_EPN			= 0xFFFE0000,
+};
+
+/*=========================================================================*/
+/* SYSBINTEN [ 0x100C ] */
+/*=========================================================================*/
+enum {
+	D_SYS_SBUS_ERRINT0EN			= (1 << 4),
+	D_SYS_SBUS_ERRINT1EN			= (1 << 5),
+	D_SYS_MBUS_ERRINTEN			= (1 << 6),
+	D_SYS_VBUS_INTEN			= (1 << 13),
+	D_SYS_DMA_ENDINTEN_EP1			= (1 << 17),
+	D_SYS_DMA_ENDINTEN_EP2			= (1 << 18),
+	D_SYS_DMA_ENDINTEN_EP3			= (1 << 19),
+	D_SYS_DMA_ENDINTEN_EP4			= (1 << 20),
+	D_SYS_DMA_ENDINTEN_EP5			= (1 << 21),
+	D_SYS_DMA_ENDINTEN_EP6			= (1 << 22),
+	D_SYS_DMA_ENDINTEN_EP7			= (1 << 23),
+	D_SYS_DMA_ENDINTEN_EP8			= (1 << 24),
+	D_SYS_DMA_ENDINTEN_EP9			= (1 << 25),
+	D_SYS_DMA_ENDINTEN_EPN			= 0xFFFE0000,
+};
+
+/*=========================================================================*/
+/* EPCTR [ 0x1010 ] */
+/*=========================================================================*/
+enum {
+	D_SYS_EPC_RST				= (1 << 0),
+	D_SYS_USBH_RST				= (1 << 1),
+	D_SYS_PLL_RST				= (1 << 2),
+	D_SYS_PCICLK_MASK			= (1 << 3),
+	D_SYS_PLL_LOCK				= (1 << 4),
+	D_SYS_PLL_RESUME			= (1 << 5),
+	D_SYS_VBUS_LEVEL			= (1 << 8),
+	D_SYS_DIRPD				= (1 << 12),
+};
+
+/*=========================================================================*/
+/* USBSSVER [ 0x1020 ] */
+/*=========================================================================*/
+enum {
+	D_SYS_SS_VER				= 0x000000FF,
+	D_SYS_EPC_VER				= 0x0000FF00,
+	D_SYS_SYSB_VER				= 0x00FF0000,
+};
+
+/*=========================================================================*/
+/* USBSSCONF [ 0x1024 ] */
+/*=========================================================================*/
+enum {
+	D_SYS_DMA_AVAILABLE			= 0x0000FFFF,
+	D_SYS_EP_AVAILABLE			= 0xFFFF0000,
+};
+
+/*=========================================================================*/
+/* DCR1 */
+/*=========================================================================*/
+enum {
+	D_SYS_EPN_REQEN				= (1 << 0),
+	D_SYS_EPN_DIR0				= (1 << 1),
+	D_SYS_EPN_DMACNT			= 0x00FF0000,
+};
+
+/*=========================================================================*/
+/* DCR2 */
+/*=========================================================================*/
+enum {
+	D_SYS_EPN_MPKT				= 0x000007FF,
+	D_SYS_EPN_LMPKT				= 0x07FF0000,
+};
+
+#endif /* __USBF_RENESAS_H__ */
diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index 5ffa4b4..6cacf7b 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -179,6 +179,18 @@ config BACKLIGHT_ATMEL_LCDC
 	  If in doubt, it's safe to enable this option; it doesn't kick
 	  in unless the board's description says it's wired that way.
 
+config BACKLIGHT_DB9000_LCD
+	bool "Digital Block DB9000 LCDC Contrast-as-Backlight control"
+	depends on FB_DB9000
+	help
+	  This provides a backlight control internal to the DB9000 LCDC
+	  driver.  If the LCD "contrast control" on your board is wired
+	  so it controls the backlight brightness, select this option to
+	  export this as a PWM-based backlight control.
+
+	  If in doubt, it's safe to enable this option; it doesn't kick
+	  in unless the board's description says it's wired that way.
+
 config BACKLIGHT_EP93XX
 	tristate "Cirrus EP93xx Backlight Driver"
 	depends on FB_EP93XX
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index 5d3b0db..61b6926 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2389,6 +2389,33 @@ config FB_AUO_K1901
 	  This controller can drive Sipix epaper displays and supports
 	  concurrent updates, making higher frames per second possible.
 
+config FB_DB9000
+	tristate "DB9000 LCD framebuffer support"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_MODE_HELPERS if OF
+	select VIDEOMODE_HELPERS if OF
+	help
+	  Framebuffer support for Digital Blocks DB9000.
+
+config FB_DB9000_BLINK
+	bool "DB9000 LCD auto-blink support"
+	depends on FB_DB9000
+	help
+	  If the LCD Controller IP supports auto-blinking, you need
+	  to enable this option as the backlight PWM is controlled by different
+	  registers.
+
+	  To enable blinking, the bits-per-pixel dtb property is set to 24 and
+	  the blink-period-ms property specifies the blink period.
+
+	  When blinking is enabled, the Controller will automatically replace
+	  certain red and green colors with black. The framebuffer is packed
+	  24bpp, the upper two bits control the blink on/off and blink speed,
+	  followed by the colors R[7:1], G[7:0], B[7:1].
+
 config FB_JZ4740
 	tristate "JZ4740 LCD framebuffer support"
 	depends on FB && MACH_JZ4740
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index ee8c814..6454b07 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -103,6 +103,7 @@ obj-$(CONFIG_FB_BROADSHEET)       += broadsheetfb.o
 obj-$(CONFIG_FB_AUO_K190X)	  += auo_k190x.o
 obj-$(CONFIG_FB_AUO_K1900)	  += auo_k1900fb.o
 obj-$(CONFIG_FB_AUO_K1901)	  += auo_k1901fb.o
+obj-$(CONFIG_FB_DB9000) 	  += db9000fb.o
 obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
 obj-$(CONFIG_FB_SH7760)		  += sh7760fb.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
diff --git a/drivers/video/fbdev/db9000fb.c b/drivers/video/fbdev/db9000fb.c
new file mode 100644
index 0000000..20bf7d8
--- /dev/null
+++ b/drivers/video/fbdev/db9000fb.c
@@ -0,0 +1,1667 @@
+/*
+ * linux/drivers/video/db9000fb.c
+ * -- Digital Blocks DB9000 LCD Controller Frame Buffer Device
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd.
+ * Copyright (C) 2010 Digital Blocks, Inc.
+ *
+ * Based on pxafb.c and amba-clcd.c which is:
+ * Copyright (C) 1999 Eric A. Thomas.
+ * Copyright (C) 2004 Jean-Frederic Clere.
+ * Copyright (C) 2004 Ian Campbell.
+ * Copyright (C) 2004 Jeff Lackey.
+ * Based on sa1100fb.c Copyright (C) 1999 Eric A. Thomas
+ * which in turn is
+ * Based on acornfb.c Copyright (C) Russell King.
+ * Copyright (C) 2001 ARM Limited, by David A Rusling
+ * Updated to 2.5, Deep Blue Solutions Ltd.
+ *
+ * 2010-05-01: Guy Winter <gwinter@digitalblocks.com>
+ * - ported pxafb and some amba-clcd code to DB9000
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+
+#include <linux/backlight.h>
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <video/display_timing.h>
+#include <video/of_display_timing.h>
+#include "db9000fb.h"
+
+#define DRIVER_NAME "clcd-db9000"
+#define DEF_BRIGHTNESS 0x80
+
+const char *mode_option;
+
+/* Bits which should not be set in machine configuration structures */
+#define CR1_INVALID_CONFIG_MASK	(~(DB9000_CR1_ENB | DB9000_CR1_LPE |\
+			DB9000_CR1_BPP(7) | DB9000_CR1_RGB | DB9000_CR1_EPO |\
+			DB9000_CR1_EBO | DB9000_CR1_DEP | DB9000_CR1_PCP |\
+			DB9000_CR1_HSP | DB9000_CR1_VSP | DB9000_CR1_OPS(7) |\
+			DB9000_CR1_FDW(3) | DB9000_CR1_LPS |\
+			DB9000_CR1_FBP | DB9000_CR1_DEE))
+
+#define DB9000_IMR_MASK_ALL (DB9000_ISR_OFUM | DB9000_ISR_OFOM |\
+			DB9000_ISR_IFUM | DB9000_ISR_IFOM | DB9000_ISR_FERM |\
+			DB9000_ISR_MBEM | DB9000_ISR_VCTM | DB9000_ISR_BAUM |\
+			DB9000_ISR_LDDM | DB9000_ISR_ABLM | DB9000_ISR_ARIM |\
+			DB9000_ISR_ARSM | DB9000_ISR_FBEM | DB9000_ISR_FNCM |\
+			DB9000_ISR_FLCM)
+
+/* These are the lcd controller states & actions for set_ctrlr_state */
+enum {
+	C_DISABLE = 0,
+	C_ENABLE,
+	C_DISABLE_CLKCHANGE,
+	C_ENABLE_CLKCHANGE,
+	C_REENABLE,
+	C_DISABLE_PM,
+	C_ENABLE_PM,
+	C_STARTUP,
+};
+
+#define LCD_PCLK_EDGE_RISE	(0 << 9)
+#define LCD_PCLK_EDGE_FALL	(1 << 9)
+
+
+#define NUM_OF_FRAMEBUFFERS	2
+#define PALETTE_SIZE		(128 * 4)
+
+
+struct db9000fb_info {
+	struct fb_info		fb;
+	struct device		*dev;
+	struct platform_device	*pdev;
+	struct clk		*clk;
+	struct clk		*bus_clk;
+	struct clk		*pixel_clk;
+
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pins_default;
+	struct pinctrl_state	*pins_sleep;
+	bool			clk_enabled;
+
+	atomic_t		usage;
+
+	/* raw memory addresses */
+	unsigned long		hsync_time;
+	unsigned long		cmap[16];
+/* size of the one frame buffer */
+	size_t			frame_size;
+/* virtual address of palette memory */
+	u_int			palette_size;
+	void __iomem            *mmio_base;
+
+/* Local images/copies of device registers */
+	u32			reg_cr1;
+	u32			reg_htr;
+	u32			reg_hvter;
+	u32			reg_vtr1;
+	u32			reg_vtr2;
+	u32			reg_pctr;
+	u32			reg_dbar;
+	u32			reg_dear;
+	u32			reg_pwmfr;
+	u32			reg_pwmdcr;
+
+	u32			palette[PALETTE_SIZE/4];
+
+	u32			buswidth;
+	u_char			state;
+	u_char			old_state;
+	u_char			task_state;
+	u16			db9000_rev;
+	struct mutex		ctrlr_lock;
+	wait_queue_head_t	ctrlr_wait;
+	struct work_struct	task;
+
+	/* Completion - for PAN display alignment with VSYNC/BAU event */
+	struct completion vsync_notifier;
+
+	/* ignore_cpufreq_notification is > 0 if cpu and clcd uses diff pll */
+	bool ignore_cpufreq_notification;
+
+#ifdef CONFIG_CPU_FREQ
+	struct notifier_block	freq_transition;
+	struct notifier_block	freq_policy;
+#endif
+
+#ifdef CONFIG_BACKLIGHT_DB9000_LCD
+	struct backlight_device *backlight;
+	u32			pwm_clock;
+	u8			bl_power;
+#endif
+
+	bool			use_blinking;
+};
+
+#define to_db9000fb(info)	container_of(info, struct db9000fb_info, fb)
+#define TO_INF(ptr, member)	container_of(ptr, struct db9000fb_info, member)
+
+static inline void db9000fb_backlight_power(struct db9000fb_info *fbi, int on);
+static inline void db9000fb_lcd_power(struct db9000fb_info *fbi, int on);
+static int db9000fb_activate_var(struct fb_var_screeninfo *var,
+		struct db9000fb_info *fbi);
+static void set_ctrlr_state(struct db9000fb_info *fbi, u_int state);
+
+static inline u32
+lcd_readl(struct db9000fb_info *fbi, unsigned int off)
+{
+	return readl(fbi->mmio_base + off);
+}
+
+static inline void
+lcd_writel(struct db9000fb_info *fbi, unsigned int off, u32 val)
+{
+	writel(val, fbi->mmio_base + off);
+}
+
+static inline void
+db9000fb_schedule_work(struct db9000fb_info *fbi, u_int state)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	/*
+	 * We need to handle two requests being made at the same time.
+	 * There are two important cases:
+	 * 1. When we are changing VT (C_REENABLE) while unblanking (C_ENABLE)
+	 *	We must perform the unblanking, which will do our REENABLE for
+	 *	us.
+	 * 2. When we are blanking, but immediately unblank before we have
+	 *	blanked. We do the "REENABLE" thing here as well, just to be
+	 *	sure.
+	 */
+	if (fbi->task_state == C_ENABLE && state == C_REENABLE)
+		state = (u_int) -1;
+
+	if (fbi->task_state == C_DISABLE && state == C_ENABLE)
+		state = C_REENABLE;
+
+	if (state != (u_int)-1) {
+		fbi->task_state = state;
+		schedule_work(&fbi->task);
+	}
+
+	local_irq_restore(flags);
+}
+
+static inline u_int convert_bitfield(u_int val, struct fb_bitfield *bf)
+{
+	unsigned int mask = (1 << bf->length) - 1;
+
+	return (val >> (16 - bf->length) & mask) << bf->offset;
+}
+
+static int
+db9000fb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue, u_int
+		trans, struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+	u_int val;
+	u16 *pal = (u16 *)&fbi->palette[0];
+
+	if (regno >= fbi->palette_size)
+		return 1;
+
+	if (fbi->fb.var.grayscale) {
+		pal[regno] = ((blue >> 8) & 0x00ff);
+		return 0;
+	}
+
+	/* red and blue swapped */
+	if (fbi->reg_cr1 & DB9000_CR1_RGB) {
+		val = red;
+		red = blue;
+		blue = val;
+	}
+
+	if ((fbi->reg_cr1 & DB9000_CR1_OPS(7)) == DB9000_CR1_OPS(1)) {
+		/* RGB, 5:5:5 format */
+		val = ((red >> 1) & 0x7c00);
+		val |= ((green >> 6) & 0x03e0);
+		val |= ((blue >> 11) & 0x001f);
+	} else {
+		/* RGB, 5:6:5 format */
+		val = ((red >> 0) & 0xf800);
+		val |= ((green >> 5) & 0x07e0);
+		val |= ((blue >> 11) & 0x001f);
+	}
+	pal[regno] = val;
+
+	return 0;
+}
+
+static int
+db9000fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue, u_int trans,
+		struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value to greyscale no
+	 * matter what visual we are using.
+	 */
+	if (fbi->fb.var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				7471 * blue) >> 16;
+
+	switch (fbi->fb.fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour. We encode the RGB value according to the
+		 * RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fbi->fb.pseudo_palette;
+
+			val = convert_bitfield(red, &fbi->fb.var.red);
+			val |= convert_bitfield(green, &fbi->fb.var.green);
+			val |= convert_bitfield(blue, &fbi->fb.var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		ret = db9000fb_setpalettereg(regno, red, green, blue, trans,
+				info);
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * db9000fb_bpp_to_cr1():
+ *	Convert a bits per pixel value to the correct bit pattern for CR1
+ */
+static int db9000fb_bpp_to_cr1(struct fb_var_screeninfo *var)
+{
+	int ret = 0;
+
+	switch (var->bits_per_pixel) {
+	case 1:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_1bpp);
+		break;
+	case 2:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_2bpp);
+		break;
+	case 4:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_4bpp);
+		break;
+	case 8:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_8bpp);
+		break;
+	case 16:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_16bpp);
+		break;
+	case 18:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_18bpp);
+		break;
+	case 24:
+	default:
+		ret = DB9000_CR1_BPP(DB9000_CR1_BPP_24bpp);
+	}
+
+	return ret;
+}
+
+static int
+db9000fb_check_var_in(struct fb_var_screeninfo *var)
+{
+	if (var->xres < 16 || var->xres > 4096 || (var->xres % 16)) {
+		pr_err("invalid xres %d\n", var->xres);
+		return -EINVAL;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+	case 16:
+	case 18:
+	case 24:
+	case 32:
+		break;
+	default:
+		pr_err("invalid bit depth %d\n", var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	if (var->hsync_len < 0 || var->hsync_len > 255) {
+		pr_err("invalid hsync_len %d\n", var->hsync_len);
+		return -EINVAL;
+	}
+	if (var->left_margin < 0 || var->left_margin > 1023) {
+		pr_err("invalid left_margin %d\n", var->left_margin);
+		return -EINVAL;
+	}
+	if (var->right_margin < 0 || var->right_margin > 1023) {
+		pr_err("invalid right_margin %d\n", var->right_margin);
+		return -EINVAL;
+	}
+	if (var->yres < 0 || var->yres > 4096) {
+		pr_err("invalid yres %d\n", var->yres);
+		return -EINVAL;
+	}
+	if (var->vsync_len < 0 || var->vsync_len > 255) {
+		pr_err("invalid vsync_len %d\n", var->vsync_len);
+		return -EINVAL;
+	}
+	if (var->upper_margin < 0 || var->upper_margin > 1023) {
+		pr_err("invalid upper_margin %d\n", var->upper_margin);
+		return -EINVAL;
+	}
+	if (var->lower_margin < 0 || var->lower_margin > 1023) {
+		pr_err("invalid lower_margin %d\n", var->lower_margin);
+		return -EINVAL;
+	}
+	if (var->pixclock <= 0) {
+		pr_err("invalid pixel clock %d\n", var->pixclock);
+		return -EINVAL;
+	}
+	return 0;
+}
+/*
+ * db9000fb_check_var():
+ *	Get the video params out of 'var'. If a value doesn't fit, round it up,
+ *	if it's too big, return -EINVAL.
+ *
+ * Round up in the following order: bits_per_pixel, xres, yres, xres_virtual,
+ * yres_virtual, xoffset, yoffset, grayscale, bitfields, horizontal timing,
+ * vertical timing.
+ */
+static int
+db9000fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+
+	if (db9000fb_check_var_in(var) < 0)
+		return -EINVAL;
+
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+		var->red.offset		= var->green.offset = 0;
+		var->blue.offset	= var->transp.offset = 0;
+		var->red.length		= var->bits_per_pixel;
+		var->green.length	= var->bits_per_pixel;
+		var->blue.length	= var->bits_per_pixel;
+		var->transp.length	= 0;
+		break;
+	case 16:
+		var->red.offset		= 11;
+		var->red.length		= 5;
+		var->green.offset	= 5;
+		var->green.length	= 6;
+		var->blue.offset	= 0;
+		var->blue.length	= 5;
+		var->transp.offset	= var->transp.length = 0;
+		break;
+	case 18: /* RGB666 */
+		var->transp.offset	= var->transp.length = 0;
+		var->red.offset		= 12;
+		var->red.length		= 6;
+		var->green.offset	= 6;
+		var->green.length	= 6;
+		var->blue.offset	= 0;
+		var->blue.length	= 6;
+		break;
+	case 24: /* RGB888 */
+		if (!fbi->use_blinking) {
+			var->transp.offset	= var->transp.length = 0;
+			var->red.offset		= 16;
+			var->red.length		= 8;
+			var->green.offset	= 8;
+			var->green.length	= 8;
+			var->blue.offset	= 0;
+			var->blue.length	= 8;
+		} else {
+			/* Blinking attributes abuse the transparency field */
+			var->transp.offset	= 22;
+			var->transp.length	= 2;
+			var->red.offset		= 15;
+			var->red.length		= 7;
+			var->green.offset	= 7;
+			var->green.length	= 8;
+			var->blue.offset	= 0;
+			var->blue.length	= 7;
+		}
+		break;
+	case 32: /* RGB888 */
+		var->transp.offset	= 24;
+		var->transp.length	= 0;
+		var->red.offset		= 16;
+		var->red.length		= 8;
+		var->green.offset	= 8;
+		var->green.length	= 8;
+		var->blue.offset	= 0;
+		var->blue.length	= 8;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static inline void db9000fb_set_truecolor(u_int is_true_color)
+{
+	/* do your machine-specific setup if needed */
+}
+
+#ifdef CONFIG_BACKLIGHT_DB9000_LCD
+static int db9000_bl_update_status(struct backlight_device *bl)
+{
+	struct db9000fb_info *fbi = bl_get_data(bl);
+	int power = fbi->bl_power;
+	int brightness = bl->props.brightness;
+
+	if (bl->props.fb_blank != fbi->bl_power)
+		power =	bl->props.fb_blank;
+	else if (bl->props.power != fbi->bl_power)
+		power =	bl->props.power;
+
+	if (power == FB_BLANK_UNBLANK && brightness < 0)
+		brightness = lcd_readl(fbi, DB9000_PWMDCR);
+	else if (power != FB_BLANK_UNBLANK)
+		brightness = 0;
+
+	/* If turning off, save current brightness */
+	if (power)
+		fbi->reg_pwmdcr = lcd_readl(fbi, DB9000_PWMDCR);
+
+	lcd_writel(fbi, DB9000_PWMDCR, brightness);
+	bl->props.fb_blank = bl->props.power = fbi->bl_power = power;
+
+	return 0;
+}
+
+static int db9000_bl_get_brightness(struct backlight_device *bl)
+{
+	struct db9000fb_info *fbi = bl_get_data(bl);
+
+	return lcd_readl(fbi, DB9000_PWMDCR);
+}
+
+static const struct backlight_ops db9000_lcd_bl_ops = {
+	.update_status = db9000_bl_update_status,
+	.get_brightness	= db9000_bl_get_brightness,
+};
+
+static void init_backlight(struct db9000fb_info *fbi)
+{
+	struct backlight_device *bl;
+	struct backlight_properties props = {0, };
+
+	if (fbi->backlight)
+		return;
+
+	/* Has a PWM clock been specified? */
+	if (!fbi->pwm_clock)
+		return;
+
+	fbi->bl_power = FB_BLANK_UNBLANK;
+	props.max_brightness = 0xff;
+	props.type = BACKLIGHT_RAW;
+	bl = devm_backlight_device_register(fbi->dev, "backlight", fbi->dev,
+			fbi, &db9000_lcd_bl_ops, &props);
+
+	if (IS_ERR(bl)) {
+		dev_err(fbi->dev, "error %ld on backlight register\n",
+				PTR_ERR(bl));
+		return;
+	}
+
+	fbi->backlight = bl;
+
+	bl->props.power = FB_BLANK_UNBLANK;
+	bl->props.fb_blank = FB_BLANK_UNBLANK;
+	bl->props.brightness = db9000_bl_get_brightness(bl);
+	backlight_update_status(bl);
+}
+#endif
+
+/*
+ * db9000fb_set_par():
+ *	Set the user defined part of the display for the specified console
+ */
+static int db9000fb_set_par(struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+
+	fbi->fb.var.xres_virtual = fbi->fb.var.xres;
+	fbi->fb.var.yres_virtual = fbi->fb.var.yres *
+		NUM_OF_FRAMEBUFFERS;
+
+	if (fbi->fb.var.bits_per_pixel >= 16)
+		fbi->fb.fix.visual = FB_VISUAL_TRUECOLOR;
+	else
+		fbi->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;
+
+	fbi->fb.fix.line_length = (fbi->fb.var.xres_virtual *
+					fbi->fb.var.bits_per_pixel) / 8;
+	if (fbi->fb.var.bits_per_pixel >= 16)
+		fbi->palette_size = 0;
+	else
+		fbi->palette_size = 1 << fbi->fb.var.bits_per_pixel;
+
+	/* Set (any) board control register to handle new color depth */
+	db9000fb_set_truecolor(fbi->fb.fix.visual == FB_VISUAL_TRUECOLOR);
+
+	if (fbi->fb.var.bits_per_pixel >= 16) {
+		if (fbi->fb.cmap.len)
+			fb_dealloc_cmap(&fbi->fb.cmap);
+	} else {
+		fb_alloc_cmap(&fbi->fb.cmap, fbi->palette_size, 0);
+	}
+
+	db9000fb_activate_var(&fbi->fb.var, fbi);
+
+	return 0;
+}
+
+/*
+ * db9000fb_blank():
+ *	Blank the display by setting all palette values to zero. Note, the 16
+ *	bpp mode does not really use the palette, so this will not blank the
+ *	display in all modes.
+ */
+static int db9000fb_blank(int blank, struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+	int i;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		if (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR) {
+			for (i = 0; i < fbi->palette_size; i++)
+				db9000fb_setpalettereg(i, 0, 0, 0, 0, info);
+		}
+
+		db9000fb_schedule_work(fbi, C_DISABLE);
+	/* TODO: if (db9000fb_blank_helper) db9000fb_blank_helper(blank); */
+		break;
+
+	case FB_BLANK_UNBLANK:
+	/* TODO: if (db9000fb_blank_helper) db9000fb_blank_helper(blank); */
+		if (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR)
+			fb_set_cmap(&fbi->fb.cmap, info);
+		db9000fb_schedule_work(fbi, C_ENABLE);
+	}
+	return 0;
+}
+
+static int db9000fb_open(struct fb_info *info, int user)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+
+	/* Enable Controller only if its uses is zero*/
+	if (atomic_inc_return(&fbi->usage) == 1) {
+		set_ctrlr_state(fbi, C_ENABLE);
+
+#ifdef CONFIG_BACKLIGHT_DB9000_LCD
+		init_backlight(fbi);
+#endif
+	}
+	return 0;
+}
+
+static int db9000fb_release(struct fb_info *info, int user)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+
+	if (atomic_dec_and_test(&fbi->usage))
+		set_ctrlr_state(fbi, C_DISABLE);
+
+	return 0;
+}
+
+/* Pan the display if device supports it. */
+static int db9000fb_pan_display(struct fb_var_screeninfo *var,
+	struct fb_info *info)
+{
+	struct db9000fb_info *fbi = to_db9000fb(info);
+	u32 frame_addr;
+	u_int y_bottom = var->yoffset;
+
+	if (!(var->vmode & FB_VMODE_YWRAP))
+		y_bottom += var->yres;
+
+	BUG_ON(y_bottom > var->yres_virtual);
+
+	frame_addr = info->fix.smem_start +
+		(var->yoffset * info->fix.line_length);
+
+	/* There are some probing calls with no buffer switch */
+	if (fbi->reg_dbar != frame_addr) {
+		u32 imr;
+
+		lcd_writel(fbi, DB9000_DBAR, frame_addr);
+		lcd_writel(fbi, DB9000_DEAR, frame_addr + fbi->frame_size);
+		lcd_writel(fbi, DB9000_MRR,
+			DB9000_MRR_DEAR_MRR(frame_addr + fbi->frame_size) |
+			DB9000_MRR_MRR(DB9000_MRR_OUTST_4));
+
+		/* Enable Base Address Update interrupt */
+		imr = lcd_readl(fbi, DB9000_IMR);
+		lcd_writel(fbi, DB9000_IMR, imr | DB9000_ISR_BAU);
+		/*
+		 * Force waiting till the current buffer is completely drawn by
+		 * video controller
+		 */
+		wait_for_completion(&fbi->vsync_notifier);
+	}
+
+	return 0;
+}
+
+static struct fb_ops db9000fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_open	= db9000fb_open,
+	.fb_release	= db9000fb_release,
+	.fb_check_var	= db9000fb_check_var,
+	.fb_set_par	= db9000fb_set_par,
+	.fb_setcolreg	= db9000fb_setcolreg,
+	.fb_pan_display = db9000fb_pan_display,
+	.fb_fillrect	= sys_fillrect,
+	.fb_copyarea	= sys_copyarea,
+	.fb_imageblit	= sys_imageblit,
+	.fb_blank	= db9000fb_blank,
+};
+
+/*
+ * Some touchscreens need hsync information from the video driver to function
+ * correctly. We export it here. Note that 'hsync_time' and the value returned
+ * from db9000fb_get_hsync_time() is the *reciprocal* of the hsync period in
+ * seconds.
+ */
+static inline void set_hsync_time(struct db9000fb_info *fbi, unsigned int pcd)
+{
+	unsigned long htime;
+
+	if ((pcd == 0) || (fbi->fb.var.hsync_len == 0)) {
+		fbi->hsync_time = 0;
+		return;
+	}
+
+	htime = clk_get_rate(fbi->clk) / (pcd * fbi->fb.var.hsync_len);
+
+	fbi->hsync_time = htime;
+}
+
+unsigned long db9000fb_get_hsync_time(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	/* If display is blanked/suspended, hsync isn't active */
+	if (!fbi || (fbi->state != C_ENABLE))
+		return 0;
+
+	return fbi->hsync_time;
+}
+EXPORT_SYMBOL(db9000fb_get_hsync_time);
+
+static u32 get_pixclk(struct db9000fb_info *fbi,
+			unsigned int pixclock)
+{
+	unsigned long clk_rate;
+	unsigned long actual_rate;
+	int pcd;
+	u32 ret;
+
+	clk_rate = PICOS2KHZ(pixclock) * 1000;
+	pr_debug("Clock value is %ld", clk_rate);
+
+	/* If input pixel clock can be set to within 10% of the requested pixel
+	 * clock, use it.
+	 */
+	actual_rate = clk_round_rate(fbi->pixel_clk, clk_rate);
+	if ((clk_rate - actual_rate) < (clk_rate / 10)) {
+		clk_set_rate(fbi->pixel_clk, actual_rate);
+		clk_set_parent(fbi->clk, fbi->pixel_clk);
+		ret = DB9000_PCTR_PCI;
+	} else {
+		/* Otherwise, use the bus clock */
+		pcd = (clk_get_rate(fbi->bus_clk) / clk_rate) - 2;
+		if (pcd < 0)
+			dev_err(&fbi->pdev->dev, "Invalid pixel clock\n");
+
+		set_hsync_time(fbi, pcd);
+		clk_set_parent(fbi->clk, fbi->bus_clk);
+		ret = DB9000_PCTR_PCD(pcd);
+	}
+
+	if (fbi->pwm_clock) {
+		/* div = pclk / (256 x pwm_clock) */
+		u32 pwmfcd = clk_get_rate(fbi->clk) / 256;
+		pwmfcd /= fbi->pwm_clock;
+		fbi->reg_pwmfr = DB9000_PWMFR_PWM_FCD(pwmfcd - 1);
+	}
+
+	return ret;
+}
+
+static void setup_parallel_timing(struct db9000fb_info *fbi,
+				struct fb_var_screeninfo *var)
+{
+	fbi->reg_pctr &= ~0x7FF;
+
+	fbi->reg_pctr |= get_pixclk(fbi, var->pixclock);
+
+	fbi->reg_htr =
+	/* horizontal sync width */
+		DB9000_HTR_HSW(var->hsync_len) |
+	/* horizontal back porch */
+		DB9000_HTR_HBP(var->left_margin) |
+	/* Pixels per line */
+		DB9000_HTR_PPL((var->xres)/16) |
+	/* Horizontal Front Porch */
+		DB9000_HTR_HFP(var->right_margin);
+
+	/* Vertical and Horizontal Timing Extension write */
+	if (fbi->db9000_rev >= DB9000_REVISION_1_14) {
+		fbi->reg_hvter =
+			DB9000_HVTER_HFPE(var->right_margin) |
+			DB9000_HVTER_HBPE(var->left_margin) |
+			DB9000_HVTER_VFPE(var->lower_margin) |
+			DB9000_HVTER_VBPE(var->upper_margin);
+	}
+
+	fbi->reg_vtr1 =
+		DB9000_VTR1_VBP(var->upper_margin) |
+		DB9000_VTR1_VFP(var->lower_margin) |
+		DB9000_VTR1_VSW((var->vsync_len));
+
+	fbi->reg_vtr2 = DB9000_VTR2_LPP(var->yres);
+
+	fbi->reg_cr1 &= ~(DB9000_CR1_HSP | DB9000_CR1_VSP);
+	fbi->reg_cr1 |=
+		(var->sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : DB9000_CR1_HSP;
+	fbi->reg_cr1 |=
+		(var->sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : DB9000_CR1_VSP;
+	fbi->reg_dear = lcd_readl(fbi, DB9000_DBAR) + fbi->frame_size;
+}
+
+/*
+ * db9000fb_activate_var():
+ *	Configures LCD Controller based on entries in var parameter. Settings
+ *	are only written to the controller if changes were made.
+ */
+static int db9000fb_activate_var(struct fb_var_screeninfo *var,
+				struct db9000fb_info *fbi)
+{
+	if (db9000fb_check_var_in(var) < 0)
+		return -EINVAL;
+
+	if (var->xres_virtual < var->xres)
+		return -EINVAL;
+	if (var->yres_virtual < var->yres * NUM_OF_FRAMEBUFFERS)
+		return -EINVAL;
+
+	/* Update shadow copy atomically */
+	setup_parallel_timing(fbi, var);
+
+	fbi->reg_cr1 &= ~DB9000_CR1_BPP(7);
+	fbi->reg_cr1 |= db9000fb_bpp_to_cr1(var);
+
+	if (var->bits_per_pixel == 24)
+		fbi->reg_cr1 |= DB9000_CR1_FBP;
+	else
+		fbi->reg_cr1 &= ~DB9000_CR1_FBP;
+
+	/*
+	 * Normally, the controller simply outputs pixels straight from the
+	 * buffer to the panel. Buffers less than 16bpp are effecively treated
+	 * as 16bpp due to the palette. If we are connected to a panel with a
+	 * 24-bit interface, we need to shift the data to the msbits.
+	 */
+	if (var->bits_per_pixel <= 16 && fbi->buswidth == 24)
+		fbi->reg_cr1 |= DB9000_CR1_OPS(2);
+	else
+		fbi->reg_cr1 &= ~DB9000_CR1_OPS(2);
+
+	/*
+	 * Only update the registers if the controller is enabled and something
+	 * has changed.
+	 * DBAR is not checked here, it is adviced to be updated on BAU event
+	 */
+	if ((lcd_readl(fbi, DB9000_CR1) != fbi->reg_cr1) ||
+		(lcd_readl(fbi, DB9000_HTR) != fbi->reg_htr) ||
+		(lcd_readl(fbi, DB9000_VTR1) != fbi->reg_vtr1) ||
+		(lcd_readl(fbi, DB9000_VTR2) != fbi->reg_vtr2) ||
+		(lcd_readl(fbi, DB9000_HVTER) != fbi->reg_hvter) ||
+		(lcd_readl(fbi, DB9000_PCTR) != fbi->reg_pctr) ||
+		(lcd_readl(fbi, DB9000_DBAR) != fbi->reg_dbar) ||
+		(lcd_readl(fbi, DB9000_DEAR) != fbi->reg_dear))
+		db9000fb_schedule_work(fbi, C_REENABLE);
+
+	return 0;
+}
+
+/*
+ * NOTE! The following functions are purely helpers for set_ctrlr_state. Do not
+ * call them directly; set_ctrlr_state does the correct serialisation to ensure
+ * that things happen in the right way 100% of time time.
+ * -- rmk
+ */
+static inline void db9000fb_backlight_power(struct db9000fb_info *fbi, int on)
+{
+	/* Has a PWM clock been specified? */
+	if (!fbi->pwm_clock)
+		return;
+
+	fbi->reg_pwmfr &= ~DB9000_PWMFR_PWM_FCE;
+
+	if (on) {
+		fbi->reg_pwmfr |= DB9000_PWMFR_PWM_FCE;
+		lcd_writel(fbi, DB9000_PWMDCR, fbi->reg_pwmdcr);
+	} else {
+		lcd_writel(fbi, DB9000_PWMDCR, 0x0);
+	}
+
+	lcd_writel(fbi, DB9000_PWMFR, fbi->reg_pwmfr);
+}
+
+static inline void db9000fb_lcd_power(struct db9000fb_info *fbi, int on)
+{
+	fbi->reg_cr1 &= ~DB9000_CR1_LPE;
+	if (on)
+		fbi->reg_cr1 |= DB9000_CR1_LPE;
+	lcd_writel(fbi, DB9000_CR1, fbi->reg_cr1);
+}
+
+static void db9000fb_setup_gpio(struct db9000fb_info *fbi, bool on)
+{
+	int ret;
+
+	if (on) {
+		if (!IS_ERR(fbi->pins_default)) {
+			ret = pinctrl_select_state(fbi->pinctrl,
+					fbi->pins_default);
+			if (ret)
+				dev_err(&fbi->pdev->dev,
+					"could not set default pins\n");
+		}
+	} else {
+		if (!IS_ERR(fbi->pins_sleep)) {
+			ret = pinctrl_select_state(fbi->pinctrl,
+					fbi->pins_sleep);
+			if (ret)
+				dev_err(&fbi->pdev->dev,
+					"could not set pins to sleep state\n");
+		}
+	}
+}
+
+static void db9000fb_enable_controller(struct db9000fb_info *fbi)
+{
+	int i;
+	u32 val;
+	u32 isr;
+
+	pr_debug("db9000fb: Enabling LCD controller\n");
+	pr_debug("reg_cr1: 0x%08x\n", (unsigned int) fbi->reg_cr1);
+	pr_debug("reg_htr : 0x%08x\n", (unsigned int) fbi->reg_htr);
+	pr_debug("reg_vtr1: 0x%08x\n", (unsigned int) fbi->reg_vtr1);
+	pr_debug("reg_vtr2: 0x%08x\n", (unsigned int) fbi->reg_vtr2);
+	pr_debug("reg_pctr: 0x%08x\n", (unsigned int) fbi->reg_pctr);
+
+	/* enable LCD controller clock */
+	if (!fbi->clk_enabled) {
+		fbi->clk_enabled = true;
+		clk_prepare_enable(fbi->clk);
+	}
+
+	/* Write into the palette memory */
+	if (fbi->palette_size > 0) {
+		for (i = 0; i < (fbi->palette_size/2) ; ++i) {
+			val = fbi->palette[i];
+			lcd_writel(fbi, (DB9000_PALT + i*4), val);
+		}
+	}
+
+	lcd_writel(fbi, DB9000_HTR, fbi->reg_htr);
+	lcd_writel(fbi, DB9000_VTR1, fbi->reg_vtr1);
+	lcd_writel(fbi, DB9000_VTR2, fbi->reg_vtr2);
+	lcd_writel(fbi, DB9000_HVTER, fbi->reg_hvter);
+	lcd_writel(fbi, DB9000_PCTR, fbi->reg_pctr | DB9000_PCTR_PCR);
+
+	fbi->reg_dbar = fbi->fb.fix.smem_start;
+	fbi->reg_dear = fbi->reg_dbar + fbi->frame_size;
+
+	lcd_writel(fbi, DB9000_DBAR, fbi->reg_dbar);
+	lcd_writel(fbi, DB9000_DEAR, fbi->reg_dear);
+
+	/* configure MRR to 4 outstanding requests */
+	lcd_writel(fbi, DB9000_MRR,
+		DB9000_MRR_DEAR_MRR(fbi->reg_dear) |
+		DB9000_MRR_MRR(DB9000_MRR_OUTST_4));
+
+	/* enable BAU event for IRQ */
+	isr = lcd_readl(fbi, DB9000_ISR);
+	lcd_writel(fbi, DB9000_ISR, isr | DB9000_ISR_BAU);
+	lcd_writel(fbi, DB9000_IMR, DB9000_ISR_BAU);
+
+	lcd_writel(fbi, DB9000_CR1,
+		fbi->reg_cr1 | DB9000_CR1_ENB | DB9000_CR1_DEE);
+}
+
+static void db9000fb_disable_controller(struct db9000fb_info *fbi)
+{
+	u32 cr1 = lcd_readl(fbi, DB9000_CR1) & ~DB9000_CR1_ENB;
+
+	lcd_writel(fbi, DB9000_CR1, cr1);
+	msleep(100);
+
+	if (fbi->clk_enabled) {
+		fbi->clk_enabled = false;
+		clk_disable_unprepare(fbi->clk);
+	}
+}
+
+/* db9000fb_handle_irq: Handle 'LCD DONE' interrupts. */
+static irqreturn_t db9000fb_handle_irq(int irq, void *dev_id)
+{
+	struct db9000fb_info *fbi = dev_id;
+	u32 isr = lcd_readl(fbi, DB9000_ISR);
+	u32 dbar;
+
+	if (isr & DB9000_ISR_BAU) {
+		u32 imr;
+
+		/* DMA Base Address Register Update */
+		dbar = lcd_readl(fbi, DB9000_DBAR);
+		if (dbar != fbi->reg_dbar) {
+			fbi->reg_dbar = dbar;
+			fbi->reg_dear = dbar + fbi->frame_size;
+			complete(&fbi->vsync_notifier);
+		}
+
+		/* Disable Base Address Update interrupt */
+		imr = lcd_readl(fbi, DB9000_IMR);
+		lcd_writel(fbi, DB9000_IMR, imr & ~DB9000_ISR_BAU);
+	}
+
+	lcd_writel(fbi, DB9000_ISR, isr);
+	return IRQ_HANDLED;
+}
+
+/*
+ * This function must be called from task context only, since it will sleep when
+ * disabling the LCD controller, or if we get two contending processes trying to
+ * alter state.
+ */
+static void set_ctrlr_state(struct db9000fb_info *fbi, u_int state)
+{
+	u_int old_state;
+
+	mutex_lock(&fbi->ctrlr_lock);
+	old_state = fbi->state;
+
+	/* Hack around fbcon initialisation. */
+	if (old_state == C_STARTUP && state == C_REENABLE)
+		state = C_STARTUP;
+
+	switch (state) {
+	case C_DISABLE_CLKCHANGE:
+		/*
+		 * Disable controller for clock change. If the controller is
+		 * already disabled, then do nothing.
+		 */
+		if (old_state != C_DISABLE && old_state != C_DISABLE_PM) {
+			db9000fb_backlight_power(fbi, 0);
+			db9000fb_lcd_power(fbi, 0);
+			db9000fb_setup_gpio(fbi, false);
+			fbi->state = state;
+			db9000fb_disable_controller(fbi);
+		}
+		break;
+
+	case C_DISABLE_PM:
+	case C_DISABLE:
+		/* Disable controller */
+		if (old_state != C_DISABLE) {
+			fbi->state = state;
+			db9000fb_backlight_power(fbi, 0);
+			db9000fb_lcd_power(fbi, 0);
+			db9000fb_setup_gpio(fbi, false);
+			if (old_state != C_DISABLE_CLKCHANGE)
+				db9000fb_disable_controller(fbi);
+		}
+		break;
+
+	case C_ENABLE_CLKCHANGE:
+		/*
+		 * Enable the controller after clock change. Only do this if we
+		 * were disabled for the clock change.
+		 */
+		if (old_state == C_DISABLE_CLKCHANGE) {
+			fbi->state = C_ENABLE;
+			db9000fb_setup_gpio(fbi, true);
+			db9000fb_lcd_power(fbi, 1);
+			db9000fb_enable_controller(fbi);
+			/* TODO __db9000fb_lcd_power(fbi, 1); */
+		}
+		break;
+
+	case C_REENABLE:
+		/*
+		 * Re-enable the controller only if it was already enabled.
+		 * This is so we reprogram the control registers.
+		 */
+		if (old_state == C_ENABLE) {
+			db9000fb_backlight_power(fbi, 0);
+			db9000fb_lcd_power(fbi, 0);
+			db9000fb_setup_gpio(fbi, false);
+			db9000fb_disable_controller(fbi);
+			msleep(100);
+			db9000fb_setup_gpio(fbi, true);
+			db9000fb_lcd_power(fbi, 1);
+			db9000fb_enable_controller(fbi);
+			db9000fb_backlight_power(fbi, 1);
+		}
+		break;
+
+	case C_ENABLE_PM:
+		/*
+		 * Re-enable the controller after PM. This is not perfect -
+		 * think about the case where we were doing a clock change, and
+		 * we suspended half-way through.
+		 */
+		if (old_state != C_DISABLE_PM)
+			break;
+		/* fall through */
+
+	case C_ENABLE:
+		/*
+		 * Power up the LCD screen, enable controller, and turn on the
+		 * backlight.
+		 */
+		if (old_state != C_ENABLE) {
+
+			fbi->state = C_ENABLE;
+			db9000fb_setup_gpio(fbi, true);
+			db9000fb_lcd_power(fbi, 1);
+			db9000fb_enable_controller(fbi);
+			db9000fb_backlight_power(fbi, 1);
+		}
+		break;
+
+	case C_STARTUP:
+		fbi->state = C_STARTUP;
+		db9000fb_setup_gpio(fbi, true);
+		db9000fb_lcd_power(fbi, 1);
+		db9000fb_enable_controller(fbi);
+		db9000fb_backlight_power(fbi, 1);
+		msleep(100);
+		db9000fb_backlight_power(fbi, 0);
+		db9000fb_lcd_power(fbi, 0);
+		db9000fb_setup_gpio(fbi, false);
+		db9000fb_disable_controller(fbi);
+		break;
+	}
+	mutex_unlock(&fbi->ctrlr_lock);
+}
+
+/*
+ * Our LCD controller task (which is called when we blank or unblank) via
+ * keventd.
+ */
+static void db9000fb_task(struct work_struct *work)
+{
+	struct db9000fb_info *fbi =
+		container_of(work, struct db9000fb_info, task);
+	u_int state = xchg(&fbi->task_state, -1);
+
+	set_ctrlr_state(fbi, state);
+}
+
+#ifdef CONFIG_CPU_FREQ
+/*
+ * CPU clock speed change handler. We need to adjust the LCD timing parameters
+ * when the CPU clock is adjusted by the power management subsystem.
+ *
+ * TODO: Determine why f->new != 10*get_lclk_frequency_10khz()
+ */
+static int
+db9000fb_freq_transition(
+	struct notifier_block *nb, unsigned long val, void *data)
+{
+	struct db9000fb_info *fbi = TO_INF(nb, freq_transition);
+	struct fb_var_screeninfo *var = &fbi->fb.var;
+	/* TODO struct cpufreq_freqs *f = data; */
+
+	switch (val) {
+	case CPUFREQ_PRECHANGE:
+		if (!fbi->ignore_cpufreq_notification)
+			set_ctrlr_state(fbi, C_DISABLE_CLKCHANGE);
+		break;
+
+	case CPUFREQ_POSTCHANGE:
+		if (!fbi->ignore_cpufreq_notification) {
+			setup_parallel_timing(fbi, var);
+			set_ctrlr_state(fbi, C_ENABLE_CLKCHANGE);
+		}
+		break;
+	}
+	return 0;
+}
+
+/*
+ * Calculate the minimum period (in picoseconds) between two DMA requests
+ * for the LCD controller. If we hit this, it means we're doing nothing but
+ * LCD DMA.
+ */
+static unsigned int db9000fb_display_dma_period(struct fb_var_screeninfo *var)
+{
+	/*
+	 * Period = pixclock * bits_per_byte * bytes_per_transfer /
+	 * memory_bits_per_pixel;
+	 */
+	return var->pixclock * 8 * 16 / var->bits_per_pixel;
+}
+
+static int
+db9000fb_freq_policy(struct notifier_block *nb, unsigned long val, void *data)
+{
+	struct db9000fb_info *fbi = TO_INF(nb, freq_policy);
+	struct fb_var_screeninfo *var = &fbi->fb.var;
+	struct cpufreq_policy *policy = data;
+
+	switch (val) {
+	case CPUFREQ_ADJUST:
+		pr_debug("min dma period: %d ps, new clock %d kHz\n",
+			db9000fb_display_dma_period(var),
+			policy->max);
+		/* TODO: fill in min/max values */
+		break;
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+/*
+ * Power management hooks. Note that we won't be called from IRQ context, unlike
+ * the blank functions above, so we may sleep.
+ */
+static int db9000fb_suspend(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	set_ctrlr_state(fbi, C_DISABLE_PM);
+	return 0;
+}
+
+static int db9000fb_resume(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	set_ctrlr_state(fbi, C_ENABLE_PM);
+	return 0;
+}
+
+static int db9000fb_thaw(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	if (!fbi->clk_enabled) {
+		fbi->clk_enabled = true;
+		clk_prepare_enable(fbi->clk);
+	}
+
+	fbi->state = fbi->old_state;
+
+	return 0;
+}
+
+static int db9000fb_freeze(struct device *dev)
+{
+	struct db9000fb_info *fbi = dev_get_drvdata(dev);
+
+	if (fbi->clk_enabled) {
+		fbi->clk_enabled = false;
+		clk_disable_unprepare(fbi->clk);
+	}
+
+	fbi->old_state = fbi->state;
+	fbi->state = C_DISABLE_PM;
+
+	return 0;
+}
+
+static const struct dev_pm_ops db9000fb_pm_ops = {
+	.suspend	= db9000fb_suspend,
+	.resume		= db9000fb_resume,
+	.freeze		= db9000fb_freeze,
+	.thaw		= db9000fb_thaw,
+	.poweroff	= db9000fb_suspend,
+	.restore	= db9000fb_resume,
+};
+#endif
+
+static void *db9000fb_init_fbinfo(struct device *dev,
+	struct db9000fb_info *fbi)
+{
+	fbi->clk = clk_get(dev, NULL);
+	if (IS_ERR(fbi->clk))
+		return NULL;
+
+	strcpy(fbi->fb.fix.id, DRIVER_NAME);
+
+	fbi->dev = dev;
+	fbi->fb.fix.type	= FB_TYPE_PACKED_PIXELS;
+	fbi->fb.fix.type_aux	= 0;
+	fbi->fb.fix.xpanstep	= 0;
+	fbi->fb.fix.ypanstep	= 1;
+	fbi->fb.fix.ywrapstep	= 1;
+	fbi->fb.fix.accel	= FB_ACCEL_NONE;
+
+	fbi->fb.var.nonstd	= 0;
+	fbi->fb.var.activate	= FB_ACTIVATE_NOW;
+	fbi->fb.var.height	= fbi->fb.var.yres;
+	fbi->fb.var.width	= fbi->fb.var.xres;
+	fbi->fb.var.accel_flags	= 0;
+	fbi->fb.var.vmode	= FB_VMODE_NONINTERLACED;
+	fbi->fb.pseudo_palette	= fbi->cmap;
+	fbi->fb.fbops		= &db9000fb_ops;
+	fbi->fb.flags		= FBINFO_DEFAULT;
+	fbi->fb.node		= -1;
+
+	fbi->state		= C_STARTUP;
+	fbi->task_state		= (u_char)-1;
+
+	atomic_set(&fbi->usage, 0);
+	init_waitqueue_head(&fbi->ctrlr_wait);
+	INIT_WORK(&fbi->task, db9000fb_task);
+	mutex_init(&fbi->ctrlr_lock);
+	init_completion(&fbi->vsync_notifier);
+
+	return fbi;
+}
+
+static void get_backlight_pwm_clock(struct device_node *np,
+	struct db9000fb_info *fbi)
+{
+	int ret;
+	u32 pwm_clock;
+
+	ret = of_property_read_u32(np, "backlight-pwm-clock", &pwm_clock);
+	if (!ret)
+		fbi->pwm_clock = pwm_clock;
+}
+
+#if defined(CONFIG_FB_DB9000_BLINK)
+static int setup_blink_mode(struct device_node *np, struct db9000fb_info *fbi)
+{
+	int ret;
+	u32 fast_blink_ms;
+	u32 pwmfcd;
+	u32 blink_duty_cycle;
+	u32 pwmdc;
+
+	if (fbi->fb.var.bits_per_pixel != 24)
+		return 0;
+
+	ret = of_property_read_u32(np, "blink-period-ms", &fast_blink_ms);
+	if (ret)
+		return 0;
+
+	if (fast_blink_ms == 0)
+		return 0;
+
+	/* div = (pclk / 256) * fast blink period */
+	pwmfcd = clk_get_rate(fbi->pixel_clk) / 256;
+	pwmfcd *= fast_blink_ms;
+	pwmfcd /= 1000;	/* adjustment as blink period is in ms */
+
+	ret = of_property_read_u32(np, "blink-duty-cycle",
+					&blink_duty_cycle);
+	if (ret)
+		blink_duty_cycle = 50; /* default % */
+
+	if (blink_duty_cycle > 100)
+		return -EINVAL;
+
+	pwmdc = (blink_duty_cycle * 256) / 100;
+
+	lcd_writel(fbi, DB9000_PWMFR_BLINK,
+		DB9000_PWMFR_PWM_FCD(pwmfcd-1) | DB9000_PWMFR_PWM_FCE);
+	lcd_writel(fbi, DB9000_PWMDCR_BLINK, pwmdc-1);
+	lcd_writel(fbi, DB9000_GPIOR, 1);
+
+	fbi->use_blinking = true;
+
+	return 0;
+}
+#endif
+
+static int db9000fb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct db9000fb_info *fbi;
+	struct display_timings *disp_timings;
+	struct display_timing *disp_timing;
+	struct fb_videomode mode;
+	u32 bpp;
+	struct device_node *np = pdev->dev.of_node;
+	dma_addr_t fb_mem_phys;
+	unsigned long fb_mem_len;
+	void *fb_mem_virt;
+	struct resource *res;
+	int irq;
+	int ret;
+	const char *def_mode;
+
+	/* Alloc the db9000fb_info with the embedded pseudo_palette */
+	fbi = devm_kzalloc(dev, sizeof(struct db9000fb_info), GFP_KERNEL);
+	if (!fbi)
+		return -ENOMEM;
+
+	disp_timings = of_get_display_timings(np);
+	if (!disp_timings)
+		return -EINVAL;
+
+	ret = of_get_fb_videomode(np, &mode, OF_USE_NATIVE_MODE);
+	if (ret) {
+		dev_err(dev, "Could not get videomode\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np, "bits-per-pixel", &bpp);
+	if (ret) {
+		dev_err(dev, "Required bits-per-pixel property is missing\n");
+		return ret;
+	}
+
+	/* setup the timing properties */
+	disp_timing = disp_timings->timings[disp_timings->native_mode];
+	if (disp_timing->flags & DISPLAY_FLAGS_HSYNC_LOW)
+		fbi->reg_cr1 |= DB9000_CR1_HSP;
+	if (disp_timing->flags & DISPLAY_FLAGS_VSYNC_LOW)
+		fbi->reg_cr1 |= DB9000_CR1_VSP;
+	if (disp_timing->flags & DISPLAY_FLAGS_DE_HIGH)
+		fbi->reg_cr1 |= DB9000_CR1_DEP;
+
+	/* Width of RGB data going to the panel */
+	ret = of_property_read_u32(np, "bus-width", &fbi->buswidth);
+	if (ret)
+		fbi->buswidth = 24;
+
+	/* Request 16 beat burst Master Bus transactions for max performance */
+	fbi->reg_cr1 |= DB9000_CR1_FDW(2);
+
+#ifdef CONFIG_BACKLIGHT_DB9000_LCD
+	fbi->reg_pwmdcr = DEF_BRIGHTNESS;
+#endif
+
+	/* Pixel clock */
+	fbi->pixel_clk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(fbi->pixel_clk))
+		return PTR_ERR(fbi->pixel_clk);
+	ret = clk_prepare_enable(fbi->pixel_clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable pixel clock\n");
+		return ret;
+	}
+
+	/* AHB bus clock */
+	fbi->bus_clk = devm_clk_get(dev, "ahb");
+	if (IS_ERR(fbi->bus_clk))
+		return PTR_ERR(fbi->bus_clk);
+	ret = clk_prepare_enable(fbi->bus_clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable AHB clock\n");
+		return ret;
+	}
+
+	/* allocate the framebuffer. Worst case bpp in case changed later on */
+	fbi->frame_size = (mode.xres * mode.yres * 32) / 8;
+	fb_mem_len = fbi->frame_size * NUM_OF_FRAMEBUFFERS;
+
+	fb_mem_virt = dmam_alloc_coherent(dev, fb_mem_len, &fb_mem_phys,
+				GFP_KERNEL);
+	if (!fb_mem_virt) {
+		dev_err(dev, "Failed to allocate framebuffer\n");
+		return -ENOMEM;
+	}
+
+	db9000fb_init_fbinfo(dev, fbi);
+
+	/* registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
+
+	fbi->mmio_base = devm_ioremap_resource(dev, res);
+	if (!fbi->mmio_base) {
+		dev_err(dev, "failed to map I/O memory\n");
+		return -ENOMEM;
+	}
+
+	/* irq */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "no IRQ defined\n");
+		return -ENOENT;
+	}
+
+	ret = devm_request_irq(dev, irq, db9000fb_handle_irq, 0, pdev->name,
+			       fbi);
+	if (ret) {
+		dev_err(dev, "request_irq failed: %d\n", ret);
+		return ret;
+	}
+
+	/* pins */
+	fbi->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(fbi->pinctrl))
+		ret = PTR_ERR(fbi->pinctrl);
+
+	fbi->pins_default = pinctrl_lookup_state(fbi->pinctrl,
+			PINCTRL_STATE_DEFAULT);
+	if (IS_ERR(fbi->pins_default))
+		dev_err(dev, "could not get default pinstate\n");
+
+	fbi->pins_sleep = pinctrl_lookup_state(fbi->pinctrl,
+			PINCTRL_STATE_SLEEP);
+	if (IS_ERR(fbi->pins_sleep))
+		dev_dbg(dev, "could not get sleep pinstate\n");
+
+	/* other */
+	if (np) {
+		of_property_read_string(np, "st,mode", &def_mode);
+
+		if (of_get_property(np, "ignore_cpufreq_notification", NULL))
+			fbi->ignore_cpufreq_notification = true;
+	}
+
+	if (!mode_option)
+		mode_option = def_mode;
+
+	fb_videomode_to_var(&fbi->fb.var, &mode);
+
+	dev_info(dev, "got a %dx%dx%d LCD\n", fbi->fb.var.xres,
+			fbi->fb.var.yres, bpp);
+
+	/* Initialize fb_info */
+	fbi->pdev = pdev;
+	fbi->fb.screen_base	= fb_mem_virt;
+	fbi->fb.fix.smem_start	= fb_mem_phys;
+	fbi->fb.fix.smem_len	= fb_mem_len;
+	fbi->fb.var.height	= fbi->fb.var.yres;
+	fbi->fb.var.width	= fbi->fb.var.xres;
+	fbi->fb.var.bits_per_pixel = bpp;
+
+	get_backlight_pwm_clock(np, fbi);
+
+#if defined(CONFIG_FB_DB9000_BLINK)
+	ret = setup_blink_mode(np, fbi);
+	if (ret) {
+		dev_err(dev, "Failed to set blink parameters\n");
+		return ret;
+	}
+#endif
+
+	ret = db9000fb_check_var(&fbi->fb.var, &fbi->fb);
+	if (ret) {
+		dev_err(dev, "failed to get suitable mode\n");
+		goto err_free_bl;
+	}
+
+	platform_set_drvdata(pdev, fbi);
+
+	ret = register_framebuffer(&fbi->fb);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register framebuffer device:%d\n", ret);
+		goto err_clear_plat_data;
+	}
+
+#ifdef CONFIG_CPU_FREQ
+	fbi->freq_transition.notifier_call = db9000fb_freq_transition;
+	fbi->freq_policy.notifier_call = db9000fb_freq_policy;
+	cpufreq_register_notifier(&fbi->freq_transition,
+			CPUFREQ_TRANSITION_NOTIFIER);
+	cpufreq_register_notifier(&fbi->freq_policy,
+			CPUFREQ_POLICY_NOTIFIER);
+#endif
+
+	/* Read the core version register and print it out */
+	fbi->db9000_rev = lcd_readl(fbi, DB9000_CIR);
+	dev_info(dev, "Core ID reg: 0x%08X\n", fbi->db9000_rev);
+
+	ret = db9000fb_set_par(&fbi->fb);
+	if (ret) {
+		dev_err(dev, "Failed to set parameters\n");
+		goto err_clear_plat_data;
+	}
+
+	return 0;
+
+err_clear_plat_data:
+	platform_set_drvdata(pdev, NULL);
+	if (fbi->fb.cmap.len)
+		fb_dealloc_cmap(&fbi->fb.cmap);
+err_free_bl:
+	clk_put(fbi->clk);
+
+	return ret;
+}
+
+static int db9000fb_remove(struct platform_device *pdev)
+{
+	struct db9000fb_info *fbi = platform_get_drvdata(pdev);
+	struct fb_info *info;
+
+	if (!fbi)
+		return 0;
+
+	info = &fbi->fb;
+
+	unregister_framebuffer(info);
+	db9000fb_disable_controller(fbi);
+	complete_and_exit(&fbi->vsync_notifier, 0);
+
+	if (fbi->fb.cmap.len)
+		fb_dealloc_cmap(&fbi->fb.cmap);
+
+	clk_put(fbi->clk);
+
+	return 0;
+}
+
+static const struct of_device_id db9000fb_id_match[] = {
+	{ .compatible = "digitalblocks,db9000-clcd", },
+	{}
+};
+
+static struct platform_driver db9000fb_driver = {
+	.probe		= db9000fb_probe,
+	.remove		= db9000fb_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= DRIVER_NAME,
+		.of_match_table = db9000fb_id_match,
+#ifdef CONFIG_PM
+		.pm = &db9000fb_pm_ops,
+#endif
+	},
+};
+
+#ifndef MODULE
+static int __init db9000fb_setup(char *options)
+{
+	char *this_opt;
+
+	/* Parse user speficied options (`video=db9000:') */
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+		else
+			mode_option = this_opt;
+	}
+	return 0;
+}
+#endif
+
+static int __init db9000fb_init(void)
+{
+	/* For kernel boot options (in 'video=pm3fb:<options>' format) */
+#ifndef MODULE
+	char *option = NULL;
+
+	if (fb_get_options("db9000", &option))
+		return -ENODEV;
+	db9000fb_setup(option);
+#endif
+	return platform_driver_register(&db9000fb_driver);
+}
+module_init(db9000fb_init);
+
+static void __exit db9000fb_exit(void)
+{
+	platform_driver_unregister(&db9000fb_driver);
+}
+module_exit(db9000fb_exit);
+
+MODULE_DESCRIPTION("loadable framebuffer driver for Digital Blocks DB9000");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/db9000fb.h b/drivers/video/fbdev/db9000fb.h
new file mode 100644
index 0000000..7184f18
--- /dev/null
+++ b/drivers/video/fbdev/db9000fb.h
@@ -0,0 +1,234 @@
+/*
+ * linux/drivers/video/db9000fb.h
+ *    -- Digital Blocks DB9000 LCD Controller Frame Buffer Device
+ * Copyright (C) 2016 Renesas Electronics Europe Ltd.
+ * Copyright (C) 2010 Digital Blocks, Inc.
+ *
+ * Based on pxafb.h
+ * Copyright (C) 1999 Eric A. Thomas.
+ * Copyright (C) 2004 Jean-Frederic Clere.
+ * Copyright (C) 2004 Ian Campbell.
+ * Copyright (C) 2004 Jeff Lackey.
+ * Based on sa1100fb.c Copyright (C) 1999 Eric A. Thomas
+ * which in turn is
+ * Based on acornfb.c Copyright (C) Russell King.
+ *
+ *  2001-08-03: Cliff Brake <cbrake@acclent.com>
+ *	 - ported SA1100 code to PXA
+ *  2010-05-01: Guy Winter <gwinter@digitalblocks.com>
+ *  - ported pxafb code to DB9000
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+#ifndef __DB9000FB_H__
+#define __DB9000FB_H__
+
+/* LCD Controller Control Register 1 */
+#define DB9000_CR1	(0x000)
+/* Horizontal Timing Register */
+#define DB9000_HTR	(0x008)
+/* Vertical Timing Register 1 */
+#define DB9000_VTR1	(0x00C)
+/* Vertical Timing Register 2 */
+#define DB9000_VTR2	(0x010)
+/* Pixel Clock Timing Register */
+#define DB9000_PCTR	(0x014)
+/* Interrupt Status Register */
+#define DB9000_ISR	(0x018)
+/* Interrupt Mask Register */
+#define DB9000_IMR	(0x01C)
+/* Interrupt Vector Register */
+#define DB9000_IVR	(0x020)
+/* Interrupt Scan Compare Register */
+#define DB9000_ISCR	(0x024)
+/* DMA Base Address Register */
+#define DB9000_DBAR	(0x028)
+/* DMA Current Address Register */
+#define DB9000_DCAR	(0x02C)
+/* DMA End Address Register */
+#define DB9000_DEAR	(0x030)
+/* PWM Frequency Register */
+#if defined(CONFIG_FB_DB9000_BLINK)
+#define DB9000_PWMFR	(0x04c)
+#define DB9000_PWMFR_BLINK	(0x034)
+#else
+#define DB9000_PWMFR	(0x034)
+#endif
+/* PWM Duty Cycle Register */
+#if defined(CONFIG_FB_DB9000_BLINK)
+#define DB9000_PWMDCR	(0x050)
+#define DB9000_PWMDCR_BLINK	(0x038)
+#else
+#define DB9000_PWMDCR	(0x038)
+#endif
+/* DMA Frame Descriptor Branch Address Register */
+#define DB9000_DFBAR	(0x03C)
+/* DMA Frame Descriptor Last Address Register */
+#define DB9000_DFLAR	(0x040)
+/* DMA Horizontal and Vertical Timing Extension Register */
+#define DB9000_HVTER	(0x044)
+/* GPIO Register */
+#define DB9000_GPIOR	(0x1F8)
+/* Core Identification Register */
+#define DB9000_CIR	(0x1FC)
+/* Palette Data Words */
+#define DB9000_PALT	(0x200)
+
+/* Multiple Memory Reads Request Register */
+#define DB9000_MRR	(0xFFC)
+
+/* Control Register 1, Offset 0x000 */
+/* LCD Controller Enable */
+#define DB9000_CR1_ENB		(1 << 0)
+/* LCD Power Enable */
+#define DB9000_CR1_LPE		(1 << 1)
+/* LCD Bits per Pixel */
+#define DB9000_CR1_BPP(x)	(((x) & 0x7) << 2)
+/* RGB or BGR Format */
+#define DB9000_CR1_RGB		(1 << 5)
+/* Big or Little Endian Pixel Ordering */
+#define DB9000_CR1_EPO		(1 << 6)
+/* Big or Little Endian Byte Ordering  */
+#define DB9000_CR1_EBO		(1 << 7)
+/* Data Enable Polarity */
+#define DB9000_CR1_DEP		(1 << 8)
+/* Pixel Clock Polarity */
+#define DB9000_CR1_PCP		(1 << 9)
+/* Horizontal Sync Polarity */
+#define DB9000_CR1_HSP		(1 << 10)
+/* Vertical Sync Polarity */
+#define DB9000_CR1_VSP		(1 << 11)
+/* Output Pixel Select */
+#define DB9000_CR1_OPS(x)	(((x) & 0x7) << 12)
+/* FIFO DMA Request Words */
+#define DB9000_CR1_FDW(x)	(((x) & 0x3) << 16)
+/* LCD 1 or Port Select */
+#define DB9000_CR1_LPS		(1 << 18)
+/* Frame Buffer 24bpp Packed Word */
+#define DB9000_CR1_FBP		(1 << 19)
+/* DMA End Address Enable */
+#define DB9000_CR1_DEE		(1 << 20)
+/* 1 bit per pixel */
+#define DB9000_CR1_BPP_1bpp	(0)
+/* 2 bits per pixel */
+#define DB9000_CR1_BPP_2bpp	(1)
+/* 4 bits per pixel */
+#define DB9000_CR1_BPP_4bpp	(2)
+/* 8 bits per pixel */
+#define DB9000_CR1_BPP_8bpp	(3)
+/* 16 bits per pixel */
+#define DB9000_CR1_BPP_16bpp	(4)
+/* 18 bits per pixel */
+#define DB9000_CR1_BPP_18bpp	(5)
+/* 24 bits per pixel */
+#define DB9000_CR1_BPP_24bpp	(6)
+/*  Pixel clock Rising-Edge */
+#define DB9000_CR1_PixRsEdg	(DB9000_CR1_PCP*0)
+/*  Pixel clock Falling-Edge */
+#define DB9000_CR1_PixFlEdg	(DB9000_CR1_PCP*1)
+
+/* Horizontal Timing Register, Offset 0x008 */
+/* Horizontal Front Porch */
+#define DB9000_HTR_HFP(x)	(((x) & 0xff) << 0)
+/* Pixels per Line */
+#define DB9000_HTR_PPL(x)	(((x) & 0xff) << 8)
+/* Horizontal Back Porch */
+#define DB9000_HTR_HBP(x)	(((x) & 0xff) << 16)
+/* Horizontal Sync Width */
+#define DB9000_HTR_HSW(x)	(((x) & 0xff) << 24)
+
+/* Vertical Timing Register 1, Offset 0x00C */
+/* Vertical Sync Width */
+#define DB9000_VTR1_VSW(x)	(((x) & 0xff) << 0)
+/* Vertical Front Porch */
+#define DB9000_VTR1_VFP(x)	(((x) & 0xff) << 8)
+/* Vertical Back Porch */
+#define DB9000_VTR1_VBP(x)	(((x) & 0xff) << 16)
+
+/* Vertical and Horizontal Timing Extension Register, Offset 0x044 */
+/* Horizontal Front Porch Extension */
+#define DB9000_HVTER_HFPE(x)	((((x) >> 8) & 0x3) << 0)
+/* Horizontal Back Porch Extension */
+#define DB9000_HVTER_HBPE(x)	((((x) >> 8) & 0x3) << 4)
+/* Vertical Front Porch Extension */
+#define DB9000_HVTER_VFPE(x)	((((x) >> 8) & 0x3) << 8)
+/* Vertical Back Porch Extension */
+#define DB9000_HVTER_VBPE(x)	((((x) >> 8) & 0x3) << 12)
+
+/* DB9000 Revisions */
+#define DB9000_REVISION_1_14	(0x0E)
+
+/* Vertical Timing Register 2, Offset 0x010 */
+/* Lines Per Panel */
+#define DB9000_VTR2_LPP(x)	(((x) & 0xfff) << 0)
+
+/* Pixel Clock Timing Register, Offset 0x014 */
+/* Pixel Clock Divider */
+#define DB9000_PCTR_PCD(x)	(((x) & 0xff) << 0)
+/* Pixel Clock Divider Bypass */
+#define DB9000_PCTR_PCB		(1 << 8)
+/* Pixel Clock Input Select */
+#define DB9000_PCTR_PCI		(1 << 9)
+/* clock reset select */
+#define DB9000_PCTR_PCR		(1 << 10)
+
+/* Interrupt Status Register, Offset 0x018 */
+#define DB9000_ISR_OFU	(1 << 0) /* Output FIFO Underrun */
+#define DB9000_ISR_OFO	(1 << 1) /* Output FIFO Overrun */
+#define DB9000_ISR_IFU	(1 << 2) /* Input FIFO Underrun */
+#define DB9000_ISR_IFO	(1 << 3) /* Input FIFO Overrun */
+#define DB9000_ISR_FER	(1 << 4) /* OR of OFU, OFO, IFU, IFO */
+#define DB9000_ISR_MBE	(1 << 5) /* Master Bus Error */
+#define DB9000_ISR_VCT	(1 << 6) /* Vertical Compare Triggered */
+#define DB9000_ISR_BAU	(1 << 7) /* DMA Base Address Register Update to CAR */
+#define DB9000_ISR_LDD	(1 << 8) /* LCD Controller Disable Done */
+
+#define DB9000_ISR_ABL	(1 << 9) /* AXI Master - Read Burst Length Error */
+#define DB9000_ISR_ARI	(1 << 10) /* AXI Master - Return ID Error */
+#define DB9000_ISR_ARS	(1 << 11) /* AXI Master - Response Signal Error */
+
+#define DB9000_ISR_FBE	(1 << 12) /* Frame Descriptor - Bus Error */
+#define DB9000_ISR_FNC	(1 << 13) /* Frame Descriptor - Node Complete */
+#define DB9000_ISR_FLC	(1 << 14) /* Frame Descriptor - List Complete */
+
+/* Interrupt Mask Register, Offset 0x01C */
+#define DB9000_ISR_OFUM	(1 << 0)  /* Output FIFO Underrun - Mask */
+#define DB9000_ISR_OFOM	(1 << 1)  /* Output FIFO Overrun - Mask */
+#define DB9000_ISR_IFUM	(1 << 2)  /* Input FIFO Underrun - Mask */
+#define DB9000_ISR_IFOM	(1 << 3)  /* Input FIFO Overrun - Mask */
+#define DB9000_ISR_FERM	(1 << 4)  /* OR of OFU, OFO, IFU, IFO - Mask */
+#define DB9000_ISR_MBEM	(1 << 5)  /* Master Bus Error - Mask */
+#define DB9000_ISR_VCTM	(1 << 6)  /* Vertical Compare Triggered - Mask */
+/* DMA Base Address Register Update to CAR - Mask */
+#define DB9000_ISR_BAUM	(1 << 7)
+#define DB9000_ISR_LDDM	(1 << 8)  /* LCD Controller Disable Done - Mask */
+
+/* AXI Master - Read Burst Length Error - Mask */
+#define DB9000_ISR_ABLM	(1 << 9)
+/* AXI Master - Return ID Error - Mask */
+#define DB9000_ISR_ARIM	(1 << 10)
+/* AXI Master - Response Signal Error - Mask */
+
+#define DB9000_ISR_ARSM	(1 << 11)
+#define DB9000_ISR_FBEM	(1 << 12) /* Frame Descriptor - Bus Error - Mask */
+#define DB9000_ISR_FNCM	(1 << 13) /* Frame Descriptor - Node Complete - Mask */
+#define DB9000_ISR_FLCM	(1 << 14) /* Frame Descriptor - List Complete - Mask */
+
+/* PWM Frequency Registers, Offset 0x034 and 0x04c */
+#define DB9000_PWMFR_PWM_FCD(x)	(((x) & 0x3fffff) << 0)
+#define DB9000_PWMFR_PWM_FCE	(1 << 22)
+
+/* PWM Duty Cycle Registers, Offset 0x038 and 0x050 */
+#define DB9000_PWMDCR_DCR(x)	((x) & 0xff)
+
+/* Multiple Memory Reads Request Register, offset 0xFFC */
+#define DB9000_MRR_MRR(x)	(((x) & 0x3) << 0)
+#define DB9000_MRR_DEAR_MRR(x)	((x) & 0xFFFFFFFC)
+#define DB9000_MRR_OUTST_0	0x0
+#define DB9000_MRR_OUTST_2	0x1
+#define DB9000_MRR_OUTST_4	0x2
+
+#endif /* __DB9000FB_H__ */
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 3eb58cb..27ee973 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -452,6 +452,14 @@ config RN5T618_WATCHDOG
 	  This driver can also be built as a module.  If so, the module
 	  will be called rn5t618_wdt.
 
+config RZN1_WATCHDOG
+	tristate "Renesas RZ/N1 watchdogsafe"
+	depends on ARCH_RZN1
+	default y if ARCH_RZN1
+	select WATCHDOG_CORE
+	help
+	  Support for the Renesas RZ/N1 WatchdogSafe timer.
+
 config SUNXI_WATCHDOG
 	tristate "Allwinner SoCs watchdog support"
 	depends on ARCH_SUNXI
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index caa9f4a..1517ffc 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -58,6 +58,7 @@ obj-$(CONFIG_DAVINCI_WATCHDOG) += davinci_wdt.o
 obj-$(CONFIG_ORION_WATCHDOG) += orion_wdt.o
 obj-$(CONFIG_SUNXI_WATCHDOG) += sunxi_wdt.o
 obj-$(CONFIG_RN5T618_WATCHDOG) += rn5t618_wdt.o
+obj-$(CONFIG_RZN1_WATCHDOG) += rzn1_wdtsafe.o
 obj-$(CONFIG_COH901327_WATCHDOG) += coh901327_wdt.o
 obj-$(CONFIG_STMP3XXX_RTC_WATCHDOG) += stmp3xxx_rtc_wdt.o
 obj-$(CONFIG_NUC900_WATCHDOG) += nuc900_wdt.o
diff --git a/drivers/watchdog/rzn1_wdtsafe.c b/drivers/watchdog/rzn1_wdtsafe.c
new file mode 100644
index 0000000..653577c
--- /dev/null
+++ b/drivers/watchdog/rzn1_wdtsafe.c
@@ -0,0 +1,304 @@
+/*
+ * Renesas RZ/N1 Watchdog timer
+ *
+ * Copyright 2015-2016 Renesas Electronics Europe Ltd.
+ * Author: Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>
+ *
+ * Derived from Ralink RT288x watchdog timer.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/watchdog.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_irq.h>
+#include <linux/clk.h>
+
+/*
+ * Auto-generated from WATCHDOG1_register_map_d1_0v59_ipxact.xml
+ */
+#define RZN1_WATCHDOG_LOADMAXCOUNT		0x0
+#define RZN1_WATCHDOG_LOADMAXCOUNT_BLOADMAXCOUNT	0
+#define RZN1_WATCHDOG_LOADMAXCOUNT_BLOADMAXCOUNT_MASK	0xffff
+#define RZN1_WATCHDOG_CURRENTMAXCOUNT		0x4
+#define RZN1_WATCHDOG_CURRENTMAXCOUNT_BCURRENTMAXCOUNT	0
+#define RZN1_WATCHDOG_CURRENTMAXCOUNT_BCURRENTMAXCOUNT_MASK	0xffff
+#define RZN1_WATCHDOG_LOADMINCOUNT		0x8
+#define RZN1_WATCHDOG_LOADMINCOUNT_BLOADMINCOUNT	0
+#define RZN1_WATCHDOG_LOADMINCOUNT_BLOADMINCOUNT_MASK	0xffff
+#define RZN1_WATCHDOG_CURRENTMINCOUNT		0xc
+#define RZN1_WATCHDOG_CURRENTMINCOUNT_BCURRENTMINCOUNT	0
+#define RZN1_WATCHDOG_CURRENTMINCOUNT_BCURRENTMINCOUNT_MASK	0xffff
+#define RZN1_WATCHDOG_STATUSINT0		0x10
+#define RZN1_WATCHDOG_STATUSINT0_BSTATUSINT0		0
+#define RZN1_WATCHDOG_STATUSINT1		0x14
+#define RZN1_WATCHDOG_STATUSINT1_BSTATUSINT1		0
+#define RZN1_WATCHDOG_CLEARINT			0x18
+#define RZN1_WATCHDOG_CLEARINT_BCLEARINT		0
+#define RZN1_WATCHDOG_CONTROL			0x1c
+#define RZN1_WATCHDOG_CONTROL_BMASKINT			0
+#define RZN1_WATCHDOG_STATUS			0x20
+#define RZN1_WATCHDOG_STATUS_BEN			0
+#define RZN1_WATCHDOG_STATUS_BENABLE			1
+#define RZN1_WATCHDOG_STATUS_BPADTEST			2
+#define RZN1_WATCHDOG_STATUS_BTRIGGER			3
+#define RZN1_WATCHDOG_STATUS_BTIMEOUT			4
+#define RZN1_WATCHDOG_STATUS_BENABLERESET		5
+#define RZN1_WATCHDOG_STATUS_BENABLEREFRESH		6
+#define RZN1_WATCHDOG_STATUS_BBADSEQUENCE		7
+#define RZN1_WATCHDOG_STATUS_BSTATUS			8
+#define RZN1_WATCHDOG_STATUS_BRESET			9
+#define RZN1_WATCHDOG_STATUS_BFORCEEN			10
+#define RZN1_WATCHDOG_STATUS_BFORCESTATUS		11
+#define RZN1_WATCHDOG_STATUS_BTESTMODE			12
+#define RZN1_WATCHDOG_REFRESH			0x24
+#define RZN1_WATCHDOG_SETENABLEREFRESH		0x28
+#define RZN1_WATCHDOG_CLEARENABLEREFRESH	0x2c
+#define RZN1_WATCHDOG_SETENABLERESET		0x30
+#define RZN1_WATCHDOG_CLEARENABLERESET		0x34
+#define RZN1_WATCHDOG_SETTRIGGER		0x38
+#define RZN1_WATCHDOG_SETPADTEST		0x3c
+#define RZN1_WATCHDOG_CLEARPADTEST		0x40
+#define RZN1_WATCHDOG_SETENABLE			0x44
+#define RZN1_WATCHDOG_CLEARENABLE		0x48
+#define RZN1_WATCHDOG_SETTESTMODE		0x4c
+#define RZN1_WATCHDOG_CLEARTESTMODE		0x50
+#define RZN1_WATCHDOG_SETFORCEEN		0x54
+#define RZN1_WATCHDOG_CLEARFORCEEN		0x58
+#define RZN1_WATCHDOG_SETFORCESTATUS		0x5c
+#define RZN1_WATCHDOG_CLEARFORCESTATUS		0x60
+
+#define RZN1_WATCHDOG_REGSIZE			100
+
+struct rzn1_watchdog {
+	struct watchdog_device 		wdt;
+	struct device			*dev;
+	void __iomem 			*base;
+	unsigned int			irq;
+};
+
+#define to_rzn1_watchdog(_ptr) \
+	container_of(_ptr, struct rzn1_watchdog, wdt)
+
+
+static int rzn1_wdt_ping(struct watchdog_device *w)
+{
+	struct rzn1_watchdog *wdt = to_rzn1_watchdog(w);
+
+	writel(0x3456789a,
+		wdt->base + RZN1_WATCHDOG_REFRESH);
+
+	return 0;
+}
+
+static int rzn1_wdt_start(struct watchdog_device *w)
+{
+	struct rzn1_watchdog *wdt = to_rzn1_watchdog(w);
+
+	writel((1 << RZN1_WATCHDOG_CONTROL_BMASKINT),
+		wdt->base + RZN1_WATCHDOG_CONTROL);
+
+	writel(0x6789abcd,
+		wdt->base + RZN1_WATCHDOG_SETENABLERESET);
+
+	writel(0xbcdef012,
+		wdt->base + RZN1_WATCHDOG_SETENABLE);
+
+	return 0;
+}
+
+static int rzn1_wdt_stop(struct watchdog_device *w)
+{
+	struct rzn1_watchdog *wdt = to_rzn1_watchdog(w);
+
+	writel(0, wdt->base + RZN1_WATCHDOG_CONTROL);
+	writel(0xcdef0123,
+		wdt->base + RZN1_WATCHDOG_CLEARENABLE);
+
+	return 0;
+}
+
+static int rzn1_wdt_set_timeout(struct watchdog_device *w, unsigned int t)
+{
+	struct rzn1_watchdog *wdt = to_rzn1_watchdog(w);
+
+	w->timeout = t;
+	t = (t * 1000) | ((~(t * 1000)) << 16);
+
+	writel(0x56789abc,
+		wdt->base + RZN1_WATCHDOG_CLEARENABLEREFRESH);
+	writel(t,
+		wdt->base + RZN1_WATCHDOG_LOADMAXCOUNT);
+	writel(0x456789ab,
+		wdt->base + RZN1_WATCHDOG_SETENABLEREFRESH);
+	rzn1_wdt_ping(w);
+
+	return 0;
+}
+
+static irqreturn_t rzn1_wdtsafe_irq(int irq, void *_wdt)
+{
+	struct rzn1_watchdog *wdt = (struct rzn1_watchdog *)_wdt;
+
+	dev_info(wdt->dev, "%s triggered\n", __func__);
+	readl(wdt->base + RZN1_WATCHDOG_CLEARINT);
+	return IRQ_HANDLED;
+}
+
+
+static struct watchdog_info rzn1_wdt_info = {
+	.identity = "RZ/N1 Watchdog",
+	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
+};
+
+static const struct watchdog_ops rzn1_wdt_ops = {
+	.owner = THIS_MODULE,
+	.start = rzn1_wdt_start,
+	.stop = rzn1_wdt_stop,
+	.ping = rzn1_wdt_ping,
+	.set_timeout = rzn1_wdt_set_timeout,
+};
+
+static const struct watchdog_device rzn1_wdt_dev = {
+	.info = &rzn1_wdt_info,
+	.ops = &rzn1_wdt_ops,
+	.min_timeout = 1,
+	.max_timeout = 65,
+};
+
+static ssize_t status_show(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct rzn1_watchdog *wdt = platform_get_drvdata(
+						to_platform_device(dev));
+	u32 status = readl(wdt->base + RZN1_WATCHDOG_STATUS);
+
+	return sprintf(buf, "status: %08x max:%d/%d min:%d "
+			"%s%s%s%s%s%s%s%s%s%s\n", status,
+		readl(wdt->base + RZN1_WATCHDOG_CURRENTMAXCOUNT),
+		readl(wdt->base + RZN1_WATCHDOG_LOADMAXCOUNT),
+		readl(wdt->base + RZN1_WATCHDOG_CURRENTMINCOUNT),
+		status & (1 << RZN1_WATCHDOG_STATUS_BEN) ? "EN " : "",
+		status & (1 << RZN1_WATCHDOG_STATUS_BENABLE) ? "ENABLE " : "",
+		status & (1 << RZN1_WATCHDOG_STATUS_BTRIGGER) ? "TRIGGER " : "",
+		status & (1 << RZN1_WATCHDOG_STATUS_BTIMEOUT) ? "TIMEOUT " : "",
+		status & (1 << RZN1_WATCHDOG_STATUS_BENABLERESET) ? "RESET " : "",
+		status & (1 << RZN1_WATCHDOG_STATUS_BENABLEREFRESH) ? "REFRESH " : "",
+		status & (1 << RZN1_WATCHDOG_STATUS_BBADSEQUENCE) ? "BADSEQ " : "",
+		status & (1 << RZN1_WATCHDOG_STATUS_BSTATUS) ? "WATCHPIN " : "",
+		status & (1 << RZN1_WATCHDOG_STATUS_BRESET) ? "RESETPIN " : "",
+		status & (1 << RZN1_WATCHDOG_STATUS_BFORCEEN) ? "FORCE " : "");
+}
+static DEVICE_ATTR_RO(status);
+
+static struct attribute *wdt_attrs[] = {
+	&dev_attr_status.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(wdt);
+
+static int rzn1_wdt_probe(struct platform_device *ofdev)
+{
+	struct rzn1_watchdog *wdt;
+	int ret;
+	struct device_node *np = ofdev->dev.of_node;
+	int error;
+	struct clk *clk;
+
+	wdt = devm_kzalloc(&ofdev->dev, sizeof(*wdt), GFP_KERNEL);
+	if (wdt == NULL)
+		return -ENOMEM;
+	wdt->dev = &ofdev->dev;
+	wdt->wdt = rzn1_wdt_dev;
+
+	wdt->base  = of_iomap(np, 0);
+	if (IS_ERR(wdt->base)) {
+		dev_err(wdt->dev, "unable to get register bank\n");
+		return PTR_ERR(wdt->base);
+	}
+	wdt->irq = irq_of_parse_and_map(np, 0);
+	if (wdt->irq == NO_IRQ) {
+		pr_err("%s:%s failed to map interrupts\n",
+			__func__, np->full_name);
+		goto err_noirq;
+	}
+
+	error = devm_request_irq(wdt->dev, wdt->irq, rzn1_wdtsafe_irq, 0,
+				np->name, wdt);
+	if (error) {
+		dev_err(wdt->dev, "cannot request irq %d err %d\n",
+				wdt->irq, error);
+		goto err_noirq;
+	}
+	clk = devm_clk_get(wdt->dev, NULL);
+	if (!IS_ERR(clk) && clk_prepare_enable(clk))
+		dev_info(wdt->dev, "no clock source\n");
+
+	watchdog_init_timeout(&wdt->wdt, wdt->wdt.max_timeout,
+			      &ofdev->dev);
+
+	ret = watchdog_register_device(&wdt->wdt);
+	if (ret)
+		goto error;
+
+	platform_set_drvdata(ofdev, wdt);
+	sysfs_create_groups(&wdt->dev->kobj, wdt_groups);
+	dev_info(wdt->dev, "Initialized\n");
+
+	return 0;
+err_noirq:
+error:
+	dev_warn(wdt->dev, "Initialization failed\n");
+	return -1;
+}
+
+static int rzn1_wdt_remove(struct platform_device *ofdev)
+{
+	struct rzn1_watchdog *wdt = platform_get_drvdata(ofdev);
+
+	watchdog_unregister_device(&wdt->wdt);
+
+	return 0;
+}
+
+static void rzn1_wdt_shutdown(struct platform_device *ofdev)
+{
+	struct rzn1_watchdog *wdt = platform_get_drvdata(ofdev);
+
+	rzn1_wdt_stop(&wdt->wdt);
+}
+
+static const struct of_device_id rzn1_wdt_match[] = {
+	{ .compatible = "renesas,rzn1-watchdogsafe" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rzn1_wdt_match);
+
+static struct platform_driver rzn1_wdt_driver = {
+	.probe		= rzn1_wdt_probe,
+	.remove		= rzn1_wdt_remove,
+	.shutdown	= rzn1_wdt_shutdown,
+	.driver		= {
+		.name		= KBUILD_MODNAME,
+		.of_match_table	= rzn1_wdt_match,
+	},
+};
+
+module_platform_driver(rzn1_wdt_driver);
+
+MODULE_DESCRIPTION("Renesas RZ/N1 hardware watchdog");
+MODULE_AUTHOR("Michel Pollet <michel.pollet@bp.renesas.com>,<buserror@gmail.com>");
+MODULE_LICENSE("GPL v2");
+
diff --git a/include/dt-bindings/clock/rzn1-clocks.h b/include/dt-bindings/clock/rzn1-clocks.h
new file mode 100644
index 0000000..51507f3
--- /dev/null
+++ b/include/dt-bindings/clock/rzn1-clocks.h
@@ -0,0 +1,183 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_CLOCKS_H__
+#define __RZN1_CLOCKS_H__
+
+#define RZN1_CLKDIV_PGEXT2_PR6			0
+#define RZN1_CLKDIV_QSPI2			1
+#define RZN1_CLKDIV_SWITCH			2
+#define RZN1_CLKDIV_OPP				3
+#define RZN1_CLKDIV_CA7				4
+#define RZN1_CLKDIV_PG1_PR2			5
+#define RZN1_CLKDIV_PG1_PR3			6
+#define RZN1_CLKDIV_PG1_PR4			7
+#define RZN1_CLKDIV_PG4_PR1			8
+#define RZN1_CLKDIV_PG5_PR5			9
+#define RZN1_CLKDIV_QSPI1			10
+#define RZN1_CLKDIV_SDIO1			11
+#define RZN1_CLKDIV_SDIO2			12
+#define RZN1_CLKDIV_PG0_ADC			13
+#define RZN1_CLKDIV_PG0_I2C			14
+#define RZN1_CLKDIV_PG0_UART			15
+#define RZN1_CLKDIV_NFLASH			16
+#define RZN1_CLKDIV_PG0_MOTOR			17
+#define RZN1_CLKDIV_HWRTOS_MDC			18
+
+#define RZN1_HCLK_SDIO0_ID			0
+#define RZN1_CLK_SDIO0_ID			1
+#define RZN1_HCLK_USBH_ID			2
+#define RZN1_HCLK_USBF_ID			3
+#define RZN1_HCLK_USBPM_ID			4
+#define RZN1_CLK_PCI_USB_ID			5
+#define RZN1_HCLK_CRYPTO_EIP93_ID		6
+#define RZN1_HCLK_CRYPTO_EIP150_ID		7
+#define RZN1_HCLK_MSEBI_S_ID			8
+#define RZN1_HCLK_MSEBI_M_ID			9
+#define RZN1_HCLK_UART0_ID			10
+#define RZN1_HCLK_UART1_ID			11
+#define RZN1_HCLK_UART2_ID			12
+#define RZN1_HCLK_I2C0_ID			13
+#define RZN1_HCLK_I2C1_ID			14
+#define RZN1_HCLK_ADC_ID			15
+#define RZN1_CLK_UART0_ID			16
+#define RZN1_CLK_USBUART0_ID			17
+#define RZN1_CLK_UART1_ID			18
+#define RZN1_CLK_USBUART1_ID			19
+#define RZN1_CLK_UART2_ID			20
+#define RZN1_CLK_USBUART2_ID			21
+#define RZN1_CLK_I2C0_ID			22
+#define RZN1_CLK_I2C1_ID			23
+#define RZN1_CLK_ADC_ID				24
+#define RZN1_HCLK_SGPIO0_ID			25
+#define RZN1_HCLK_SGPIO1_ID			26
+#define RZN1_HCLK_PWMPTO_ID			27
+#define RZN1_HCLK_DELTASIGMA_ID			28
+#define RZN1_HCLK_SPI0_ID			29
+#define RZN1_HCLK_SPI1_ID			30
+#define RZN1_HCLK_SPI2_ID			31
+#define RZN1_HCLK_SPI3_ID			32
+#define RZN1_HCLK_SPI4_ID			33
+#define RZN1_HCLK_SPI5_ID			34
+#define RZN1_HCLK_GPIO0_ID			35
+#define RZN1_HCLK_GPIO1_ID			36
+#define RZN1_HCLK_UART3_ID			37
+#define RZN1_HCLK_UART4_ID			38
+#define RZN1_HCLK_UART5_ID			39
+#define RZN1_HCLK_UART6_ID			40
+#define RZN1_HCLK_UART7_ID			41
+#define RZN1_HCLK_GPIO2_ID			42
+#define RZN1_HCLK_PG19_ID			43
+#define RZN1_HCLK_PG20_ID			44
+#define RZN1_HCLK_DMA0_ID			45
+#define RZN1_HCLK_DMA1_ID			46
+#define RZN1_HCLK_NAND_ID			47
+#define RZN1_CLK_NAND_ID			48
+#define RZN1_HCLK_QSPI0_ID			49
+#define RZN1_CLK_QSPI0_ID			50
+#define RZN1_HCLK_DDRC_ID			51
+#define RZN1_CLK_DDRC_ID			52
+#define RZN1_CLK_RGMII_REF_ID			53
+#define RZN1_CLK_RMII_REF_ID			54
+#define RZN1_CLK_MII_REF_ID			55
+#define RZN1_HCLK_GMAC0_ID			56
+#define RZN1_HCLK_GMAC1_ID			57
+#define RZN1_HCLK_ECAT125_ID			58
+#define RZN1_CLK_ECAT25_ID			59
+#define RZN1_CLK_ECAT100_ID			60
+#define RZN1_HCLK_SERCOS_ID			61
+#define RZN1_CLK_SERCOS50_ID			62
+#define RZN1_CLK_SERCOS100_ID			63
+#define RZN1_HCLK_QSPI1_ID			64
+#define RZN1_CLK_QSPI1_ID			65
+#define RZN1_HCLK_HSR_ID			66
+#define RZN1_CLK_HSR_DUP_ID			67
+#define RZN1_CLK_HSR50_ID			68
+#define RZN1_HCLK_SDIO1_ID			69
+#define RZN1_CLK_SDIO1_ID			70
+#define RZN1_HCLK_PINCONFIG_ID			71
+#define RZN1_HCLK_TIMER0_ID			72
+#define RZN1_HCLK_TIMER1_ID			73
+#define RZN1_CLK_25MHZ_PG4_ID			74
+#define RZN1_CLK_25MHZ_PG5_ID			75
+#define RZN1_CLK_25MHZ_PG6_ID			76
+#define RZN1_CLK_25MHZ_PG7_ID			77
+#define RZN1_CLK_25MHZ_PG8_ID			78
+#define RZN1_CLK_UART3_ID			79
+#define RZN1_CLK_USBUART3_ID			80
+#define RZN1_CLK_UART4_ID			81
+#define RZN1_CLK_USBUART4_ID			82
+#define RZN1_CLK_UART5_ID			83
+#define RZN1_CLK_USBUART5_ID			84
+#define RZN1_CLK_UART6_ID			85
+#define RZN1_CLK_USBUART6_ID			86
+#define RZN1_CLK_UART7_ID			87
+#define RZN1_CLK_USBUART7_ID			88
+#define RZN1_CLK_NOUSBP2_PG6_ID			89
+#define RZN1_CLK_USBP2_PG6_ID			90
+#define RZN1_HCLK_CAN1_ID			91
+#define RZN1_CLK_48MHZ_PG4_ID			92
+#define RZN1_CLK_48MHZ_PG_F_ID			93
+#define RZN1_HCLK_RSV_ID			94
+#define RZN1_HCLK_CAN0_ID			95
+#define RZN1_HCLK_LCD_ID			96
+#define RZN1_HCLK_SEMAP_ID			97
+#define RZN1_HCLK_PG3_ID			98
+#define RZN1_HCLK_PG4_ID			99
+#define RZN1_HCLK_PG_I_ID			100
+#define RZN1_CLK_SPI0_ID			101
+#define RZN1_CLK_SPI1_ID			102
+#define RZN1_CLK_SPI2_ID			103
+#define RZN1_CLK_SPI3_ID			104
+#define RZN1_CLK_SPI4_ID			105
+#define RZN1_CLK_SPI5_ID			106
+#define RZN1_CLK_P4_PG3_ID			107
+#define RZN1_CLK_P4_PG4_ID			108
+#define RZN1_CLK_SLCD_ID			109
+#define RZN1_CLK_P1_PG2_ID			110
+#define RZN1_CLK_P1_PG3_ID			111
+#define RZN1_CLK_P1_PG4_ID			112
+#define RZN1_CLK_P6_PG1_ID			113
+#define RZN1_CLK_P6_PG2_ID			114
+#define RZN1_CLK_P6_PG3_ID			115
+#define RZN1_CLK_P6_PG4_ID			116
+#define RZN1_HCLK_SGPIO2_ID			117
+#define RZN1_HCLK_SGPIO3_ID			118
+#define RZN1_HCLK_SGPIO4_ID			119
+#define RZN1_HCLK_SWITCH_ID			120
+#define RZN1_CLK_SWITCH_ID			121
+#define RZN1_HCLK_RTC_ID			122
+#define RZN1_HCLK_ROM_ID			123
+#define RZN1_CLK_CM3_ID				124
+#define RZN1_HCLK_CM3_ID			125
+#define RZN1_HCLK_SWITCH_RG_ID			126
+#define RZN1_CLK_HW_RTOS_ID			127
+#define RZN1_CLK_RTOS_MDC_ID			128
+
+#endif /* __RZN1_CLOCKS_H__ */
diff --git a/include/dt-bindings/interrupt-controller/rzn1-irq.h b/include/dt-bindings/interrupt-controller/rzn1-irq.h
new file mode 100644
index 0000000..f0d379c
--- /dev/null
+++ b/include/dt-bindings/interrupt-controller/rzn1-irq.h
@@ -0,0 +1,169 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_IRQ_H__
+#define __RZN1_IRQ_H__
+
+#define RZN1_IRQ_ADC			0
+#define RZN1_IRQ_I2C0			1
+#define RZN1_IRQ_I2C1			2
+#define RZN1_IRQ_SAFETY_FILTERING	3
+#define RZN1_IRQ_SGPIO0			4
+#define RZN1_IRQ_SGPIO1			5
+#define RZN1_IRQ_UART0			6
+#define RZN1_IRQ_UART1			7
+#define RZN1_IRQ_UART2			8
+#define RZN1_IRQ_DELTASIGMA		9
+#define RZN1_IRQ_PWMPTO			10
+#define RZN1_IRQ_ECC_4MB		11
+#define RZN1_IRQ_ECC_2MB		12
+#define RZN1_IRQ_CM3_LOCKUP		13
+#define RZN1_IRQ_CM3_TRING_0		14
+#define RZN1_IRQ_CM3_TRING_1		15
+#define RZN1_IRQ_HWRTOS_BRAMERR		16
+#define RZN1_IRQ_HWRTOS_BUFDMA		17
+#define RZN1_IRQ_HWRTOS_BUFDMAERR	18
+#define RZN1_IRQ_HWRTOS_ETHMII		19
+#define RZN1_IRQ_HWRTOS_ETHPAUSE	20
+#define RZN1_IRQ_HWRTOS_ETHRXDERR	21
+#define RZN1_IRQ_HWRTOS_ETHRXDMA	22
+#define RZN1_IRQ_HWRTOS_ETHRXERR	23
+#define RZN1_IRQ_HWRTOS_ETHRXFIFO	24
+#define RZN1_IRQ_HWRTOS_ETHTX		25
+#define RZN1_IRQ_HWRTOS_ETHTXDERR	26
+#define RZN1_IRQ_HWRTOS_ETHTXDMA	27
+#define RZN1_IRQ_HWRTOS_ETHTXFIFO	28
+#define RZN1_IRQ_HWRTOS_ETHTXFIFOERR	29
+#define RZN1_IRQ_HWRTOS			30
+#define RZN1_IRQ_HWRTOS_MACDMARXFRM	31
+#define RZN1_IRQ_HWRTOS_TM_LPI_AST	32
+#define RZN1_IRQ_HWRTOS_TM_LPI_DEAST	33
+#define RZN1_IRQ_SBD0			34
+#define RZN1_IRQ_LPI0			35
+#define RZN1_IRQ_PMT0			36
+#define RZN1_IRQ_SBD1			37
+#define RZN1_IRQ_LPI1			38
+#define RZN1_IRQ_PMT1			39
+#define RZN1_IRQ_SWITCHDLR		40
+#define RZN1_IRQ_SWITCH			42
+#define RZN1_IRQ_SWITCHPRP		43
+#define RZN1_IRQ_ETHSWHUB		44
+#define RZN1_IRQ_ETHSWPTRN		45
+#define RZN1_IRQ_CAT_RST		46
+#define RZN1_IRQ_CAT_SYNC_0		47
+#define RZN1_IRQ_CAT_SYNC_1		48
+#define RZN1_IRQ_CAT_WDT		49	/* shared */
+#define RZN1_IRQ_S3_DIVCLK		49	/* shared */
+#define RZN1_IRQ_CAT_EOF		50	/* shared */
+#define RZN1_IRQ_S3_CONCLK		50	/* shared */
+#define RZN1_IRQ_HSR_PTP		50	/* shared */
+#define RZN1_IRQ_CAT_SOF		51	/* shared */
+#define RZN1_IRQ_S3_0			51	/* shared */
+#define RZN1_IRQ_HSR_CPU		51	/* shared */
+#define RZN1_IRQ_CAT			52	/* shared */
+#define RZN1_IRQ_S3_1			52	/* shared */
+#define RZN1_IRQ_NOCFIREWALL		53
+#define RZN1_IRQ_CRYPTO0		54
+#define RZN1_IRQ_CRYPTO1		55
+#define RZN1_IRQ_DMA0			56
+#define RZN1_IRQ_DMA1			57
+#define RZN1_IRQ_NAND			58
+#define RZN1_IRQ_IPCM_0			59
+#define RZN1_IRQ_IPCM_1			60
+#define RZN1_IRQ_IPCM_2			61
+#define RZN1_IRQ_MSEBIM			62
+#define RZN1_IRQ_MSEBIS			63
+#define RZN1_IRQ_QSPI0			64
+#define RZN1_IRQ_QSPI1			65
+#define RZN1_IRQ_RTCATINTAL		66
+#define RZN1_IRQ_RTCATINTR		67
+#define RZN1_IRQ_RTCATINT1S		68
+#define RZN1_IRQ_SDIO0			69
+#define RZN1_IRQ_SDIO0_WKUP		70
+#define RZN1_IRQ_SDIO1			71
+#define RZN1_IRQ_SDIO1_WKUP		72
+#define RZN1_IRQ_WATCHDOG_RESETN_0	73
+#define RZN1_IRQ_WATCHDOG_RESETN_1	74
+#define RZN1_IRQ_WATCHDOG_CM3_RESETN	75
+#define RZN1_IRQ_DDRSUB			76
+#define RZN1_IRQ_USBF_EPC		77
+#define RZN1_IRQ_USBF			78
+#define RZN1_IRQ_USBH_BIND		79
+#define RZN1_IRQ_SPI0			80
+#define RZN1_IRQ_SPI1			81
+#define RZN1_IRQ_SPI2			82
+#define RZN1_IRQ_SPI3			83
+#define RZN1_IRQ_SPI4			84
+#define RZN1_IRQ_SPI5			85
+#define RZN1_IRQ_UART3			86
+#define RZN1_IRQ_UART4			87
+#define RZN1_IRQ_UART5			88
+#define RZN1_IRQ_UART6			89
+#define RZN1_IRQ_UART7			90
+#define RZN1_IRQ_SGPIO2			91
+#define RZN1_IRQ_SGPIO3			92
+#define RZN1_IRQ_SGPIO4			93
+#define RZN1_IRQ_RSV			94
+#define RZN1_IRQ_CAN0			95
+#define RZN1_IRQ_CAN1			96
+#define RZN1_IRQ_LCD			97
+#define RZN1_IRQ_WATCHDOGSAFE0		100
+#define RZN1_IRQ_WATCHDOGSAFE1		101
+#define RZN1_IRQ_RESET			102
+#define RZN1_IRQ_GPIO_0			103
+#define RZN1_IRQ_GPIO_1			104
+#define RZN1_IRQ_GPIO_2			105
+#define RZN1_IRQ_GPIO_3			106
+#define RZN1_IRQ_GPIO_4			107
+#define RZN1_IRQ_GPIO_5			108
+#define RZN1_IRQ_GPIO_6			109
+#define RZN1_IRQ_GPIO_7			110
+#define RZN1_IRQ_TIMER0_0		112
+#define RZN1_IRQ_TIMER0_1		113
+#define RZN1_IRQ_TIMER0_2		114
+#define RZN1_IRQ_TIMER0_3		115
+#define RZN1_IRQ_TIMER0_4		116
+#define RZN1_IRQ_TIMER0_5		117
+#define RZN1_IRQ_TIMER0_6		118
+#define RZN1_IRQ_TIMER0_7		119
+#define RZN1_IRQ_TIMER1_0		120
+#define RZN1_IRQ_TIMER1_1		121
+#define RZN1_IRQ_TIMER1_2		122
+#define RZN1_IRQ_TIMER1_3		123
+#define RZN1_IRQ_TIMER1_4		124
+#define RZN1_IRQ_TIMER1_5		125
+#define RZN1_IRQ_TIMER1_6		126
+#define RZN1_IRQ_TIMER1_7		127
+#define RZN1_IRQ_NAXIERRIRQ		155
+#define RZN1_IRQ_NCTIIRQ_0		156
+#define RZN1_IRQ_NCTIIRQ_1		157
+#define RZN1_IRQ_NPMUIRQ_0		158
+#define RZN1_IRQ_NPMUIRQ_1		159
+
+#endif /* __RZN1_IRQ_H__ */
diff --git a/include/dt-bindings/pinctrl/pinctrl-rzn1.h b/include/dt-bindings/pinctrl/pinctrl-rzn1.h
new file mode 100644
index 0000000..93214eb
--- /dev/null
+++ b/include/dt-bindings/pinctrl/pinctrl-rzn1.h
@@ -0,0 +1,197 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PINCTRL_RZN1_H__
+#define __PINCTRL_RZN1_H__
+
+#define RZN1_MUX_FUNC_BIT			8
+#define RZN1_MUX_HAS_FUNC_BIT			15
+#define RZN1_MUX_HAS_DRIVE_BIT			16
+#define RZN1_MUX_DRIVE_BIT			17
+#define RZN1_MUX_HAS_PULL_BIT			19
+#define RZN1_MUX_PULL_BIT			20
+
+#define RZN1_MUX_PULL_UP			1
+#define RZN1_MUX_PULL_DOWN			3
+#define RZN1_MUX_PULL_NONE			0
+
+#define RZN1_MUX_DRIVE_4MA			0
+#define RZN1_MUX_DRIVE_6MA			1
+#define RZN1_MUX_DRIVE_8MA			2
+#define RZN1_MUX_DRIVE_12MA			3
+
+#define RZN1_MUX(_gpio, _func) \
+	(((RZN1_FUNC_##_func) << RZN1_MUX_FUNC_BIT) | \
+		(1 << RZN1_MUX_HAS_FUNC_BIT) | \
+		(_gpio))
+
+#define RZN1_MUX_PULL(_pull) \
+		((1 << RZN1_MUX_HAS_PULL_BIT) | \
+		((_pull) << RZN1_MUX_PULL_BIT))
+
+#define RZN1_MUX_DRIVE(_drive) \
+		((1 << RZN1_MUX_HAS_DRIVE_BIT) | \
+		((_drive) << RZN1_MUX_DRIVE_BIT))
+
+#define RZN1_MUX_PUP(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_PULL(RZN1_MUX_PULL_UP))
+#define RZN1_MUX_PDOWN(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_PULL(RZN1_MUX_PULL_DOWN))
+#define RZN1_MUX_PNONE(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_PULL(RZN1_MUX_PULL_NONE))
+
+#define RZN1_MUX_4MA(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_4MA))
+#define RZN1_MUX_6MA(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_6MA))
+#define RZN1_MUX_8MA(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_8MA))
+#define RZN1_MUX_12MA(_gpio, _func) \
+	(RZN1_MUX(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_12MA))
+
+#define RZN1_MUX_PUP_4MA(_gpio, _func) \
+	(RZN1_MUX_PUP(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_4MA))
+#define RZN1_MUX_PUP_6MA(_gpio, _func) \
+	(RZN1_MUX_PUP(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_6MA))
+#define RZN1_MUX_PUP_8MA(_gpio, _func) \
+	(RZN1_MUX_PUP(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_8MA))
+#define RZN1_MUX_PUP_12MA(_gpio, _func) \
+	(RZN1_MUX_PUP(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_12MA))
+
+#define RZN1_MUX_PDOWN_4MA(_gpio, _func) \
+	(RZN1_MUX_PDOWN(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_4MA))
+#define RZN1_MUX_PDOWN_6MA(_gpio, _func) \
+	(RZN1_MUX_PDOWN(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_6MA))
+#define RZN1_MUX_PDOWN_8MA(_gpio, _func) \
+	(RZN1_MUX_PDOWN(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_8MA))
+#define RZN1_MUX_PDOWN_12MA(_gpio, _func) \
+	(RZN1_MUX_PDOWN(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_12MA))
+
+#define RZN1_MUX_PNONE_4MA(_gpio, _func) \
+	(RZN1_MUX_PNONE(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_4MA))
+#define RZN1_MUX_PNONE_6MA(_gpio, _func) \
+	(RZN1_MUX_PNONE(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_6MA))
+#define RZN1_MUX_PNONE_8MA(_gpio, _func) \
+	(RZN1_MUX_PNONE(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_8MA))
+#define RZN1_MUX_PNONE_12MA(_gpio, _func) \
+	(RZN1_MUX_PNONE(_gpio, _func) | RZN1_MUX_DRIVE(RZN1_MUX_DRIVE_12MA))
+
+
+/* Use these "gpio" numbers with the RZN1_FUNC_MDIO_MUX* functions
+ * to set the destination of the two MDIO busses. */
+#define RZN1_MDIO_BUS0				170
+#define RZN1_MDIO_BUS1				171
+
+#define RZN1_FUNC_HIGHZ				0
+#define RZN1_FUNC_0L				1
+#define RZN1_FUNC_CLK_ETH_MII_RGMII_RMII	2
+#define RZN1_FUNC_CLK_ETH_NAND			3
+#define RZN1_FUNC_QSPI				4
+#define RZN1_FUNC_SDIO				5
+#define RZN1_FUNC_LCD				6
+#define RZN1_FUNC_LCD_E				7
+#define RZN1_FUNC_MSEBIM			8
+#define RZN1_FUNC_MSEBIS			9
+#define RZN1_FUNC_LEVEL2_OFFSET			10	/* I'm Special */
+#define RZN1_FUNC_HIGHZ1			10
+#define RZN1_FUNC_ETHERCAT			11
+#define RZN1_FUNC_SERCOS3			12
+#define RZN1_FUNC_SDIO_E			13
+#define RZN1_FUNC_ETH_MDIO			14
+#define RZN1_FUNC_ETH_MDIO_E1			15
+#define RZN1_FUNC_USB				16
+#define RZN1_FUNC_MSEBIM_E			17
+#define RZN1_FUNC_MSEBIS_E			18
+#define RZN1_FUNC_RSV				19
+#define RZN1_FUNC_RSV_E				20
+#define RZN1_FUNC_RSV_E1			21
+#define RZN1_FUNC_UART0_I			22
+#define RZN1_FUNC_UART0_I_E			23
+#define RZN1_FUNC_UART1_I			24
+#define RZN1_FUNC_UART1_I_E			25
+#define RZN1_FUNC_UART2_I			26
+#define RZN1_FUNC_UART2_I_E			27
+#define RZN1_FUNC_UART0				28
+#define RZN1_FUNC_UART0_E			29
+#define RZN1_FUNC_UART1				30
+#define RZN1_FUNC_UART1_E			31
+#define RZN1_FUNC_UART2				32
+#define RZN1_FUNC_UART2_E			33
+#define RZN1_FUNC_UART3				34
+#define RZN1_FUNC_UART3_E			35
+#define RZN1_FUNC_UART4				36
+#define RZN1_FUNC_UART4_E			37
+#define RZN1_FUNC_UART5				38
+#define RZN1_FUNC_UART5_E			39
+#define RZN1_FUNC_UART6				40
+#define RZN1_FUNC_UART6_E			41
+#define RZN1_FUNC_UART7				42
+#define RZN1_FUNC_UART7_E			43
+#define RZN1_FUNC_SPI0_M			44
+#define RZN1_FUNC_SPI0_M_E			45
+#define RZN1_FUNC_SPI1_M			46
+#define RZN1_FUNC_SPI1_M_E			47
+#define RZN1_FUNC_SPI2_M			48
+#define RZN1_FUNC_SPI2_M_E			49
+#define RZN1_FUNC_SPI3_M			50
+#define RZN1_FUNC_SPI3_M_E			51
+#define RZN1_FUNC_SPI4_S			52
+#define RZN1_FUNC_SPI4_S_E			53
+#define RZN1_FUNC_SPI5_S			54
+#define RZN1_FUNC_SPI5_S_E			55
+#define RZN1_FUNC_SGPIO0_M			56
+#define RZN1_FUNC_SGPIO1_M			57
+#define RZN1_FUNC_GPIO				58
+#define RZN1_FUNC_CAN				59
+#define RZN1_FUNC_I2C				60
+#define RZN1_FUNC_SAFE				61
+#define RZN1_FUNC_PTO_PWM			62
+#define RZN1_FUNC_PTO_PWM1			63
+#define RZN1_FUNC_PTO_PWM2			64
+#define RZN1_FUNC_PTO_PWM3			65
+#define RZN1_FUNC_PTO_PWM4			66
+#define RZN1_FUNC_DELTA_SIGMA			67
+#define RZN1_FUNC_SGPIO2_M			68
+#define RZN1_FUNC_SGPIO3_M			69
+#define RZN1_FUNC_SGPIO4_S			70
+#define RZN1_FUNC_MAC_MTIP_SWITCH		71
+#define RZN1_FUNC_MDIO_MUX_HIGHZ		72
+#define RZN1_FUNC_MDIO_MUX_MAC0			73
+#define RZN1_FUNC_MDIO_MUX_MAC1			74
+#define RZN1_FUNC_MDIO_MUX_ECAT			75
+#define RZN1_FUNC_MDIO_MUX_S3_MDIO0		76
+#define RZN1_FUNC_MDIO_MUX_S3_MDIO1		77
+#define RZN1_FUNC_MDIO_MUX_HWRTOS		78
+#define RZN1_FUNC_MDIO_MUX_SWITCH		79
+#define RZN1_FUNC_MAX				80
+
+#define RZN1_FUNC_NONE				0xff
+
+
+#endif /* __PINCTRL_RZN1_H__ */
diff --git a/include/dt-bindings/soc/rzn1-memory-map.h b/include/dt-bindings/soc/rzn1-memory-map.h
new file mode 100644
index 0000000..d20adea
--- /dev/null
+++ b/include/dt-bindings/soc/rzn1-memory-map.h
@@ -0,0 +1,199 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_MEMORY_MAP_H__
+#define __RZN1_MEMORY_MAP_H__
+
+#define RZN1_ROM_BASE			0x00000000
+#define RZN1_ROM_SIZE			0x10000		/* 64 KB */
+#define RZN1_SRAM_ID_BASE		0x04000000
+#define RZN1_SRAM_ID_SIZE		0x100000	/* 1 MB */
+#define RZN1_V_QSPI_BASE		0x10000000
+#define RZN1_V_QSPI_SIZE		0x10000000	/* 256 MB */
+#define RZN1_SRAM_SYS_BASE		0x20000000
+#define RZN1_SRAM_SYS_SIZE		0x100000	/* 1 MB */
+#define RZN1_QSPI_BASE			0x40005000
+#define RZN1_QSPI_SIZE			0x1000		/* 4 KB */
+#define RZN1_RTC_BASE			0x40006000
+#define RZN1_RTC_SIZE			0x1000		/* 4 KB */
+#define RZN1_OTP_BASE			0x40007000
+#define RZN1_OTP_SIZE			0x1000		/* 4 KB */
+#define RZN1_WATCHDOG0_BASE		0x40008000
+#define RZN1_WATCHDOG0_SIZE		0x1000		/* 4 KB */
+#define RZN1_WATCHDOG1_BASE		0x40009000
+#define RZN1_WATCHDOG1_SIZE		0x1000		/* 4 KB */
+#define RZN1_WATCHDOG_M3_BASE		0x4000A000
+#define RZN1_WATCHDOG_M3_SIZE		0x1000		/* 4 KB */
+#define RZN1_MAILBOX_BASE		0x4000B000
+#define RZN1_MAILBOX_SIZE		0x1000		/* 4 KB */
+#define RZN1_SYSTEM_CTRL_BASE		0x4000C000
+#define RZN1_SYSTEM_CTRL_SIZE		0x1000		/* 4 KB */
+#define RZN1_DDR_BASE			0x4000D000
+#define RZN1_DDR_SIZE			0x1000		/* 4 KB */
+#define RZN1_DDRPHY_BASE		0x4000E000
+#define RZN1_DDRPHY_SIZE		0x1000		/* 4 KB */
+#define RZN1_QSPI1_BASE			0x4000E000	/* RZ/N1S only */
+#define RZN1_QSPI1_SIZE			0x1000		/* 4 KB */
+#define RZN1_PACKET_ENGINE_BASE		0x40010000
+#define RZN1_PACKET_ENGINE_SIZE		0x1000		/* 4 KB */
+#define RZN1_USB_DEV_BASE		0x4001E000
+#define RZN1_USB_DEV_SIZE		0x2000		/* 8 KB */
+#define RZN1_USB_HOST_BASE		0x40020000
+#define RZN1_USB_HOST_SIZE		0x20000		/* 128 KB */
+#define RZN1_PUBLIC_KEY_PROC_BASE	0x40040000
+#define RZN1_PUBLIC_KEY_PROC_SIZE	0x10000		/* 64 KB */
+#define RZN1_UART0_BASE			0x40060000
+#define RZN1_UART0_SIZE			0x400		/* 1 KB */
+#define RZN1_UART1_BASE			0x40061000
+#define RZN1_UART1_SIZE			0x400		/* 1 KB */
+#define RZN1_UART2_BASE			0x40062000
+#define RZN1_UART2_SIZE			0x400		/* 1 KB */
+#define RZN1_I2C0_BASE			0x40063000
+#define RZN1_I2C0_SIZE			0x100		/* 256 bytes */
+#define RZN1_I2C1_BASE			0x40064000
+#define RZN1_I2C1_SIZE			0x100		/* 256 bytes */
+#define RZN1_ADC_BASE			0x40065000
+#define RZN1_ADC_SIZE			0x1000		/* 4 KB */
+#define RZN1_CONFIG_SOC_BASE		0x40066000
+#define RZN1_CONFIG_SOC_SIZE		0x2000		/* 8 KB */
+#define RZN1_PINCTRL_BASE		0x40067000
+#define RZN1_PINCTRL_SIZE		0x1000		/* 4 KB */
+#define RZN1_PWM_BASE			0x40068000
+#define RZN1_PWM_SIZE			0x4000		/* 16 KB */
+#define RZN1_DELTASIGMA_BASE		0x4006C000
+#define RZN1_DELTASIGMA_SIZE		0x400		/* 1 KB */
+#define RZN1_SGPIO0_BASE		0x4006D000
+#define RZN1_SGPIO0_SIZE		0x400		/* 1 KB */
+#define RZN1_SGPIO1_BASE		0x4006E000
+#define RZN1_SGPIO1_SIZE		0x400		/* 1 KB */
+#define RZN1_MSEBI_M1_BASE		0x40080000
+#define RZN1_MSEBI_M1_SIZE		0x40000		/* 256 KB */
+#define RZN1_MSEBI_M0_BASE		0x400C0000
+#define RZN1_MSEBI_M0_SIZE		0x2000		/* 8 KB */
+#define RZN1_MSEBI_S_BASE		0x400C2000
+#define RZN1_MSEBI_S_SIZE		0x1000		/* 4 KB */
+#define RZN1_RIN_CTRL_REG_BASE		0x400E0000
+#define RZN1_RIN_CTRL_REG_SIZE		0x20000		/* 128 KB */
+#define RZN1_SDIO0_BASE			0x40100000
+#define RZN1_SDIO0_SIZE			0x1000		/* 4 KB */
+#define RZN1_SDIO1_BASE			0x40101000
+#define RZN1_SDIO1_SIZE			0x1000		/* 4 KB */
+#define RZN1_NAND_BASE			0x40102000
+#define RZN1_NAND_SIZE			0x2000		/* 8 KB */
+#define RZN1_DMA0_BASE			0x40104000
+#define RZN1_DMA0_SIZE			0x1000		/* 4 KB */
+#define RZN1_DMA1_BASE			0x40105000
+#define RZN1_DMA1_SIZE			0x1000		/* 4 KB */
+#define RZN1_GMAC0_BASE			0x44000000
+#define RZN1_GMAC0_SIZE			0x2000		/* 8 KB */
+#define RZN1_GMAC1_BASE			0x44002000
+#define RZN1_GMAC1_SIZE			0x2000		/* 8 KB */
+#define RZN1_ETHERCAT_BASE		0x44010000
+#define RZN1_ETHERCAT_SIZE		0x10000		/* 64 KB */
+#define RZN1_SERCOS_BASE		0x44020000
+#define RZN1_SERCOS_SIZE		0x10000		/* 64 KB */
+#define RZN1_SWITCH_CTRL_REG_BASE	0x44030000
+#define RZN1_SWITCH_CTRL_REG_SIZE	0x10000		/* 64 KB */
+#define RZN1_CPU_BASE			0x44040000
+#define RZN1_CPU_SIZE			0x8000		/* 32 KB */
+#define RZN1_CORE_BASE			0x44048000
+#define RZN1_CORE_SIZE			0x4000		/* 16 KB */
+#define RZN1_PTP_BASE			0x4404C000
+#define RZN1_PTP_SIZE			0x4000		/* 16 KB */
+#define RZN1_SWITCH_BASE		0x44050000
+#define RZN1_SWITCH_SIZE		0x10000		/* 64 KB */
+#define RZN1_GIC_BASE			0x44100000
+#define RZN1_GIC_SIZE			0x8000		/* 32 KB */
+#define RZN1_CSDAP_BASE			0x45000000
+#define RZN1_CSDAP_SIZE			0x200000	/* 2 MB */
+#define RZN1_UART3_BASE			0x50000000
+#define RZN1_UART3_SIZE			0x400		/* 1 KB */
+#define RZN1_UART4_BASE			0x50001000
+#define RZN1_UART4_SIZE			0x400		/* 1 KB */
+#define RZN1_UART5_BASE			0x50002000
+#define RZN1_UART5_SIZE			0x400		/* 1 KB */
+#define RZN1_UART6_BASE			0x50003000
+#define RZN1_UART6_SIZE			0x400		/* 1 KB */
+#define RZN1_UART7_BASE			0x50004000
+#define RZN1_UART7_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI0_BASE			0x50005000
+#define RZN1_SPI0_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI1_BASE			0x50006000
+#define RZN1_SPI1_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI2_BASE			0x50007000
+#define RZN1_SPI2_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI3_BASE			0x50008000
+#define RZN1_SPI3_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI4_BASE			0x50009000
+#define RZN1_SPI4_SIZE			0x400		/* 1 KB */
+#define RZN1_SPI5_BASE			0x5000A000
+#define RZN1_SPI5_SIZE			0x400		/* 1 KB */
+#define RZN1_GPIO0_BASE			0x5000B000
+#define RZN1_GPIO0_SIZE			0x80		/* 128 bytes */
+#define RZN1_GPIO1_BASE			0x5000C000
+#define RZN1_GPIO1_SIZE			0x80		/* 128 bytes */
+#define RZN1_GPIO2_BASE			0x5000D000
+#define RZN1_GPIO2_SIZE			0x80		/* 128 bytes */
+#define RZN1_SGPIO3_BASE		0x5000F000
+#define RZN1_SGPIO3_SIZE		0x400		/* 1 KB */
+#define RZN1_SGPIO4_BASE		0x50010000
+#define RZN1_SGPIO4_SIZE		0x400		/* 1 KB */
+#define RZN1_PINCTRL_L2_BASE		0x51000000
+#define RZN1_PINCTRL_L2_SIZE		0x800		/* 2 KB */
+#define RZN1_TIMER0_BASE		0x51001000
+#define RZN1_TIMER0_SIZE		0x400		/* 1 KB */
+#define RZN1_TIMER1_BASE		0x51002000
+#define RZN1_TIMER1_SIZE		0x400		/* 1 KB */
+#define RZN1_WATCHDOGSAFE0_BASE		0x51003000
+#define RZN1_WATCHDOGSAFE0_SIZE		0x400		/* 1 KB */
+#define RZN1_WATCHDOGSAFE1_BASE		0x51004000
+#define RZN1_WATCHDOGSAFE1_SIZE		0x400		/* 1 KB */
+#define RZN1_CLKMONITORING_BASE		0x51005000
+#define RZN1_CLKMONITORING_SIZE		0x400		/* 1 KB */
+#define RZN1_RESET_BASE			0x51006000
+#define RZN1_RESET_SIZE			0x400		/* 1 KB */
+#define RZN1_RSV_MEM_BASE		0x52000000
+#define RZN1_RSV_MEM_SIZE		0x100000	/* 1 MB */
+#define RZN1_RSV_REG_BASE		0x52100000
+#define RZN1_RSV_REG_SIZE		0x4000		/* 16 KB */
+#define RZN1_CAN0_BASE			0x52104000
+#define RZN1_CAN0_SIZE			0x800		/* 2 KB */
+#define RZN1_CAN1_BASE			0x52105000
+#define RZN1_CAN1_SIZE			0x800		/* 2 KB */
+#define RZN1_RSV_ID_BASE		0x52200000
+#define RZN1_RSV_ID_SIZE		0x20000		/* 128 KB */
+#define RZN1_SEMAPHORE_BASE		0x53000000
+#define RZN1_SEMAPHORE_SIZE		0x4000		/* 16 KB */
+#define RZN1_LCD_BASE			0x53004000
+#define RZN1_LCD_SIZE			0x1000		/* 4 KB */
+#define RZN1_V_DDR_BASE			0x80000000
+#define RZN1_V_QSPI1_BASE		0xA0000000	/* RZ/N1S only */
+#define RZN1_V_QSPI1_SIZE		0x10000000	/* 256 MB */
+
+#endif /* __RZN1_MEMORY_MAP_H__ */
diff --git a/include/dt-bindings/soc/rzn1-sysctrl.h b/include/dt-bindings/soc/rzn1-sysctrl.h
new file mode 100644
index 0000000..5042b51
--- /dev/null
+++ b/include/dt-bindings/soc/rzn1-sysctrl.h
@@ -0,0 +1,768 @@
+/*
+ * This file was autogenerated
+ * DO NOT EDIT
+ * (C) 2015-2016 Renesas Electronics Europe, LTD
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RZN1_SYSCTRL_H__
+#define __RZN1_SYSCTRL_H__
+
+
+/*
+ * Auto-generated from SYSCTRL_ipxact.xml
+ */
+#define RZN1_SYSCTRL_REG_CFG_USB		0x0
+#define RZN1_SYSCTRL_REG_CFG_USB_DIRPD			0
+#define RZN1_SYSCTRL_REG_CFG_USB_H2MODE			1
+#define RZN1_SYSCTRL_REG_CFG_USB_FRCLK48MOD		2
+#define RZN1_SYSCTRL_REG_OPMODE			0x4
+#define RZN1_SYSCTRL_REG_OPMODE_DDRMOD			0
+#define RZN1_SYSCTRL_REG_OPMODE_OPPMOD			1
+#define RZN1_SYSCTRL_REG_OPMODE_CA7BOOTSRC		2
+#define RZN1_SYSCTRL_REG_OPMODE_CA7BOOTSRC_MASK		0xc
+#define RZN1_SYSCTRL_REG_OPMODE_CM3BOOTSEL		4
+#define RZN1_SYSCTRL_REG_OPMODE_LCD2PU			5
+#define RZN1_SYSCTRL_REG_OPMODE_LCD1PU			6
+#define RZN1_SYSCTRL_REG_CFG_SDIO0		0x8
+#define RZN1_SYSCTRL_REG_CFG_SDIO0_BASECLKFREQ		0
+#define RZN1_SYSCTRL_REG_CFG_SDIO0_BASECLKFREQ_MASK	0xff
+#define RZN1_SYSCTRL_REG_CFG_SDIO0_SLOTTYPE		8
+#define RZN1_SYSCTRL_REG_CFG_SDIO0_SLOTTYPE_MASK	0x300
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0		0xc
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO0		0x10
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO0_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO0_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO0_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_DBGCON			0x14
+#define RZN1_SYSCTRL_REG_DBGCON_PR_DBG_EN		0
+#define RZN1_SYSCTRL_REG_DBGCON_CM3WD_DBG_EN		1
+#define RZN1_SYSCTRL_REG_DBGCON_CA7WD0_DBG_EN		2
+#define RZN1_SYSCTRL_REG_DBGCON_CA7WD1_DBG_EN		3
+#define RZN1_SYSCTRL_REG_SYSSTAT		0x18
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFE		0
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFE_MASK	0x3
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFI		2
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFI_MASK	0xc
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_STANDBYWFIL2	4
+#define RZN1_SYSCTRL_REG_SYSSTAT_CA7_COREVDDON		5
+#define RZN1_SYSCTRL_REG_SYSSTAT_PKGMODE		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB		0x1c
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_MIREQ_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_MIREQ_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_CLKEN_C		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_CLKEN_E		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_USB_RSTN_F		7
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB		0x20
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB_MIRACK_B		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_USB_MISTAT_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO		0x24
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_MIREQ_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_SLVRDY_B	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_CRYPTO_RSTN_A_ZERO	6
+#define RZN1_SYSCTRL_REG_PWRSTAT_CRYPTO		0x28
+#define RZN1_SYSCTRL_REG_PWRSTAT_CRYPTO_MIRACK_A	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_CRYPTO_MISTAT_A	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_CRYPTO_SCON_B		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI		0x2c
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_MSEBI_SLVRDY_B		6
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI		0x30
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_MSEBI_SCON_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0		0x34
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_C		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_C		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_C		8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_D		9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_D		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_D		11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_E		12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_E		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_E		14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_F		15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_F		16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_SLVRDY_F		17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_H1		18
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_H1		19
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_H2		20
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_H2		21
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_I1		22
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_I1		23
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_I2		24
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_I2		25
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_J1		26
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_J1		27
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_CLKEN_J2		28
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_RSTN_J2		29
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_0_UARTCLKSEL	30
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0		0x38
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_B		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_C		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_D		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_E		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_F		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_N		6
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_O		7
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_P		8
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG0_SCON_R		9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1		0x3c
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_N		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_N		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_SLVRDY_N		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_O		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_O		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_SLVRDY_O		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_K		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_K		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_L		8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_L		9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_M		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_M		11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_P		12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_P		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_SLVRDY_P		14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_CLKEN_R		15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_RSTN_R		16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_1_SLVRDY_R		17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1	0x40
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_A	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_A	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_B	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_B	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_C	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_C		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_C	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_D	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_D		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_D	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_E	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_E		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_E	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_F	15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_F		16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_F	17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_G	18
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_G		19
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_G	20
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_H	21
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_H		22
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_H	23
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_I	24
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_I		25
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_I	26
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_CLKEN_J	27
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_RSTN_J		28
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW1_SLVRDY_J	29
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2	0x44
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_K	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_K		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_K	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_L	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_L		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_L	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_M	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_M		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_M	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_N	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_N		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_N	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_O	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_O		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_O	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_CLKEN_P	15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_RSTN_P		16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_FW2_SLVRDY_P	17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV	0x48
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV_DIV	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA		0x4c
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_SLVRDY_B		6
+#define RZN1_SYSCTRL_REG_PWRCTRL_DMA_MIREQ_B		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH		0x50
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_SLVRDY_A	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASH_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0		0x54
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA		0x58
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_SCON_B		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_MIRACK_B		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_DMA_MISTAT_B		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_NFLASH		0x5c
+#define RZN1_SYSCTRL_REG_PWRSTAT_NFLASH_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_NFLASH_MIRACK_A	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_NFLASH_MISTAT_A	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI0		0x60
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI0_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI0_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI0_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV	0x64
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC		0x64
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_MIREQ_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_RSTN_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_DDRC_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_EETH		0x68
+#define RZN1_SYSCTRL_REG_PWRCTRL_EETH_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_EETH_CLKEN_B		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_EETH_CLKEN_C		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0		0x6c
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC0_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1		0x70
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_MAC1_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_DDRC		0x74
+#define RZN1_SYSCTRL_REG_PWRSTAT_DDRC_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_DDRC_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC0		0x78
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC0_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC0_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC0_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC1		0x7c
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC1_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC1_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_MAC1_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT		0x80
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_MIREQ_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_RSTN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_ECAT_CLKEN_C		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS		0x84
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_MIREQ_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_RSTN_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_RSTN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_SERCOS_CLKEN_C		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_ECAT		0x88
+#define RZN1_SYSCTRL_REG_PWRSTAT_ECAT_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_ECAT_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_SERCOS		0x8c
+#define RZN1_SYSCTRL_REG_PWRSTAT_SERCOS_MIRACK_A	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_SERCOS_MISTAT_A	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1		0x90
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI1_RSTN_B		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR		0x90
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_MIREQ_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_RSTN_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_CLKEN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_CLKEN_C		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_HSR_RSTN_C		5
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV	0x94
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHDIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI1		0x98
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI1_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI1_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_QSPI1_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_HSR		0x98
+#define RZN1_SYSCTRL_REG_PWRSTAT_HSR_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_HSR_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_SWITCH		0x9c
+#define RZN1_SYSCTRL_REG_PWRSTAT_SWITCH_SCON_A		0
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX		0xa0
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX0		0
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX1		1
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX2		2
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX3		3
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX4		4
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX5		5
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX6		6
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX7		7
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX8		8
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX9		9
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX10		10
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX11		11
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX12		12
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX13		13
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX14		14
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D1MX15		15
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX0		16
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX1		17
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX2		18
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX3		19
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX4		20
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX5		21
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX6		22
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX7		23
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX8		24
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX9		25
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX10		26
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX11		27
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX12		28
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX13		29
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX14		30
+#define RZN1_SYSCTRL_REG_CFG_DMAMUX_D2MX15		31
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_1A	0xa4
+#define RZN1_SYSCTRL_REG_RSTSTAT		0xa8
+#define RZN1_SYSCTRL_REG_RSTSTAT_WDA7RST_ST		1
+#define RZN1_SYSCTRL_REG_RSTSTAT_WDA7RST_ST_MASK	0x6
+#define RZN1_SYSCTRL_REG_RSTSTAT_WDM3RST_ST		3
+#define RZN1_SYSCTRL_REG_RSTSTAT_CM3LOCKUPRST_ST	4
+#define RZN1_SYSCTRL_REG_RSTSTAT_CM3SYSRESET_ST		5
+#define RZN1_SYSCTRL_REG_RSTSTAT_SWRST_ST		6
+#define RZN1_SYSCTRL_REG_RSTSTAT_PORRST_ST		31
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_1B	0xb0
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_2A	0xb4
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_2B	0xb8
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC		0xbc
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG0		0
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG0_MASK	0x1f
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG1		8
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG1_MASK	0x1f00
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG2		16
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG2_MASK	0x1f0000
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG3		24
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_TSRC_TRIG3_MASK	0x1f000000
+#define RZN1_SYSCTRL_REG_USBSTAT		0xc0
+#define RZN1_SYSCTRL_REG_USBSTAT_PLL_LOCK		0
+#define RZN1_SYSCTRL_REG_CFG_SDIO1		0xc4
+#define RZN1_SYSCTRL_REG_CFG_SDIO1_BASECLKFREQ		0
+#define RZN1_SYSCTRL_REG_CFG_SDIO1_BASECLKFREQ_MASK	0xff
+#define RZN1_SYSCTRL_REG_CFG_SDIO1_SLOTTYPE		8
+#define RZN1_SYSCTRL_REG_CFG_SDIO1_SLOTTYPE_MASK	0x300
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1		0xc8
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_MIREQ_A		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1_CLKEN_B		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO1		0xcc
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO1_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO1_MIRACK_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_SDIO1_MISTAT_A		2
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT	0xd0
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_F_SEC	0
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_I_SEC	1
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_Z_SEC	2
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_YD_SEC	3
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_YC_SEC	4
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_YS_SEC	5
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_CSA_SEC	6
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_INIT_CSB_SEC	7
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG	0xd4
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_UA_SEC	0
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_UB_SEC	1
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_J_SEC	2
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_K_SEC	3
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_NA_SEC	4
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_NB_SEC	5
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_QA_SEC	6
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_QB_SEC	7
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_RA_SEC	8
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_PC_SEC	9
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_MA_SEC	10
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_MB_SEC	11
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_MC_SEC	12
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_MD_SEC	13
+#define RZN1_SYSCTRL_REG_CFG_FW_STATIC_TZA_TARG_W_SEC	14
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_3A	0xd8
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_3B	0xdc
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_3B_PORTEN	0
+#define RZN1_SYSCTRL_REG_CFG_GPIOT_PTEN_3B_PORTEN_MASK	0x3ff
+#define RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV		0xe0
+#define RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV_DIV_MASK	0x1f
+#define RZN1_SYSCTRL_REG_PWRCTRL_OPPDIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV		0xe4
+#define RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV_DIV_MASK	0x7
+#define RZN1_SYSCTRL_REG_PWRCTRL_CA7DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ	0xe8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_Q	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_Q	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_Q	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_R	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_R	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_R	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_S	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_S	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_S	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_T	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_T	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_T	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_U	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_U	13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_U	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_V	15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_V	16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_V	17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_W	18
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_W	19
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_W	20
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_CLKEN_X	21
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_RSTN_X	22
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG2_25MHZ_SLVRDY_X	23
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2	0xec
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AG1	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AG1	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AG2	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AG2	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AH1	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AH1	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AH2	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AH2	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AI1	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AI1	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AI2	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AI2	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AJ1	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AJ1	13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AJ2	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AJ2	15
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AK1	16
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AK1	17
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AK2	18
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AK2	19
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AL1	20
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AL1	21
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_CLKEN_AL2	22
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_RSTN_AL2	23
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2_UARTCLKSEL	24
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ	0xf0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_Y	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_Y	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_SLVRDY_Y	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_Z	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_Z	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_SLVRDY_Z	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_AA	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_AA	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_SLVRDY_AA	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_AB	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_AB	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_SLVRDY_AB	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_CLKEN_UF	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_RSTN_UF	13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG3_48MHZ_MIREQ_UF	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW		0xf4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_AC	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_AC		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_SLVRDY_AC	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_AD	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_AD		4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_SLVRDY_AD	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_AE	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_AE		7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_SLVRDY_AE	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_AF	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_AF		10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_SLVRDY_AF	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_CLKEN_UI	12
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_RSTN_UI		13
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_FW_MIREQ_UI	14
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV	0xf8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR2DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3	0xfc
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_CLKEN_AM	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_RSTN_AM	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_CLKEN_AN	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_RSTN_AN	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_CLKEN_AO	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_RSTN_AO	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_CLKEN_AP	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3_RSTN_AP	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV	0x100
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR3DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4	0x104
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_CLKEN_AQ	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_RSTN_AQ	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_CLKEN_AR	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_RSTN_AR	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_CLKEN_AS	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_RSTN_AS	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_CLKEN_AT	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4_RSTN_AT	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV	0x108
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG1_PR4DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1	0x10c
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_CLKEN_AU	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_RSTN_AU	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_CLKEN_AV	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_RSTN_AV	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_CLKEN_AW	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_RSTN_AW	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_CLKEN_AX	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1_RSTN_AX	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV	0x110
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG4_PR1DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6	0x114
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_CLKEN_BC	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_RSTN_BC	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_SLVRDY_BC	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_CLKEN_BD	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_RSTN_BD	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_SLVRDY_BD	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_CLKEN_BE	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_RSTN_BE	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_SLVRDY_BE	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_CLKEN_BF	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_RSTN_BF	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PGEXT2_PR6_SLVRDY_BF	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5	0x118
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_CLKEN_AZ	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_RSTN_AZ	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_SLVRDY_AZ	5
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_CLKEN_BA	6
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_RSTN_BA	7
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_SLVRDY_BA	8
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_CLKEN_BB	9
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_RSTN_BB	10
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5_SLVRDY_BB	11
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV	0x11c
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG5_PR5DIV_BUSY	31
+#define RZN1_SYSCTRL_REG_RSTEN			0x120
+#define RZN1_SYSCTRL_REG_RSTEN_MRESET_EN		0
+#define RZN1_SYSCTRL_REG_RSTEN_WDA7RST_EN		1
+#define RZN1_SYSCTRL_REG_RSTEN_WDA7RST_EN_MASK		0x6
+#define RZN1_SYSCTRL_REG_RSTEN_WDM3RST_EN		3
+#define RZN1_SYSCTRL_REG_RSTEN_CM3LOCKUPRST_EN		4
+#define RZN1_SYSCTRL_REG_RSTEN_CM3SYSRESET_EN		5
+#define RZN1_SYSCTRL_REG_RSTEN_SWRST_EN			6
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV	0x124
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_QSPI0DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV	0x128
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO0DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV	0x12c
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_SDIO1DIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH		0x130
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH_SLVRDY_A	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH_CLKEN_B		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCH_RSTN_B		3
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV	0x134
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV_DIV_MASK	0x3ff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_ADCDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV	0x138
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_I2CDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV	0x13c
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV_DIV	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV_DIV_MASK	0xff
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_UARTDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC		0x140
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC_CLKEN_RTC		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC_RST_RTC		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC_IDLE_REQ		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_RTC_RSTN_FW_RTC	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_RTC		0x144
+#define RZN1_SYSCTRL_REG_PWRSTAT_RTC_RTC_IACK		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_RTC_RTC_IDLE		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_RTC_PWR_GOOD		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV	0x148
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV_DIV		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV_DIV_MASK	0x7f
+#define RZN1_SYSCTRL_REG_PWRCTRL_NFLASHDIV_BUSY		31
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV	0x150
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV_DIV	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV_DIV_MASK	0xf
+#define RZN1_SYSCTRL_REG_PWRCTRL_PG0_MOTORDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_PWRCTRL_ROM		0x154
+#define RZN1_SYSCTRL_REG_PWRCTRL_ROM_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_ROM_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_ROM_SLVRDY_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW		0x158
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_B		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_C		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_D		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_E		4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_F		5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_G		6
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_H		7
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_I		8
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_J		9
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_K		10
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_L		11
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_M		12
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_N		13
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_O		14
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG1_FW_SCON_P		15
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ	0x15c
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_Q	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_R	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_S	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_T	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_U	4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_V	5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_W	6
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG2_25MHZ_SCON_X	7
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ	0x160
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_SCON_Y	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_SCON_Z	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_SCON_AA	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_SCON_AB	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_MIRACK_UF	4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG3_48MHZ_MISTAT_UF	5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW		0x164
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_SCON_AC		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_SCON_AD		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_SCON_AE		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_SCON_AF		3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_MIRACK_UI	4
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG4_FW_MISTAT_UI	5
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG5_PR5	0x168
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG5_PR5_SCON_AZ	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG5_PR5_SCON_BA	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PG5_PR5_SCON_BB	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6	0x16c
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6_SCON_BC	0
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6_SCON_BD	1
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6_SCON_BE	2
+#define RZN1_SYSCTRL_REG_PWRSTAT_PGEXT2_PR6_SCON_BF	3
+#define RZN1_SYSCTRL_REG_PWRSTAT_ROM		0x170
+#define RZN1_SYSCTRL_REG_PWRSTAT_ROM_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_CM3		0x174
+#define RZN1_SYSCTRL_REG_PWRCTRL_CM3_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_CM3_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_CM3_MIREQ_A		2
+#define RZN1_SYSCTRL_REG_PWRSTAT_CM3		0x178
+#define RZN1_SYSCTRL_REG_PWRSTAT_CM3_MIRACK_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_CM3_MISTAT_A		1
+#define RZN1_SYSCTRL_REG_PWRSTAT_RINCTRL	0x17c
+#define RZN1_SYSCTRL_REG_PWRSTAT_RINCTRL_SCON_A		0
+#define RZN1_SYSCTRL_REG_PWRSTAT_SWITCHCTRL	0x180
+#define RZN1_SYSCTRL_REG_PWRSTAT_SWITCHCTRL_SCON_A	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_RINCTRL	0x184
+#define RZN1_SYSCTRL_REG_PWRCTRL_RINCTRL_CLKEN_A	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_RINCTRL_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_RINCTRL_SLVRDY_A	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL	0x188
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_CLKEN_A	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_RSTN_A	1
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_SLVRDY_A	2
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_RSTN_CLK25	3
+#define RZN1_SYSCTRL_REG_PWRCTRL_SWITCHCTRL_RSTN_ETH	4
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS		0x18c
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_CLKEN_A		0
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_RSTN_A		1
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_CLKEN_B		2
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV	0x190
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV_DIV	0
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV_DIV_MASK	0x3ff
+#define RZN1_SYSCTRL_REG_PWRCTRL_HWRTOS_MDCDIV_BUSY	31
+#define RZN1_SYSCTRL_REG_RSTCTRL		0x198
+#define RZN1_SYSCTRL_REG_RSTCTRL_WDA7RST_REQ		1
+#define RZN1_SYSCTRL_REG_RSTCTRL_WDA7RST_REQ_MASK	0x6
+#define RZN1_SYSCTRL_REG_RSTCTRL_WDM3RST_REQ		3
+#define RZN1_SYSCTRL_REG_RSTCTRL_CM3LOCKUPRST_REQ	4
+#define RZN1_SYSCTRL_REG_RSTCTRL_CM3SYSRESET_REQ	5
+#define RZN1_SYSCTRL_REG_RSTCTRL_SWRST_REQ		6
+#define RZN1_SYSCTRL_REG_VERSION		0x19c
+#define RZN1_SYSCTRL_REG_VERSION_MINOR			0
+#define RZN1_SYSCTRL_REG_VERSION_MINOR_MASK		0xf
+#define RZN1_SYSCTRL_REG_VERSION_MAJOR			4
+#define RZN1_SYSCTRL_REG_VERSION_MAJOR_MASK		0xf0
+#define RZN1_SYSCTRL_REG_VERSION_PROD			8
+#define RZN1_SYSCTRL_REG_BOOTADDR		0x204
+
+#define RZN1_SYSCTRL_REGSIZE			520
+
+#endif /* __RZN1_SYSCTRL_H__ */
diff --git a/include/linux/marvell_phy.h b/include/linux/marvell_phy.h
index a57f0df..0761f98 100644
--- a/include/linux/marvell_phy.h
+++ b/include/linux/marvell_phy.h
@@ -16,6 +16,7 @@
 #define MARVELL_PHY_ID_88E1318S		0x01410e90
 #define MARVELL_PHY_ID_88E1116R		0x01410e40
 #define MARVELL_PHY_ID_88E1510		0x01410dd0
+#define MARVELL_PHY_ID_88E1512		0x01410dd4
 #define MARVELL_PHY_ID_88E1540		0x01410eb0
 #define MARVELL_PHY_ID_88E3016		0x01410e60
 
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index c425c7b..6996095 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -177,6 +177,8 @@ struct spi_nor {
 			size_t len, u_char *read_buf);
 	ssize_t (*write)(struct spi_nor *nor, loff_t to,
 			size_t len, const u_char *write_buf);
+	ssize_t (*write_mmap)(struct spi_nor *nor, loff_t to,
+			size_t len, const u_char *write_buf);
 	int (*erase)(struct spi_nor *nor, loff_t offs);
 
 	int (*flash_lock)(struct spi_nor *nor, loff_t ofs, uint64_t len);
diff --git a/include/linux/phy.h b/include/linux/phy.h
index e25f183..20b4ea1 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -427,6 +427,9 @@ struct phy_device {
 	u8 mdix;
 
 	void (*adjust_link)(struct net_device *dev);
+
+	void (*pre_adjust_link)(void *priv);
+	void *pre_adjust_link_priv;
 };
 #define to_phy_device(d) container_of(to_mdio_device(d), \
 				      struct phy_device, mdio)
@@ -761,6 +764,8 @@ struct phy_device *phy_connect(struct net_device *dev, const char *bus_id,
 			       phy_interface_t interface);
 void phy_disconnect(struct phy_device *phydev);
 void phy_detach(struct phy_device *phydev);
+void phy_pre_prepare_link(struct phy_device *phydev, void *priv,
+			  void (*handler)(void *));
 void phy_start(struct phy_device *phydev);
 void phy_stop(struct phy_device *phydev);
 int phy_start_aneg(struct phy_device *phydev);
diff --git a/include/linux/pinctrl-rzn1.h b/include/linux/pinctrl-rzn1.h
new file mode 100644
index 0000000..ced999d
--- /dev/null
+++ b/include/linux/pinctrl-rzn1.h
@@ -0,0 +1,49 @@
+/*
+ * RZ/N1 pinctrl access API
+ *
+ * Copyright (C) 2014-2016 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PINCTRL_RZN1__
+#define __PINCTRL_RZN1__
+
+#include <dt-bindings/pinctrl/pinctrl-rzn1.h>
+
+enum {
+	MDIO_MUX_HIGHZ = 0,
+	MDIO_MUX_MAC0,
+	MDIO_MUX_MAC1,
+	MDIO_MUX_ECAT,
+	MDIO_MUX_S3_MDIO0,
+	MDIO_MUX_S3_MDIO1,
+	MDIO_MUX_HWRTOS,
+	MDIO_MUX_SWITCH,
+};
+
+void rzn1_pinctrl_mdio_select(u8 mdio, u32 func);
+
+enum {
+	GPIOINT_MUX_GPIO0A = 0,
+	GPIOINT_MUX_GPIO1A = (1 << 5),
+	GPIOINT_MUX_GPIO2A = (2 << 5),
+};
+/*
+ * Configures the GPIO interrupt dispatcher mux to route GPIO blocks 0:2 A
+ * block to RZN1_IRQ_GPIO_* -- note that this doesn't do any interupt clearing
+ * or anything else, the interrupt code is responsible for that.
+ *
+ * Use rzn1_pinctrl_gpioint_select(
+ * 		RZN1_IRQ_GPIO_[0:7],
+ * 		GPIOINT_MUX_GPIO[0:2]A + <0:31>);
+ * Note that this doesn't configure the GPIO as input or anything.
+ */
+void rzn1_pinctrl_gpioint_select(u8 gpioint, u8 gpio_source);
+u8 rzn1_pinctrl_gpioint_get(u8 gpioint);
+
+#endif /* __PINCTRL_RZN1__ */
diff --git a/include/linux/sysctrl-rzn1.h b/include/linux/sysctrl-rzn1.h
new file mode 100644
index 0000000..3d9c8d2
--- /dev/null
+++ b/include/linux/sysctrl-rzn1.h
@@ -0,0 +1,37 @@
+/*
+ * RZ/N1 sysctrl access API
+ *
+ * Copyright (C) 2014-2016 Renesas Electronics Europe Limited
+ *
+ * Michel Pollet <michel.pollet@bp.renesas.com>, <buserror@gmail.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __SYSCTRL_RZN1__
+#define __SYSCTRL_RZN1__
+
+#include <linux/io.h>
+#include <dt-bindings/soc/rzn1-memory-map.h>
+#include <dt-bindings/soc/rzn1-sysctrl.h>
+
+/* Good policy for drivers to call this, even tho it's only needed once */
+void __init rzn1_sysctrl_init(void);
+/* Get the base address for the sysctrl block. Use sparingly (clock drivers) */
+void __iomem *rzn1_sysctrl_base(void);
+
+static inline u32 rzn1_sysctrl_readl(u32 reg)
+{
+	BUG_ON(reg >= RZN1_SYSTEM_CTRL_SIZE);
+	return readl(rzn1_sysctrl_base() + reg);
+}
+
+static inline void rzn1_sysctrl_writel(u32 value, u32 reg)
+{
+	BUG_ON(reg >= RZN1_SYSTEM_CTRL_SIZE);
+	writel(value, rzn1_sysctrl_base() + reg);
+}
+
+#endif /* __SYSCTRL_RZN1__ */
diff --git a/net/can/af_can.c b/net/can/af_can.c
index 1108079..2144e05 100644
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@ -312,8 +312,12 @@ int can_send(struct sk_buff *skb, int loop)
 		return err;
 	}
 
-	if (newskb)
+	if (newskb) {
+		if (!(newskb->tstamp.tv64))
+			__net_timestamp(newskb);
+
 		netif_rx_ni(newskb);
+	}
 
 	/* update statistics */
 	can_stats.tx_frames++;
